
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model actividades
 * 
 */
export type actividades = $Result.DefaultSelection<Prisma.$actividadesPayload>
/**
 * Model cache
 * 
 */
export type cache = $Result.DefaultSelection<Prisma.$cachePayload>
/**
 * Model cache_locks
 * 
 */
export type cache_locks = $Result.DefaultSelection<Prisma.$cache_locksPayload>
/**
 * Model clientes
 * 
 */
export type clientes = $Result.DefaultSelection<Prisma.$clientesPayload>
/**
 * Model compania
 * 
 */
export type compania = $Result.DefaultSelection<Prisma.$companiaPayload>
/**
 * Model compania_representantes
 * 
 */
export type compania_representantes = $Result.DefaultSelection<Prisma.$compania_representantesPayload>
/**
 * Model companias_productos
 * 
 */
export type companias_productos = $Result.DefaultSelection<Prisma.$companias_productosPayload>
/**
 * Model companias_ramos
 * 
 */
export type companias_ramos = $Result.DefaultSelection<Prisma.$companias_ramosPayload>
/**
 * Model estados
 * 
 */
export type estados = $Result.DefaultSelection<Prisma.$estadosPayload>
/**
 * Model estatus_cliente
 * 
 */
export type estatus_cliente = $Result.DefaultSelection<Prisma.$estatus_clientePayload>
/**
 * Model estatus_polizas
 * 
 */
export type estatus_polizas = $Result.DefaultSelection<Prisma.$estatus_polizasPayload>
/**
 * Model failed_jobs
 * 
 */
export type failed_jobs = $Result.DefaultSelection<Prisma.$failed_jobsPayload>
/**
 * Model formas_de_pago
 * 
 */
export type formas_de_pago = $Result.DefaultSelection<Prisma.$formas_de_pagoPayload>
/**
 * Model job_batches
 * 
 */
export type job_batches = $Result.DefaultSelection<Prisma.$job_batchesPayload>
/**
 * Model jobs
 * 
 */
export type jobs = $Result.DefaultSelection<Prisma.$jobsPayload>
/**
 * Model metodos_de_pago
 * 
 */
export type metodos_de_pago = $Result.DefaultSelection<Prisma.$metodos_de_pagoPayload>
/**
 * Model migrations
 * 
 */
export type migrations = $Result.DefaultSelection<Prisma.$migrationsPayload>
/**
 * Model monedas
 * 
 */
export type monedas = $Result.DefaultSelection<Prisma.$monedasPayload>
/**
 * Model password_reset_tokens
 * 
 */
export type password_reset_tokens = $Result.DefaultSelection<Prisma.$password_reset_tokensPayload>
/**
 * Model personal_access_tokens
 * 
 */
export type personal_access_tokens = $Result.DefaultSelection<Prisma.$personal_access_tokensPayload>
/**
 * Model poliza_asegurados
 * 
 */
export type poliza_asegurados = $Result.DefaultSelection<Prisma.$poliza_aseguradosPayload>
/**
 * Model poliza_historial
 * 
 */
export type poliza_historial = $Result.DefaultSelection<Prisma.$poliza_historialPayload>
/**
 * Model poliza_recibos
 * 
 */
export type poliza_recibos = $Result.DefaultSelection<Prisma.$poliza_recibosPayload>
/**
 * Model polizas
 * 
 */
export type polizas = $Result.DefaultSelection<Prisma.$polizasPayload>
/**
 * Model ramos
 * 
 */
export type ramos = $Result.DefaultSelection<Prisma.$ramosPayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model tipos_de_usuarios
 * 
 */
export type tipos_de_usuarios = $Result.DefaultSelection<Prisma.$tipos_de_usuariosPayload>
/**
 * Model tipos_de_vencimiento
 * 
 */
export type tipos_de_vencimiento = $Result.DefaultSelection<Prisma.$tipos_de_vencimientoPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model usuario_claves
 * 
 */
export type usuario_claves = $Result.DefaultSelection<Prisma.$usuario_clavesPayload>
/**
 * Model usuario_team
 * 
 */
export type usuario_team = $Result.DefaultSelection<Prisma.$usuario_teamPayload>
/**
 * Model usuarios
 * 
 */
export type usuarios = $Result.DefaultSelection<Prisma.$usuariosPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const poliza_recibos_estatus: {
  Pendiente: 'Pendiente',
  Pagado: 'Pagado',
  Cancelado: 'Cancelado'
};

export type poliza_recibos_estatus = (typeof poliza_recibos_estatus)[keyof typeof poliza_recibos_estatus]

}

export type poliza_recibos_estatus = $Enums.poliza_recibos_estatus

export const poliza_recibos_estatus: typeof $Enums.poliza_recibos_estatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Actividades
 * const actividades = await prisma.actividades.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Actividades
   * const actividades = await prisma.actividades.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.actividades`: Exposes CRUD operations for the **actividades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actividades
    * const actividades = await prisma.actividades.findMany()
    * ```
    */
  get actividades(): Prisma.actividadesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cache`: Exposes CRUD operations for the **cache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caches
    * const caches = await prisma.cache.findMany()
    * ```
    */
  get cache(): Prisma.cacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cache_locks`: Exposes CRUD operations for the **cache_locks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cache_locks
    * const cache_locks = await prisma.cache_locks.findMany()
    * ```
    */
  get cache_locks(): Prisma.cache_locksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientes`: Exposes CRUD operations for the **clientes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.clientes.findMany()
    * ```
    */
  get clientes(): Prisma.clientesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.compania`: Exposes CRUD operations for the **compania** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companias
    * const companias = await prisma.compania.findMany()
    * ```
    */
  get compania(): Prisma.companiaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.compania_representantes`: Exposes CRUD operations for the **compania_representantes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Compania_representantes
    * const compania_representantes = await prisma.compania_representantes.findMany()
    * ```
    */
  get compania_representantes(): Prisma.compania_representantesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companias_productos`: Exposes CRUD operations for the **companias_productos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companias_productos
    * const companias_productos = await prisma.companias_productos.findMany()
    * ```
    */
  get companias_productos(): Prisma.companias_productosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companias_ramos`: Exposes CRUD operations for the **companias_ramos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companias_ramos
    * const companias_ramos = await prisma.companias_ramos.findMany()
    * ```
    */
  get companias_ramos(): Prisma.companias_ramosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estados`: Exposes CRUD operations for the **estados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estados
    * const estados = await prisma.estados.findMany()
    * ```
    */
  get estados(): Prisma.estadosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estatus_cliente`: Exposes CRUD operations for the **estatus_cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estatus_clientes
    * const estatus_clientes = await prisma.estatus_cliente.findMany()
    * ```
    */
  get estatus_cliente(): Prisma.estatus_clienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estatus_polizas`: Exposes CRUD operations for the **estatus_polizas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estatus_polizas
    * const estatus_polizas = await prisma.estatus_polizas.findMany()
    * ```
    */
  get estatus_polizas(): Prisma.estatus_polizasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.failed_jobs`: Exposes CRUD operations for the **failed_jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Failed_jobs
    * const failed_jobs = await prisma.failed_jobs.findMany()
    * ```
    */
  get failed_jobs(): Prisma.failed_jobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formas_de_pago`: Exposes CRUD operations for the **formas_de_pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Formas_de_pagos
    * const formas_de_pagos = await prisma.formas_de_pago.findMany()
    * ```
    */
  get formas_de_pago(): Prisma.formas_de_pagoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_batches`: Exposes CRUD operations for the **job_batches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_batches
    * const job_batches = await prisma.job_batches.findMany()
    * ```
    */
  get job_batches(): Prisma.job_batchesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.jobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metodos_de_pago`: Exposes CRUD operations for the **metodos_de_pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metodos_de_pagos
    * const metodos_de_pagos = await prisma.metodos_de_pago.findMany()
    * ```
    */
  get metodos_de_pago(): Prisma.metodos_de_pagoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.monedas`: Exposes CRUD operations for the **monedas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monedas
    * const monedas = await prisma.monedas.findMany()
    * ```
    */
  get monedas(): Prisma.monedasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password_reset_tokens`: Exposes CRUD operations for the **password_reset_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Password_reset_tokens
    * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
    * ```
    */
  get password_reset_tokens(): Prisma.password_reset_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personal_access_tokens`: Exposes CRUD operations for the **personal_access_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personal_access_tokens
    * const personal_access_tokens = await prisma.personal_access_tokens.findMany()
    * ```
    */
  get personal_access_tokens(): Prisma.personal_access_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poliza_asegurados`: Exposes CRUD operations for the **poliza_asegurados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Poliza_asegurados
    * const poliza_asegurados = await prisma.poliza_asegurados.findMany()
    * ```
    */
  get poliza_asegurados(): Prisma.poliza_aseguradosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poliza_historial`: Exposes CRUD operations for the **poliza_historial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Poliza_historials
    * const poliza_historials = await prisma.poliza_historial.findMany()
    * ```
    */
  get poliza_historial(): Prisma.poliza_historialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poliza_recibos`: Exposes CRUD operations for the **poliza_recibos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Poliza_recibos
    * const poliza_recibos = await prisma.poliza_recibos.findMany()
    * ```
    */
  get poliza_recibos(): Prisma.poliza_recibosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.polizas`: Exposes CRUD operations for the **polizas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Polizas
    * const polizas = await prisma.polizas.findMany()
    * ```
    */
  get polizas(): Prisma.polizasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ramos`: Exposes CRUD operations for the **ramos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ramos
    * const ramos = await prisma.ramos.findMany()
    * ```
    */
  get ramos(): Prisma.ramosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipos_de_usuarios`: Exposes CRUD operations for the **tipos_de_usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipos_de_usuarios
    * const tipos_de_usuarios = await prisma.tipos_de_usuarios.findMany()
    * ```
    */
  get tipos_de_usuarios(): Prisma.tipos_de_usuariosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipos_de_vencimiento`: Exposes CRUD operations for the **tipos_de_vencimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipos_de_vencimientos
    * const tipos_de_vencimientos = await prisma.tipos_de_vencimiento.findMany()
    * ```
    */
  get tipos_de_vencimiento(): Prisma.tipos_de_vencimientoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario_claves`: Exposes CRUD operations for the **usuario_claves** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuario_claves
    * const usuario_claves = await prisma.usuario_claves.findMany()
    * ```
    */
  get usuario_claves(): Prisma.usuario_clavesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario_team`: Exposes CRUD operations for the **usuario_team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuario_teams
    * const usuario_teams = await prisma.usuario_team.findMany()
    * ```
    */
  get usuario_team(): Prisma.usuario_teamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.usuariosDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    actividades: 'actividades',
    cache: 'cache',
    cache_locks: 'cache_locks',
    clientes: 'clientes',
    compania: 'compania',
    compania_representantes: 'compania_representantes',
    companias_productos: 'companias_productos',
    companias_ramos: 'companias_ramos',
    estados: 'estados',
    estatus_cliente: 'estatus_cliente',
    estatus_polizas: 'estatus_polizas',
    failed_jobs: 'failed_jobs',
    formas_de_pago: 'formas_de_pago',
    job_batches: 'job_batches',
    jobs: 'jobs',
    metodos_de_pago: 'metodos_de_pago',
    migrations: 'migrations',
    monedas: 'monedas',
    password_reset_tokens: 'password_reset_tokens',
    personal_access_tokens: 'personal_access_tokens',
    poliza_asegurados: 'poliza_asegurados',
    poliza_historial: 'poliza_historial',
    poliza_recibos: 'poliza_recibos',
    polizas: 'polizas',
    ramos: 'ramos',
    sessions: 'sessions',
    tipos_de_usuarios: 'tipos_de_usuarios',
    tipos_de_vencimiento: 'tipos_de_vencimiento',
    users: 'users',
    usuario_claves: 'usuario_claves',
    usuario_team: 'usuario_team',
    usuarios: 'usuarios'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "actividades" | "cache" | "cache_locks" | "clientes" | "compania" | "compania_representantes" | "companias_productos" | "companias_ramos" | "estados" | "estatus_cliente" | "estatus_polizas" | "failed_jobs" | "formas_de_pago" | "job_batches" | "jobs" | "metodos_de_pago" | "migrations" | "monedas" | "password_reset_tokens" | "personal_access_tokens" | "poliza_asegurados" | "poliza_historial" | "poliza_recibos" | "polizas" | "ramos" | "sessions" | "tipos_de_usuarios" | "tipos_de_vencimiento" | "users" | "usuario_claves" | "usuario_team" | "usuarios"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      actividades: {
        payload: Prisma.$actividadesPayload<ExtArgs>
        fields: Prisma.actividadesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.actividadesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actividadesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.actividadesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actividadesPayload>
          }
          findFirst: {
            args: Prisma.actividadesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actividadesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.actividadesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actividadesPayload>
          }
          findMany: {
            args: Prisma.actividadesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actividadesPayload>[]
          }
          create: {
            args: Prisma.actividadesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actividadesPayload>
          }
          createMany: {
            args: Prisma.actividadesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.actividadesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actividadesPayload>
          }
          update: {
            args: Prisma.actividadesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actividadesPayload>
          }
          deleteMany: {
            args: Prisma.actividadesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.actividadesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.actividadesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$actividadesPayload>
          }
          aggregate: {
            args: Prisma.ActividadesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActividades>
          }
          groupBy: {
            args: Prisma.actividadesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActividadesGroupByOutputType>[]
          }
          count: {
            args: Prisma.actividadesCountArgs<ExtArgs>
            result: $Utils.Optional<ActividadesCountAggregateOutputType> | number
          }
        }
      }
      cache: {
        payload: Prisma.$cachePayload<ExtArgs>
        fields: Prisma.cacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          findFirst: {
            args: Prisma.cacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          findMany: {
            args: Prisma.cacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>[]
          }
          create: {
            args: Prisma.cacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          createMany: {
            args: Prisma.cacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          update: {
            args: Prisma.cacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          deleteMany: {
            args: Prisma.cacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          aggregate: {
            args: Prisma.CacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCache>
          }
          groupBy: {
            args: Prisma.cacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<CacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.cacheCountArgs<ExtArgs>
            result: $Utils.Optional<CacheCountAggregateOutputType> | number
          }
        }
      }
      cache_locks: {
        payload: Prisma.$cache_locksPayload<ExtArgs>
        fields: Prisma.cache_locksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cache_locksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cache_locksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          findFirst: {
            args: Prisma.cache_locksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cache_locksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          findMany: {
            args: Prisma.cache_locksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>[]
          }
          create: {
            args: Prisma.cache_locksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          createMany: {
            args: Prisma.cache_locksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cache_locksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          update: {
            args: Prisma.cache_locksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          deleteMany: {
            args: Prisma.cache_locksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cache_locksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cache_locksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          aggregate: {
            args: Prisma.Cache_locksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCache_locks>
          }
          groupBy: {
            args: Prisma.cache_locksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cache_locksGroupByOutputType>[]
          }
          count: {
            args: Prisma.cache_locksCountArgs<ExtArgs>
            result: $Utils.Optional<Cache_locksCountAggregateOutputType> | number
          }
        }
      }
      clientes: {
        payload: Prisma.$clientesPayload<ExtArgs>
        fields: Prisma.clientesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          findFirst: {
            args: Prisma.clientesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          findMany: {
            args: Prisma.clientesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>[]
          }
          create: {
            args: Prisma.clientesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          createMany: {
            args: Prisma.clientesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clientesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          update: {
            args: Prisma.clientesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          deleteMany: {
            args: Prisma.clientesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clientesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientesPayload>
          }
          aggregate: {
            args: Prisma.ClientesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientes>
          }
          groupBy: {
            args: Prisma.clientesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientesGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientesCountArgs<ExtArgs>
            result: $Utils.Optional<ClientesCountAggregateOutputType> | number
          }
        }
      }
      compania: {
        payload: Prisma.$companiaPayload<ExtArgs>
        fields: Prisma.companiaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companiaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companiaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiaPayload>
          }
          findFirst: {
            args: Prisma.companiaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companiaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiaPayload>
          }
          findMany: {
            args: Prisma.companiaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiaPayload>[]
          }
          create: {
            args: Prisma.companiaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiaPayload>
          }
          createMany: {
            args: Prisma.companiaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.companiaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiaPayload>
          }
          update: {
            args: Prisma.companiaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiaPayload>
          }
          deleteMany: {
            args: Prisma.companiaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companiaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.companiaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiaPayload>
          }
          aggregate: {
            args: Prisma.CompaniaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompania>
          }
          groupBy: {
            args: Prisma.companiaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniaGroupByOutputType>[]
          }
          count: {
            args: Prisma.companiaCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniaCountAggregateOutputType> | number
          }
        }
      }
      compania_representantes: {
        payload: Prisma.$compania_representantesPayload<ExtArgs>
        fields: Prisma.compania_representantesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.compania_representantesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$compania_representantesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.compania_representantesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$compania_representantesPayload>
          }
          findFirst: {
            args: Prisma.compania_representantesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$compania_representantesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.compania_representantesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$compania_representantesPayload>
          }
          findMany: {
            args: Prisma.compania_representantesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$compania_representantesPayload>[]
          }
          create: {
            args: Prisma.compania_representantesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$compania_representantesPayload>
          }
          createMany: {
            args: Prisma.compania_representantesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.compania_representantesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$compania_representantesPayload>
          }
          update: {
            args: Prisma.compania_representantesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$compania_representantesPayload>
          }
          deleteMany: {
            args: Prisma.compania_representantesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.compania_representantesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.compania_representantesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$compania_representantesPayload>
          }
          aggregate: {
            args: Prisma.Compania_representantesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompania_representantes>
          }
          groupBy: {
            args: Prisma.compania_representantesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Compania_representantesGroupByOutputType>[]
          }
          count: {
            args: Prisma.compania_representantesCountArgs<ExtArgs>
            result: $Utils.Optional<Compania_representantesCountAggregateOutputType> | number
          }
        }
      }
      companias_productos: {
        payload: Prisma.$companias_productosPayload<ExtArgs>
        fields: Prisma.companias_productosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companias_productosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_productosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companias_productosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_productosPayload>
          }
          findFirst: {
            args: Prisma.companias_productosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_productosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companias_productosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_productosPayload>
          }
          findMany: {
            args: Prisma.companias_productosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_productosPayload>[]
          }
          create: {
            args: Prisma.companias_productosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_productosPayload>
          }
          createMany: {
            args: Prisma.companias_productosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.companias_productosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_productosPayload>
          }
          update: {
            args: Prisma.companias_productosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_productosPayload>
          }
          deleteMany: {
            args: Prisma.companias_productosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companias_productosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.companias_productosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_productosPayload>
          }
          aggregate: {
            args: Prisma.Companias_productosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanias_productos>
          }
          groupBy: {
            args: Prisma.companias_productosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Companias_productosGroupByOutputType>[]
          }
          count: {
            args: Prisma.companias_productosCountArgs<ExtArgs>
            result: $Utils.Optional<Companias_productosCountAggregateOutputType> | number
          }
        }
      }
      companias_ramos: {
        payload: Prisma.$companias_ramosPayload<ExtArgs>
        fields: Prisma.companias_ramosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companias_ramosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_ramosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companias_ramosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_ramosPayload>
          }
          findFirst: {
            args: Prisma.companias_ramosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_ramosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companias_ramosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_ramosPayload>
          }
          findMany: {
            args: Prisma.companias_ramosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_ramosPayload>[]
          }
          create: {
            args: Prisma.companias_ramosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_ramosPayload>
          }
          createMany: {
            args: Prisma.companias_ramosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.companias_ramosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_ramosPayload>
          }
          update: {
            args: Prisma.companias_ramosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_ramosPayload>
          }
          deleteMany: {
            args: Prisma.companias_ramosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companias_ramosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.companias_ramosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companias_ramosPayload>
          }
          aggregate: {
            args: Prisma.Companias_ramosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanias_ramos>
          }
          groupBy: {
            args: Prisma.companias_ramosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Companias_ramosGroupByOutputType>[]
          }
          count: {
            args: Prisma.companias_ramosCountArgs<ExtArgs>
            result: $Utils.Optional<Companias_ramosCountAggregateOutputType> | number
          }
        }
      }
      estados: {
        payload: Prisma.$estadosPayload<ExtArgs>
        fields: Prisma.estadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estadosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estadosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          findFirst: {
            args: Prisma.estadosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estadosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          findMany: {
            args: Prisma.estadosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>[]
          }
          create: {
            args: Prisma.estadosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          createMany: {
            args: Prisma.estadosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.estadosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          update: {
            args: Prisma.estadosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          deleteMany: {
            args: Prisma.estadosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estadosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.estadosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadosPayload>
          }
          aggregate: {
            args: Prisma.EstadosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstados>
          }
          groupBy: {
            args: Prisma.estadosGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstadosGroupByOutputType>[]
          }
          count: {
            args: Prisma.estadosCountArgs<ExtArgs>
            result: $Utils.Optional<EstadosCountAggregateOutputType> | number
          }
        }
      }
      estatus_cliente: {
        payload: Prisma.$estatus_clientePayload<ExtArgs>
        fields: Prisma.estatus_clienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estatus_clienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_clientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estatus_clienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_clientePayload>
          }
          findFirst: {
            args: Prisma.estatus_clienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_clientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estatus_clienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_clientePayload>
          }
          findMany: {
            args: Prisma.estatus_clienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_clientePayload>[]
          }
          create: {
            args: Prisma.estatus_clienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_clientePayload>
          }
          createMany: {
            args: Prisma.estatus_clienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.estatus_clienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_clientePayload>
          }
          update: {
            args: Prisma.estatus_clienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_clientePayload>
          }
          deleteMany: {
            args: Prisma.estatus_clienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estatus_clienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.estatus_clienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_clientePayload>
          }
          aggregate: {
            args: Prisma.Estatus_clienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstatus_cliente>
          }
          groupBy: {
            args: Prisma.estatus_clienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<Estatus_clienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.estatus_clienteCountArgs<ExtArgs>
            result: $Utils.Optional<Estatus_clienteCountAggregateOutputType> | number
          }
        }
      }
      estatus_polizas: {
        payload: Prisma.$estatus_polizasPayload<ExtArgs>
        fields: Prisma.estatus_polizasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estatus_polizasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_polizasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estatus_polizasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_polizasPayload>
          }
          findFirst: {
            args: Prisma.estatus_polizasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_polizasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estatus_polizasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_polizasPayload>
          }
          findMany: {
            args: Prisma.estatus_polizasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_polizasPayload>[]
          }
          create: {
            args: Prisma.estatus_polizasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_polizasPayload>
          }
          createMany: {
            args: Prisma.estatus_polizasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.estatus_polizasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_polizasPayload>
          }
          update: {
            args: Prisma.estatus_polizasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_polizasPayload>
          }
          deleteMany: {
            args: Prisma.estatus_polizasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estatus_polizasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.estatus_polizasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estatus_polizasPayload>
          }
          aggregate: {
            args: Prisma.Estatus_polizasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstatus_polizas>
          }
          groupBy: {
            args: Prisma.estatus_polizasGroupByArgs<ExtArgs>
            result: $Utils.Optional<Estatus_polizasGroupByOutputType>[]
          }
          count: {
            args: Prisma.estatus_polizasCountArgs<ExtArgs>
            result: $Utils.Optional<Estatus_polizasCountAggregateOutputType> | number
          }
        }
      }
      failed_jobs: {
        payload: Prisma.$failed_jobsPayload<ExtArgs>
        fields: Prisma.failed_jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.failed_jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.failed_jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          findFirst: {
            args: Prisma.failed_jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.failed_jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          findMany: {
            args: Prisma.failed_jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>[]
          }
          create: {
            args: Prisma.failed_jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          createMany: {
            args: Prisma.failed_jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.failed_jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          update: {
            args: Prisma.failed_jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          deleteMany: {
            args: Prisma.failed_jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.failed_jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.failed_jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          aggregate: {
            args: Prisma.Failed_jobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFailed_jobs>
          }
          groupBy: {
            args: Prisma.failed_jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Failed_jobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.failed_jobsCountArgs<ExtArgs>
            result: $Utils.Optional<Failed_jobsCountAggregateOutputType> | number
          }
        }
      }
      formas_de_pago: {
        payload: Prisma.$formas_de_pagoPayload<ExtArgs>
        fields: Prisma.formas_de_pagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formas_de_pagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formas_de_pagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formas_de_pagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formas_de_pagoPayload>
          }
          findFirst: {
            args: Prisma.formas_de_pagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formas_de_pagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formas_de_pagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formas_de_pagoPayload>
          }
          findMany: {
            args: Prisma.formas_de_pagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formas_de_pagoPayload>[]
          }
          create: {
            args: Prisma.formas_de_pagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formas_de_pagoPayload>
          }
          createMany: {
            args: Prisma.formas_de_pagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.formas_de_pagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formas_de_pagoPayload>
          }
          update: {
            args: Prisma.formas_de_pagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formas_de_pagoPayload>
          }
          deleteMany: {
            args: Prisma.formas_de_pagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formas_de_pagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.formas_de_pagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formas_de_pagoPayload>
          }
          aggregate: {
            args: Prisma.Formas_de_pagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormas_de_pago>
          }
          groupBy: {
            args: Prisma.formas_de_pagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Formas_de_pagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.formas_de_pagoCountArgs<ExtArgs>
            result: $Utils.Optional<Formas_de_pagoCountAggregateOutputType> | number
          }
        }
      }
      job_batches: {
        payload: Prisma.$job_batchesPayload<ExtArgs>
        fields: Prisma.job_batchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_batchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_batchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          findFirst: {
            args: Prisma.job_batchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_batchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          findMany: {
            args: Prisma.job_batchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>[]
          }
          create: {
            args: Prisma.job_batchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          createMany: {
            args: Prisma.job_batchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.job_batchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          update: {
            args: Prisma.job_batchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          deleteMany: {
            args: Prisma.job_batchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_batchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.job_batchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          aggregate: {
            args: Prisma.Job_batchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_batches>
          }
          groupBy: {
            args: Prisma.job_batchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_batchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_batchesCountArgs<ExtArgs>
            result: $Utils.Optional<Job_batchesCountAggregateOutputType> | number
          }
        }
      }
      jobs: {
        payload: Prisma.$jobsPayload<ExtArgs>
        fields: Prisma.jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          findFirst: {
            args: Prisma.jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          findMany: {
            args: Prisma.jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          create: {
            args: Prisma.jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          createMany: {
            args: Prisma.jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          update: {
            args: Prisma.jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          deleteMany: {
            args: Prisma.jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobsCountArgs<ExtArgs>
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      metodos_de_pago: {
        payload: Prisma.$metodos_de_pagoPayload<ExtArgs>
        fields: Prisma.metodos_de_pagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.metodos_de_pagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metodos_de_pagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.metodos_de_pagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metodos_de_pagoPayload>
          }
          findFirst: {
            args: Prisma.metodos_de_pagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metodos_de_pagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.metodos_de_pagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metodos_de_pagoPayload>
          }
          findMany: {
            args: Prisma.metodos_de_pagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metodos_de_pagoPayload>[]
          }
          create: {
            args: Prisma.metodos_de_pagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metodos_de_pagoPayload>
          }
          createMany: {
            args: Prisma.metodos_de_pagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.metodos_de_pagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metodos_de_pagoPayload>
          }
          update: {
            args: Prisma.metodos_de_pagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metodos_de_pagoPayload>
          }
          deleteMany: {
            args: Prisma.metodos_de_pagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.metodos_de_pagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.metodos_de_pagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metodos_de_pagoPayload>
          }
          aggregate: {
            args: Prisma.Metodos_de_pagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetodos_de_pago>
          }
          groupBy: {
            args: Prisma.metodos_de_pagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Metodos_de_pagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.metodos_de_pagoCountArgs<ExtArgs>
            result: $Utils.Optional<Metodos_de_pagoCountAggregateOutputType> | number
          }
        }
      }
      migrations: {
        payload: Prisma.$migrationsPayload<ExtArgs>
        fields: Prisma.migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findFirst: {
            args: Prisma.migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findMany: {
            args: Prisma.migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          create: {
            args: Prisma.migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          createMany: {
            args: Prisma.migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          update: {
            args: Prisma.migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          deleteMany: {
            args: Prisma.migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          aggregate: {
            args: Prisma.MigrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigrations>
          }
          groupBy: {
            args: Prisma.migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationsCountAggregateOutputType> | number
          }
        }
      }
      monedas: {
        payload: Prisma.$monedasPayload<ExtArgs>
        fields: Prisma.monedasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monedasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monedasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          findFirst: {
            args: Prisma.monedasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monedasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          findMany: {
            args: Prisma.monedasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>[]
          }
          create: {
            args: Prisma.monedasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          createMany: {
            args: Prisma.monedasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monedasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          update: {
            args: Prisma.monedasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          deleteMany: {
            args: Prisma.monedasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monedasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monedasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monedasPayload>
          }
          aggregate: {
            args: Prisma.MonedasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonedas>
          }
          groupBy: {
            args: Prisma.monedasGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonedasGroupByOutputType>[]
          }
          count: {
            args: Prisma.monedasCountArgs<ExtArgs>
            result: $Utils.Optional<MonedasCountAggregateOutputType> | number
          }
        }
      }
      password_reset_tokens: {
        payload: Prisma.$password_reset_tokensPayload<ExtArgs>
        fields: Prisma.password_reset_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.password_reset_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.password_reset_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          findFirst: {
            args: Prisma.password_reset_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.password_reset_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          findMany: {
            args: Prisma.password_reset_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          create: {
            args: Prisma.password_reset_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          createMany: {
            args: Prisma.password_reset_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.password_reset_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          update: {
            args: Prisma.password_reset_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          deleteMany: {
            args: Prisma.password_reset_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.password_reset_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.password_reset_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          aggregate: {
            args: Prisma.Password_reset_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword_reset_tokens>
          }
          groupBy: {
            args: Prisma.password_reset_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.password_reset_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokensCountAggregateOutputType> | number
          }
        }
      }
      personal_access_tokens: {
        payload: Prisma.$personal_access_tokensPayload<ExtArgs>
        fields: Prisma.personal_access_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.personal_access_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.personal_access_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          findFirst: {
            args: Prisma.personal_access_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.personal_access_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          findMany: {
            args: Prisma.personal_access_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>[]
          }
          create: {
            args: Prisma.personal_access_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          createMany: {
            args: Prisma.personal_access_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.personal_access_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          update: {
            args: Prisma.personal_access_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          deleteMany: {
            args: Prisma.personal_access_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.personal_access_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.personal_access_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personal_access_tokensPayload>
          }
          aggregate: {
            args: Prisma.Personal_access_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonal_access_tokens>
          }
          groupBy: {
            args: Prisma.personal_access_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Personal_access_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.personal_access_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Personal_access_tokensCountAggregateOutputType> | number
          }
        }
      }
      poliza_asegurados: {
        payload: Prisma.$poliza_aseguradosPayload<ExtArgs>
        fields: Prisma.poliza_aseguradosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.poliza_aseguradosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_aseguradosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.poliza_aseguradosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_aseguradosPayload>
          }
          findFirst: {
            args: Prisma.poliza_aseguradosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_aseguradosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.poliza_aseguradosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_aseguradosPayload>
          }
          findMany: {
            args: Prisma.poliza_aseguradosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_aseguradosPayload>[]
          }
          create: {
            args: Prisma.poliza_aseguradosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_aseguradosPayload>
          }
          createMany: {
            args: Prisma.poliza_aseguradosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.poliza_aseguradosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_aseguradosPayload>
          }
          update: {
            args: Prisma.poliza_aseguradosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_aseguradosPayload>
          }
          deleteMany: {
            args: Prisma.poliza_aseguradosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.poliza_aseguradosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.poliza_aseguradosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_aseguradosPayload>
          }
          aggregate: {
            args: Prisma.Poliza_aseguradosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoliza_asegurados>
          }
          groupBy: {
            args: Prisma.poliza_aseguradosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Poliza_aseguradosGroupByOutputType>[]
          }
          count: {
            args: Prisma.poliza_aseguradosCountArgs<ExtArgs>
            result: $Utils.Optional<Poliza_aseguradosCountAggregateOutputType> | number
          }
        }
      }
      poliza_historial: {
        payload: Prisma.$poliza_historialPayload<ExtArgs>
        fields: Prisma.poliza_historialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.poliza_historialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_historialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.poliza_historialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_historialPayload>
          }
          findFirst: {
            args: Prisma.poliza_historialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_historialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.poliza_historialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_historialPayload>
          }
          findMany: {
            args: Prisma.poliza_historialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_historialPayload>[]
          }
          create: {
            args: Prisma.poliza_historialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_historialPayload>
          }
          createMany: {
            args: Prisma.poliza_historialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.poliza_historialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_historialPayload>
          }
          update: {
            args: Prisma.poliza_historialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_historialPayload>
          }
          deleteMany: {
            args: Prisma.poliza_historialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.poliza_historialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.poliza_historialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_historialPayload>
          }
          aggregate: {
            args: Prisma.Poliza_historialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoliza_historial>
          }
          groupBy: {
            args: Prisma.poliza_historialGroupByArgs<ExtArgs>
            result: $Utils.Optional<Poliza_historialGroupByOutputType>[]
          }
          count: {
            args: Prisma.poliza_historialCountArgs<ExtArgs>
            result: $Utils.Optional<Poliza_historialCountAggregateOutputType> | number
          }
        }
      }
      poliza_recibos: {
        payload: Prisma.$poliza_recibosPayload<ExtArgs>
        fields: Prisma.poliza_recibosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.poliza_recibosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_recibosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.poliza_recibosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_recibosPayload>
          }
          findFirst: {
            args: Prisma.poliza_recibosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_recibosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.poliza_recibosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_recibosPayload>
          }
          findMany: {
            args: Prisma.poliza_recibosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_recibosPayload>[]
          }
          create: {
            args: Prisma.poliza_recibosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_recibosPayload>
          }
          createMany: {
            args: Prisma.poliza_recibosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.poliza_recibosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_recibosPayload>
          }
          update: {
            args: Prisma.poliza_recibosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_recibosPayload>
          }
          deleteMany: {
            args: Prisma.poliza_recibosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.poliza_recibosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.poliza_recibosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poliza_recibosPayload>
          }
          aggregate: {
            args: Prisma.Poliza_recibosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoliza_recibos>
          }
          groupBy: {
            args: Prisma.poliza_recibosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Poliza_recibosGroupByOutputType>[]
          }
          count: {
            args: Prisma.poliza_recibosCountArgs<ExtArgs>
            result: $Utils.Optional<Poliza_recibosCountAggregateOutputType> | number
          }
        }
      }
      polizas: {
        payload: Prisma.$polizasPayload<ExtArgs>
        fields: Prisma.polizasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.polizasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$polizasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.polizasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$polizasPayload>
          }
          findFirst: {
            args: Prisma.polizasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$polizasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.polizasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$polizasPayload>
          }
          findMany: {
            args: Prisma.polizasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$polizasPayload>[]
          }
          create: {
            args: Prisma.polizasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$polizasPayload>
          }
          createMany: {
            args: Prisma.polizasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.polizasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$polizasPayload>
          }
          update: {
            args: Prisma.polizasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$polizasPayload>
          }
          deleteMany: {
            args: Prisma.polizasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.polizasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.polizasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$polizasPayload>
          }
          aggregate: {
            args: Prisma.PolizasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolizas>
          }
          groupBy: {
            args: Prisma.polizasGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolizasGroupByOutputType>[]
          }
          count: {
            args: Prisma.polizasCountArgs<ExtArgs>
            result: $Utils.Optional<PolizasCountAggregateOutputType> | number
          }
        }
      }
      ramos: {
        payload: Prisma.$ramosPayload<ExtArgs>
        fields: Prisma.ramosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ramosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ramosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ramosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ramosPayload>
          }
          findFirst: {
            args: Prisma.ramosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ramosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ramosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ramosPayload>
          }
          findMany: {
            args: Prisma.ramosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ramosPayload>[]
          }
          create: {
            args: Prisma.ramosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ramosPayload>
          }
          createMany: {
            args: Prisma.ramosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ramosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ramosPayload>
          }
          update: {
            args: Prisma.ramosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ramosPayload>
          }
          deleteMany: {
            args: Prisma.ramosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ramosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ramosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ramosPayload>
          }
          aggregate: {
            args: Prisma.RamosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRamos>
          }
          groupBy: {
            args: Prisma.ramosGroupByArgs<ExtArgs>
            result: $Utils.Optional<RamosGroupByOutputType>[]
          }
          count: {
            args: Prisma.ramosCountArgs<ExtArgs>
            result: $Utils.Optional<RamosCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      tipos_de_usuarios: {
        payload: Prisma.$tipos_de_usuariosPayload<ExtArgs>
        fields: Prisma.tipos_de_usuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipos_de_usuariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_usuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipos_de_usuariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_usuariosPayload>
          }
          findFirst: {
            args: Prisma.tipos_de_usuariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_usuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipos_de_usuariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_usuariosPayload>
          }
          findMany: {
            args: Prisma.tipos_de_usuariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_usuariosPayload>[]
          }
          create: {
            args: Prisma.tipos_de_usuariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_usuariosPayload>
          }
          createMany: {
            args: Prisma.tipos_de_usuariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tipos_de_usuariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_usuariosPayload>
          }
          update: {
            args: Prisma.tipos_de_usuariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_usuariosPayload>
          }
          deleteMany: {
            args: Prisma.tipos_de_usuariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipos_de_usuariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tipos_de_usuariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_usuariosPayload>
          }
          aggregate: {
            args: Prisma.Tipos_de_usuariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipos_de_usuarios>
          }
          groupBy: {
            args: Prisma.tipos_de_usuariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipos_de_usuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipos_de_usuariosCountArgs<ExtArgs>
            result: $Utils.Optional<Tipos_de_usuariosCountAggregateOutputType> | number
          }
        }
      }
      tipos_de_vencimiento: {
        payload: Prisma.$tipos_de_vencimientoPayload<ExtArgs>
        fields: Prisma.tipos_de_vencimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipos_de_vencimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_vencimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipos_de_vencimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_vencimientoPayload>
          }
          findFirst: {
            args: Prisma.tipos_de_vencimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_vencimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipos_de_vencimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_vencimientoPayload>
          }
          findMany: {
            args: Prisma.tipos_de_vencimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_vencimientoPayload>[]
          }
          create: {
            args: Prisma.tipos_de_vencimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_vencimientoPayload>
          }
          createMany: {
            args: Prisma.tipos_de_vencimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tipos_de_vencimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_vencimientoPayload>
          }
          update: {
            args: Prisma.tipos_de_vencimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_vencimientoPayload>
          }
          deleteMany: {
            args: Prisma.tipos_de_vencimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipos_de_vencimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tipos_de_vencimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipos_de_vencimientoPayload>
          }
          aggregate: {
            args: Prisma.Tipos_de_vencimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipos_de_vencimiento>
          }
          groupBy: {
            args: Prisma.tipos_de_vencimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipos_de_vencimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipos_de_vencimientoCountArgs<ExtArgs>
            result: $Utils.Optional<Tipos_de_vencimientoCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      usuario_claves: {
        payload: Prisma.$usuario_clavesPayload<ExtArgs>
        fields: Prisma.usuario_clavesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuario_clavesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_clavesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuario_clavesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_clavesPayload>
          }
          findFirst: {
            args: Prisma.usuario_clavesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_clavesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuario_clavesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_clavesPayload>
          }
          findMany: {
            args: Prisma.usuario_clavesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_clavesPayload>[]
          }
          create: {
            args: Prisma.usuario_clavesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_clavesPayload>
          }
          createMany: {
            args: Prisma.usuario_clavesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usuario_clavesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_clavesPayload>
          }
          update: {
            args: Prisma.usuario_clavesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_clavesPayload>
          }
          deleteMany: {
            args: Prisma.usuario_clavesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuario_clavesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usuario_clavesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_clavesPayload>
          }
          aggregate: {
            args: Prisma.Usuario_clavesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario_claves>
          }
          groupBy: {
            args: Prisma.usuario_clavesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Usuario_clavesGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuario_clavesCountArgs<ExtArgs>
            result: $Utils.Optional<Usuario_clavesCountAggregateOutputType> | number
          }
        }
      }
      usuario_team: {
        payload: Prisma.$usuario_teamPayload<ExtArgs>
        fields: Prisma.usuario_teamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuario_teamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_teamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuario_teamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_teamPayload>
          }
          findFirst: {
            args: Prisma.usuario_teamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_teamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuario_teamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_teamPayload>
          }
          findMany: {
            args: Prisma.usuario_teamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_teamPayload>[]
          }
          create: {
            args: Prisma.usuario_teamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_teamPayload>
          }
          createMany: {
            args: Prisma.usuario_teamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usuario_teamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_teamPayload>
          }
          update: {
            args: Prisma.usuario_teamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_teamPayload>
          }
          deleteMany: {
            args: Prisma.usuario_teamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuario_teamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usuario_teamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_teamPayload>
          }
          aggregate: {
            args: Prisma.Usuario_teamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario_team>
          }
          groupBy: {
            args: Prisma.usuario_teamGroupByArgs<ExtArgs>
            result: $Utils.Optional<Usuario_teamGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuario_teamCountArgs<ExtArgs>
            result: $Utils.Optional<Usuario_teamCountAggregateOutputType> | number
          }
        }
      }
      usuarios: {
        payload: Prisma.$usuariosPayload<ExtArgs>
        fields: Prisma.usuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          findFirst: {
            args: Prisma.usuariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          findMany: {
            args: Prisma.usuariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>[]
          }
          create: {
            args: Prisma.usuariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          createMany: {
            args: Prisma.usuariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usuariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          update: {
            args: Prisma.usuariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          deleteMany: {
            args: Prisma.usuariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usuariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarios>
          }
          groupBy: {
            args: Prisma.usuariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuariosCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    actividades?: actividadesOmit
    cache?: cacheOmit
    cache_locks?: cache_locksOmit
    clientes?: clientesOmit
    compania?: companiaOmit
    compania_representantes?: compania_representantesOmit
    companias_productos?: companias_productosOmit
    companias_ramos?: companias_ramosOmit
    estados?: estadosOmit
    estatus_cliente?: estatus_clienteOmit
    estatus_polizas?: estatus_polizasOmit
    failed_jobs?: failed_jobsOmit
    formas_de_pago?: formas_de_pagoOmit
    job_batches?: job_batchesOmit
    jobs?: jobsOmit
    metodos_de_pago?: metodos_de_pagoOmit
    migrations?: migrationsOmit
    monedas?: monedasOmit
    password_reset_tokens?: password_reset_tokensOmit
    personal_access_tokens?: personal_access_tokensOmit
    poliza_asegurados?: poliza_aseguradosOmit
    poliza_historial?: poliza_historialOmit
    poliza_recibos?: poliza_recibosOmit
    polizas?: polizasOmit
    ramos?: ramosOmit
    sessions?: sessionsOmit
    tipos_de_usuarios?: tipos_de_usuariosOmit
    tipos_de_vencimiento?: tipos_de_vencimientoOmit
    users?: usersOmit
    usuario_claves?: usuario_clavesOmit
    usuario_team?: usuario_teamOmit
    usuarios?: usuariosOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClientesCountOutputType
   */

  export type ClientesCountOutputType = {
    polizas: number
  }

  export type ClientesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | ClientesCountOutputTypeCountPolizasArgs
  }

  // Custom InputTypes
  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientesCountOutputType
     */
    select?: ClientesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeCountPolizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: polizasWhereInput
  }


  /**
   * Count Type CompaniaCountOutputType
   */

  export type CompaniaCountOutputType = {
    compania_representantes: number
    companias_productos: number
    companias_ramos: number
    polizas: number
    usuario_claves: number
  }

  export type CompaniaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compania_representantes?: boolean | CompaniaCountOutputTypeCountCompania_representantesArgs
    companias_productos?: boolean | CompaniaCountOutputTypeCountCompanias_productosArgs
    companias_ramos?: boolean | CompaniaCountOutputTypeCountCompanias_ramosArgs
    polizas?: boolean | CompaniaCountOutputTypeCountPolizasArgs
    usuario_claves?: boolean | CompaniaCountOutputTypeCountUsuario_clavesArgs
  }

  // Custom InputTypes
  /**
   * CompaniaCountOutputType without action
   */
  export type CompaniaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniaCountOutputType
     */
    select?: CompaniaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniaCountOutputType without action
   */
  export type CompaniaCountOutputTypeCountCompania_representantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: compania_representantesWhereInput
  }

  /**
   * CompaniaCountOutputType without action
   */
  export type CompaniaCountOutputTypeCountCompanias_productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companias_productosWhereInput
  }

  /**
   * CompaniaCountOutputType without action
   */
  export type CompaniaCountOutputTypeCountCompanias_ramosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companias_ramosWhereInput
  }

  /**
   * CompaniaCountOutputType without action
   */
  export type CompaniaCountOutputTypeCountPolizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: polizasWhereInput
  }

  /**
   * CompaniaCountOutputType without action
   */
  export type CompaniaCountOutputTypeCountUsuario_clavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuario_clavesWhereInput
  }


  /**
   * Count Type Companias_productosCountOutputType
   */

  export type Companias_productosCountOutputType = {
    polizas: number
  }

  export type Companias_productosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | Companias_productosCountOutputTypeCountPolizasArgs
  }

  // Custom InputTypes
  /**
   * Companias_productosCountOutputType without action
   */
  export type Companias_productosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Companias_productosCountOutputType
     */
    select?: Companias_productosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Companias_productosCountOutputType without action
   */
  export type Companias_productosCountOutputTypeCountPolizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: polizasWhereInput
  }


  /**
   * Count Type Formas_de_pagoCountOutputType
   */

  export type Formas_de_pagoCountOutputType = {
    polizas: number
  }

  export type Formas_de_pagoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | Formas_de_pagoCountOutputTypeCountPolizasArgs
  }

  // Custom InputTypes
  /**
   * Formas_de_pagoCountOutputType without action
   */
  export type Formas_de_pagoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formas_de_pagoCountOutputType
     */
    select?: Formas_de_pagoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Formas_de_pagoCountOutputType without action
   */
  export type Formas_de_pagoCountOutputTypeCountPolizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: polizasWhereInput
  }


  /**
   * Count Type Metodos_de_pagoCountOutputType
   */

  export type Metodos_de_pagoCountOutputType = {
    polizas: number
  }

  export type Metodos_de_pagoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | Metodos_de_pagoCountOutputTypeCountPolizasArgs
  }

  // Custom InputTypes
  /**
   * Metodos_de_pagoCountOutputType without action
   */
  export type Metodos_de_pagoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodos_de_pagoCountOutputType
     */
    select?: Metodos_de_pagoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Metodos_de_pagoCountOutputType without action
   */
  export type Metodos_de_pagoCountOutputTypeCountPolizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: polizasWhereInput
  }


  /**
   * Count Type MonedasCountOutputType
   */

  export type MonedasCountOutputType = {
    polizas: number
  }

  export type MonedasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | MonedasCountOutputTypeCountPolizasArgs
  }

  // Custom InputTypes
  /**
   * MonedasCountOutputType without action
   */
  export type MonedasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonedasCountOutputType
     */
    select?: MonedasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MonedasCountOutputType without action
   */
  export type MonedasCountOutputTypeCountPolizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: polizasWhereInput
  }


  /**
   * Count Type PolizasCountOutputType
   */

  export type PolizasCountOutputType = {
    poliza_recibos: number
  }

  export type PolizasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poliza_recibos?: boolean | PolizasCountOutputTypeCountPoliza_recibosArgs
  }

  // Custom InputTypes
  /**
   * PolizasCountOutputType without action
   */
  export type PolizasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolizasCountOutputType
     */
    select?: PolizasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PolizasCountOutputType without action
   */
  export type PolizasCountOutputTypeCountPoliza_recibosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poliza_recibosWhereInput
  }


  /**
   * Count Type RamosCountOutputType
   */

  export type RamosCountOutputType = {
    companias_productos: number
    companias_ramos: number
    polizas: number
  }

  export type RamosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companias_productos?: boolean | RamosCountOutputTypeCountCompanias_productosArgs
    companias_ramos?: boolean | RamosCountOutputTypeCountCompanias_ramosArgs
    polizas?: boolean | RamosCountOutputTypeCountPolizasArgs
  }

  // Custom InputTypes
  /**
   * RamosCountOutputType without action
   */
  export type RamosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RamosCountOutputType
     */
    select?: RamosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RamosCountOutputType without action
   */
  export type RamosCountOutputTypeCountCompanias_productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companias_productosWhereInput
  }

  /**
   * RamosCountOutputType without action
   */
  export type RamosCountOutputTypeCountCompanias_ramosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companias_ramosWhereInput
  }

  /**
   * RamosCountOutputType without action
   */
  export type RamosCountOutputTypeCountPolizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: polizasWhereInput
  }


  /**
   * Count Type Tipos_de_usuariosCountOutputType
   */

  export type Tipos_de_usuariosCountOutputType = {
    usuario_team: number
  }

  export type Tipos_de_usuariosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario_team?: boolean | Tipos_de_usuariosCountOutputTypeCountUsuario_teamArgs
  }

  // Custom InputTypes
  /**
   * Tipos_de_usuariosCountOutputType without action
   */
  export type Tipos_de_usuariosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipos_de_usuariosCountOutputType
     */
    select?: Tipos_de_usuariosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tipos_de_usuariosCountOutputType without action
   */
  export type Tipos_de_usuariosCountOutputTypeCountUsuario_teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuario_teamWhereInput
  }


  /**
   * Count Type Tipos_de_vencimientoCountOutputType
   */

  export type Tipos_de_vencimientoCountOutputType = {
    polizas: number
  }

  export type Tipos_de_vencimientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | Tipos_de_vencimientoCountOutputTypeCountPolizasArgs
  }

  // Custom InputTypes
  /**
   * Tipos_de_vencimientoCountOutputType without action
   */
  export type Tipos_de_vencimientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipos_de_vencimientoCountOutputType
     */
    select?: Tipos_de_vencimientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tipos_de_vencimientoCountOutputType without action
   */
  export type Tipos_de_vencimientoCountOutputTypeCountPolizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: polizasWhereInput
  }


  /**
   * Count Type UsuariosCountOutputType
   */

  export type UsuariosCountOutputType = {
    polizas: number
    usuario_team: number
  }

  export type UsuariosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | UsuariosCountOutputTypeCountPolizasArgs
    usuario_team?: boolean | UsuariosCountOutputTypeCountUsuario_teamArgs
  }

  // Custom InputTypes
  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosCountOutputType
     */
    select?: UsuariosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountPolizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: polizasWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountUsuario_teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuario_teamWhereInput
  }


  /**
   * Models
   */

  /**
   * Model actividades
   */

  export type AggregateActividades = {
    _count: ActividadesCountAggregateOutputType | null
    _avg: ActividadesAvgAggregateOutputType | null
    _sum: ActividadesSumAggregateOutputType | null
    _min: ActividadesMinAggregateOutputType | null
    _max: ActividadesMaxAggregateOutputType | null
  }

  export type ActividadesAvgAggregateOutputType = {
    id: number | null
  }

  export type ActividadesSumAggregateOutputType = {
    id: bigint | null
  }

  export type ActividadesMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ActividadesMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ActividadesCountAggregateOutputType = {
    id: number
    label: number
    estatus: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ActividadesAvgAggregateInputType = {
    id?: true
  }

  export type ActividadesSumAggregateInputType = {
    id?: true
  }

  export type ActividadesMinAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ActividadesMaxAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ActividadesCountAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ActividadesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which actividades to aggregate.
     */
    where?: actividadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades to fetch.
     */
    orderBy?: actividadesOrderByWithRelationInput | actividadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: actividadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned actividades
    **/
    _count?: true | ActividadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActividadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActividadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActividadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActividadesMaxAggregateInputType
  }

  export type GetActividadesAggregateType<T extends ActividadesAggregateArgs> = {
        [P in keyof T & keyof AggregateActividades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActividades[P]>
      : GetScalarType<T[P], AggregateActividades[P]>
  }




  export type actividadesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: actividadesWhereInput
    orderBy?: actividadesOrderByWithAggregationInput | actividadesOrderByWithAggregationInput[]
    by: ActividadesScalarFieldEnum[] | ActividadesScalarFieldEnum
    having?: actividadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActividadesCountAggregateInputType | true
    _avg?: ActividadesAvgAggregateInputType
    _sum?: ActividadesSumAggregateInputType
    _min?: ActividadesMinAggregateInputType
    _max?: ActividadesMaxAggregateInputType
  }

  export type ActividadesGroupByOutputType = {
    id: bigint
    label: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: ActividadesCountAggregateOutputType | null
    _avg: ActividadesAvgAggregateOutputType | null
    _sum: ActividadesSumAggregateOutputType | null
    _min: ActividadesMinAggregateOutputType | null
    _max: ActividadesMaxAggregateOutputType | null
  }

  type GetActividadesGroupByPayload<T extends actividadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActividadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActividadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActividadesGroupByOutputType[P]>
            : GetScalarType<T[P], ActividadesGroupByOutputType[P]>
        }
      >
    >


  export type actividadesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["actividades"]>



  export type actividadesSelectScalar = {
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type actividadesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "estatus" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["actividades"]>

  export type $actividadesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "actividades"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["actividades"]>
    composites: {}
  }

  type actividadesGetPayload<S extends boolean | null | undefined | actividadesDefaultArgs> = $Result.GetResult<Prisma.$actividadesPayload, S>

  type actividadesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<actividadesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActividadesCountAggregateInputType | true
    }

  export interface actividadesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['actividades'], meta: { name: 'actividades' } }
    /**
     * Find zero or one Actividades that matches the filter.
     * @param {actividadesFindUniqueArgs} args - Arguments to find a Actividades
     * @example
     * // Get one Actividades
     * const actividades = await prisma.actividades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends actividadesFindUniqueArgs>(args: SelectSubset<T, actividadesFindUniqueArgs<ExtArgs>>): Prisma__actividadesClient<$Result.GetResult<Prisma.$actividadesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Actividades that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {actividadesFindUniqueOrThrowArgs} args - Arguments to find a Actividades
     * @example
     * // Get one Actividades
     * const actividades = await prisma.actividades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends actividadesFindUniqueOrThrowArgs>(args: SelectSubset<T, actividadesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__actividadesClient<$Result.GetResult<Prisma.$actividadesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Actividades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividadesFindFirstArgs} args - Arguments to find a Actividades
     * @example
     * // Get one Actividades
     * const actividades = await prisma.actividades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends actividadesFindFirstArgs>(args?: SelectSubset<T, actividadesFindFirstArgs<ExtArgs>>): Prisma__actividadesClient<$Result.GetResult<Prisma.$actividadesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Actividades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividadesFindFirstOrThrowArgs} args - Arguments to find a Actividades
     * @example
     * // Get one Actividades
     * const actividades = await prisma.actividades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends actividadesFindFirstOrThrowArgs>(args?: SelectSubset<T, actividadesFindFirstOrThrowArgs<ExtArgs>>): Prisma__actividadesClient<$Result.GetResult<Prisma.$actividadesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Actividades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividadesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actividades
     * const actividades = await prisma.actividades.findMany()
     * 
     * // Get first 10 Actividades
     * const actividades = await prisma.actividades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actividadesWithIdOnly = await prisma.actividades.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends actividadesFindManyArgs>(args?: SelectSubset<T, actividadesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$actividadesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Actividades.
     * @param {actividadesCreateArgs} args - Arguments to create a Actividades.
     * @example
     * // Create one Actividades
     * const Actividades = await prisma.actividades.create({
     *   data: {
     *     // ... data to create a Actividades
     *   }
     * })
     * 
     */
    create<T extends actividadesCreateArgs>(args: SelectSubset<T, actividadesCreateArgs<ExtArgs>>): Prisma__actividadesClient<$Result.GetResult<Prisma.$actividadesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Actividades.
     * @param {actividadesCreateManyArgs} args - Arguments to create many Actividades.
     * @example
     * // Create many Actividades
     * const actividades = await prisma.actividades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends actividadesCreateManyArgs>(args?: SelectSubset<T, actividadesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Actividades.
     * @param {actividadesDeleteArgs} args - Arguments to delete one Actividades.
     * @example
     * // Delete one Actividades
     * const Actividades = await prisma.actividades.delete({
     *   where: {
     *     // ... filter to delete one Actividades
     *   }
     * })
     * 
     */
    delete<T extends actividadesDeleteArgs>(args: SelectSubset<T, actividadesDeleteArgs<ExtArgs>>): Prisma__actividadesClient<$Result.GetResult<Prisma.$actividadesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Actividades.
     * @param {actividadesUpdateArgs} args - Arguments to update one Actividades.
     * @example
     * // Update one Actividades
     * const actividades = await prisma.actividades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends actividadesUpdateArgs>(args: SelectSubset<T, actividadesUpdateArgs<ExtArgs>>): Prisma__actividadesClient<$Result.GetResult<Prisma.$actividadesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Actividades.
     * @param {actividadesDeleteManyArgs} args - Arguments to filter Actividades to delete.
     * @example
     * // Delete a few Actividades
     * const { count } = await prisma.actividades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends actividadesDeleteManyArgs>(args?: SelectSubset<T, actividadesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actividades
     * const actividades = await prisma.actividades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends actividadesUpdateManyArgs>(args: SelectSubset<T, actividadesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Actividades.
     * @param {actividadesUpsertArgs} args - Arguments to update or create a Actividades.
     * @example
     * // Update or create a Actividades
     * const actividades = await prisma.actividades.upsert({
     *   create: {
     *     // ... data to create a Actividades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actividades we want to update
     *   }
     * })
     */
    upsert<T extends actividadesUpsertArgs>(args: SelectSubset<T, actividadesUpsertArgs<ExtArgs>>): Prisma__actividadesClient<$Result.GetResult<Prisma.$actividadesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Actividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividadesCountArgs} args - Arguments to filter Actividades to count.
     * @example
     * // Count the number of Actividades
     * const count = await prisma.actividades.count({
     *   where: {
     *     // ... the filter for the Actividades we want to count
     *   }
     * })
    **/
    count<T extends actividadesCountArgs>(
      args?: Subset<T, actividadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActividadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActividadesAggregateArgs>(args: Subset<T, ActividadesAggregateArgs>): Prisma.PrismaPromise<GetActividadesAggregateType<T>>

    /**
     * Group by Actividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends actividadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: actividadesGroupByArgs['orderBy'] }
        : { orderBy?: actividadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, actividadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActividadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the actividades model
   */
  readonly fields: actividadesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for actividades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__actividadesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the actividades model
   */
  interface actividadesFieldRefs {
    readonly id: FieldRef<"actividades", 'BigInt'>
    readonly label: FieldRef<"actividades", 'String'>
    readonly estatus: FieldRef<"actividades", 'Boolean'>
    readonly created_at: FieldRef<"actividades", 'DateTime'>
    readonly updated_at: FieldRef<"actividades", 'DateTime'>
    readonly deleted_at: FieldRef<"actividades", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * actividades findUnique
   */
  export type actividadesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades
     */
    select?: actividadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the actividades
     */
    omit?: actividadesOmit<ExtArgs> | null
    /**
     * Filter, which actividades to fetch.
     */
    where: actividadesWhereUniqueInput
  }

  /**
   * actividades findUniqueOrThrow
   */
  export type actividadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades
     */
    select?: actividadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the actividades
     */
    omit?: actividadesOmit<ExtArgs> | null
    /**
     * Filter, which actividades to fetch.
     */
    where: actividadesWhereUniqueInput
  }

  /**
   * actividades findFirst
   */
  export type actividadesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades
     */
    select?: actividadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the actividades
     */
    omit?: actividadesOmit<ExtArgs> | null
    /**
     * Filter, which actividades to fetch.
     */
    where?: actividadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades to fetch.
     */
    orderBy?: actividadesOrderByWithRelationInput | actividadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for actividades.
     */
    cursor?: actividadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of actividades.
     */
    distinct?: ActividadesScalarFieldEnum | ActividadesScalarFieldEnum[]
  }

  /**
   * actividades findFirstOrThrow
   */
  export type actividadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades
     */
    select?: actividadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the actividades
     */
    omit?: actividadesOmit<ExtArgs> | null
    /**
     * Filter, which actividades to fetch.
     */
    where?: actividadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades to fetch.
     */
    orderBy?: actividadesOrderByWithRelationInput | actividadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for actividades.
     */
    cursor?: actividadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of actividades.
     */
    distinct?: ActividadesScalarFieldEnum | ActividadesScalarFieldEnum[]
  }

  /**
   * actividades findMany
   */
  export type actividadesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades
     */
    select?: actividadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the actividades
     */
    omit?: actividadesOmit<ExtArgs> | null
    /**
     * Filter, which actividades to fetch.
     */
    where?: actividadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades to fetch.
     */
    orderBy?: actividadesOrderByWithRelationInput | actividadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing actividades.
     */
    cursor?: actividadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades.
     */
    skip?: number
    distinct?: ActividadesScalarFieldEnum | ActividadesScalarFieldEnum[]
  }

  /**
   * actividades create
   */
  export type actividadesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades
     */
    select?: actividadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the actividades
     */
    omit?: actividadesOmit<ExtArgs> | null
    /**
     * The data needed to create a actividades.
     */
    data: XOR<actividadesCreateInput, actividadesUncheckedCreateInput>
  }

  /**
   * actividades createMany
   */
  export type actividadesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many actividades.
     */
    data: actividadesCreateManyInput | actividadesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * actividades update
   */
  export type actividadesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades
     */
    select?: actividadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the actividades
     */
    omit?: actividadesOmit<ExtArgs> | null
    /**
     * The data needed to update a actividades.
     */
    data: XOR<actividadesUpdateInput, actividadesUncheckedUpdateInput>
    /**
     * Choose, which actividades to update.
     */
    where: actividadesWhereUniqueInput
  }

  /**
   * actividades updateMany
   */
  export type actividadesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update actividades.
     */
    data: XOR<actividadesUpdateManyMutationInput, actividadesUncheckedUpdateManyInput>
    /**
     * Filter which actividades to update
     */
    where?: actividadesWhereInput
    /**
     * Limit how many actividades to update.
     */
    limit?: number
  }

  /**
   * actividades upsert
   */
  export type actividadesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades
     */
    select?: actividadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the actividades
     */
    omit?: actividadesOmit<ExtArgs> | null
    /**
     * The filter to search for the actividades to update in case it exists.
     */
    where: actividadesWhereUniqueInput
    /**
     * In case the actividades found by the `where` argument doesn't exist, create a new actividades with this data.
     */
    create: XOR<actividadesCreateInput, actividadesUncheckedCreateInput>
    /**
     * In case the actividades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<actividadesUpdateInput, actividadesUncheckedUpdateInput>
  }

  /**
   * actividades delete
   */
  export type actividadesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades
     */
    select?: actividadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the actividades
     */
    omit?: actividadesOmit<ExtArgs> | null
    /**
     * Filter which actividades to delete.
     */
    where: actividadesWhereUniqueInput
  }

  /**
   * actividades deleteMany
   */
  export type actividadesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which actividades to delete
     */
    where?: actividadesWhereInput
    /**
     * Limit how many actividades to delete.
     */
    limit?: number
  }

  /**
   * actividades without action
   */
  export type actividadesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades
     */
    select?: actividadesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the actividades
     */
    omit?: actividadesOmit<ExtArgs> | null
  }


  /**
   * Model cache
   */

  export type AggregateCache = {
    _count: CacheCountAggregateOutputType | null
    _avg: CacheAvgAggregateOutputType | null
    _sum: CacheSumAggregateOutputType | null
    _min: CacheMinAggregateOutputType | null
    _max: CacheMaxAggregateOutputType | null
  }

  export type CacheAvgAggregateOutputType = {
    expiration: number | null
  }

  export type CacheSumAggregateOutputType = {
    expiration: number | null
  }

  export type CacheMinAggregateOutputType = {
    key: string | null
    value: string | null
    expiration: number | null
  }

  export type CacheMaxAggregateOutputType = {
    key: string | null
    value: string | null
    expiration: number | null
  }

  export type CacheCountAggregateOutputType = {
    key: number
    value: number
    expiration: number
    _all: number
  }


  export type CacheAvgAggregateInputType = {
    expiration?: true
  }

  export type CacheSumAggregateInputType = {
    expiration?: true
  }

  export type CacheMinAggregateInputType = {
    key?: true
    value?: true
    expiration?: true
  }

  export type CacheMaxAggregateInputType = {
    key?: true
    value?: true
    expiration?: true
  }

  export type CacheCountAggregateInputType = {
    key?: true
    value?: true
    expiration?: true
    _all?: true
  }

  export type CacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache to aggregate.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caches
    **/
    _count?: true | CacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CacheMaxAggregateInputType
  }

  export type GetCacheAggregateType<T extends CacheAggregateArgs> = {
        [P in keyof T & keyof AggregateCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCache[P]>
      : GetScalarType<T[P], AggregateCache[P]>
  }




  export type cacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cacheWhereInput
    orderBy?: cacheOrderByWithAggregationInput | cacheOrderByWithAggregationInput[]
    by: CacheScalarFieldEnum[] | CacheScalarFieldEnum
    having?: cacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CacheCountAggregateInputType | true
    _avg?: CacheAvgAggregateInputType
    _sum?: CacheSumAggregateInputType
    _min?: CacheMinAggregateInputType
    _max?: CacheMaxAggregateInputType
  }

  export type CacheGroupByOutputType = {
    key: string
    value: string
    expiration: number
    _count: CacheCountAggregateOutputType | null
    _avg: CacheAvgAggregateOutputType | null
    _sum: CacheSumAggregateOutputType | null
    _min: CacheMinAggregateOutputType | null
    _max: CacheMaxAggregateOutputType | null
  }

  type GetCacheGroupByPayload<T extends cacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CacheGroupByOutputType[P]>
            : GetScalarType<T[P], CacheGroupByOutputType[P]>
        }
      >
    >


  export type cacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    expiration?: boolean
  }, ExtArgs["result"]["cache"]>



  export type cacheSelectScalar = {
    key?: boolean
    value?: boolean
    expiration?: boolean
  }

  export type cacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "expiration", ExtArgs["result"]["cache"]>

  export type $cachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
      expiration: number
    }, ExtArgs["result"]["cache"]>
    composites: {}
  }

  type cacheGetPayload<S extends boolean | null | undefined | cacheDefaultArgs> = $Result.GetResult<Prisma.$cachePayload, S>

  type cacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CacheCountAggregateInputType | true
    }

  export interface cacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cache'], meta: { name: 'cache' } }
    /**
     * Find zero or one Cache that matches the filter.
     * @param {cacheFindUniqueArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cacheFindUniqueArgs>(args: SelectSubset<T, cacheFindUniqueArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cacheFindUniqueOrThrowArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cacheFindUniqueOrThrowArgs>(args: SelectSubset<T, cacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindFirstArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cacheFindFirstArgs>(args?: SelectSubset<T, cacheFindFirstArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindFirstOrThrowArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cacheFindFirstOrThrowArgs>(args?: SelectSubset<T, cacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caches
     * const caches = await prisma.cache.findMany()
     * 
     * // Get first 10 Caches
     * const caches = await prisma.cache.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const cacheWithKeyOnly = await prisma.cache.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends cacheFindManyArgs>(args?: SelectSubset<T, cacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cache.
     * @param {cacheCreateArgs} args - Arguments to create a Cache.
     * @example
     * // Create one Cache
     * const Cache = await prisma.cache.create({
     *   data: {
     *     // ... data to create a Cache
     *   }
     * })
     * 
     */
    create<T extends cacheCreateArgs>(args: SelectSubset<T, cacheCreateArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Caches.
     * @param {cacheCreateManyArgs} args - Arguments to create many Caches.
     * @example
     * // Create many Caches
     * const cache = await prisma.cache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cacheCreateManyArgs>(args?: SelectSubset<T, cacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cache.
     * @param {cacheDeleteArgs} args - Arguments to delete one Cache.
     * @example
     * // Delete one Cache
     * const Cache = await prisma.cache.delete({
     *   where: {
     *     // ... filter to delete one Cache
     *   }
     * })
     * 
     */
    delete<T extends cacheDeleteArgs>(args: SelectSubset<T, cacheDeleteArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cache.
     * @param {cacheUpdateArgs} args - Arguments to update one Cache.
     * @example
     * // Update one Cache
     * const cache = await prisma.cache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cacheUpdateArgs>(args: SelectSubset<T, cacheUpdateArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Caches.
     * @param {cacheDeleteManyArgs} args - Arguments to filter Caches to delete.
     * @example
     * // Delete a few Caches
     * const { count } = await prisma.cache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cacheDeleteManyArgs>(args?: SelectSubset<T, cacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caches
     * const cache = await prisma.cache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cacheUpdateManyArgs>(args: SelectSubset<T, cacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cache.
     * @param {cacheUpsertArgs} args - Arguments to update or create a Cache.
     * @example
     * // Update or create a Cache
     * const cache = await prisma.cache.upsert({
     *   create: {
     *     // ... data to create a Cache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cache we want to update
     *   }
     * })
     */
    upsert<T extends cacheUpsertArgs>(args: SelectSubset<T, cacheUpsertArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheCountArgs} args - Arguments to filter Caches to count.
     * @example
     * // Count the number of Caches
     * const count = await prisma.cache.count({
     *   where: {
     *     // ... the filter for the Caches we want to count
     *   }
     * })
    **/
    count<T extends cacheCountArgs>(
      args?: Subset<T, cacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CacheAggregateArgs>(args: Subset<T, CacheAggregateArgs>): Prisma.PrismaPromise<GetCacheAggregateType<T>>

    /**
     * Group by Cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cacheGroupByArgs['orderBy'] }
        : { orderBy?: cacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cache model
   */
  readonly fields: cacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cache model
   */
  interface cacheFieldRefs {
    readonly key: FieldRef<"cache", 'String'>
    readonly value: FieldRef<"cache", 'String'>
    readonly expiration: FieldRef<"cache", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cache findUnique
   */
  export type cacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache findUniqueOrThrow
   */
  export type cacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache findFirst
   */
  export type cacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caches.
     */
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache findFirstOrThrow
   */
  export type cacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caches.
     */
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache findMany
   */
  export type cacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which caches to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache create
   */
  export type cacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data needed to create a cache.
     */
    data: XOR<cacheCreateInput, cacheUncheckedCreateInput>
  }

  /**
   * cache createMany
   */
  export type cacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caches.
     */
    data: cacheCreateManyInput | cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache update
   */
  export type cacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data needed to update a cache.
     */
    data: XOR<cacheUpdateInput, cacheUncheckedUpdateInput>
    /**
     * Choose, which cache to update.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache updateMany
   */
  export type cacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caches.
     */
    data: XOR<cacheUpdateManyMutationInput, cacheUncheckedUpdateManyInput>
    /**
     * Filter which caches to update
     */
    where?: cacheWhereInput
    /**
     * Limit how many caches to update.
     */
    limit?: number
  }

  /**
   * cache upsert
   */
  export type cacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The filter to search for the cache to update in case it exists.
     */
    where: cacheWhereUniqueInput
    /**
     * In case the cache found by the `where` argument doesn't exist, create a new cache with this data.
     */
    create: XOR<cacheCreateInput, cacheUncheckedCreateInput>
    /**
     * In case the cache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cacheUpdateInput, cacheUncheckedUpdateInput>
  }

  /**
   * cache delete
   */
  export type cacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter which cache to delete.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache deleteMany
   */
  export type cacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which caches to delete
     */
    where?: cacheWhereInput
    /**
     * Limit how many caches to delete.
     */
    limit?: number
  }

  /**
   * cache without action
   */
  export type cacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
  }


  /**
   * Model cache_locks
   */

  export type AggregateCache_locks = {
    _count: Cache_locksCountAggregateOutputType | null
    _avg: Cache_locksAvgAggregateOutputType | null
    _sum: Cache_locksSumAggregateOutputType | null
    _min: Cache_locksMinAggregateOutputType | null
    _max: Cache_locksMaxAggregateOutputType | null
  }

  export type Cache_locksAvgAggregateOutputType = {
    expiration: number | null
  }

  export type Cache_locksSumAggregateOutputType = {
    expiration: number | null
  }

  export type Cache_locksMinAggregateOutputType = {
    key: string | null
    owner: string | null
    expiration: number | null
  }

  export type Cache_locksMaxAggregateOutputType = {
    key: string | null
    owner: string | null
    expiration: number | null
  }

  export type Cache_locksCountAggregateOutputType = {
    key: number
    owner: number
    expiration: number
    _all: number
  }


  export type Cache_locksAvgAggregateInputType = {
    expiration?: true
  }

  export type Cache_locksSumAggregateInputType = {
    expiration?: true
  }

  export type Cache_locksMinAggregateInputType = {
    key?: true
    owner?: true
    expiration?: true
  }

  export type Cache_locksMaxAggregateInputType = {
    key?: true
    owner?: true
    expiration?: true
  }

  export type Cache_locksCountAggregateInputType = {
    key?: true
    owner?: true
    expiration?: true
    _all?: true
  }

  export type Cache_locksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache_locks to aggregate.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cache_locks
    **/
    _count?: true | Cache_locksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cache_locksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cache_locksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cache_locksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cache_locksMaxAggregateInputType
  }

  export type GetCache_locksAggregateType<T extends Cache_locksAggregateArgs> = {
        [P in keyof T & keyof AggregateCache_locks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCache_locks[P]>
      : GetScalarType<T[P], AggregateCache_locks[P]>
  }




  export type cache_locksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cache_locksWhereInput
    orderBy?: cache_locksOrderByWithAggregationInput | cache_locksOrderByWithAggregationInput[]
    by: Cache_locksScalarFieldEnum[] | Cache_locksScalarFieldEnum
    having?: cache_locksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cache_locksCountAggregateInputType | true
    _avg?: Cache_locksAvgAggregateInputType
    _sum?: Cache_locksSumAggregateInputType
    _min?: Cache_locksMinAggregateInputType
    _max?: Cache_locksMaxAggregateInputType
  }

  export type Cache_locksGroupByOutputType = {
    key: string
    owner: string
    expiration: number
    _count: Cache_locksCountAggregateOutputType | null
    _avg: Cache_locksAvgAggregateOutputType | null
    _sum: Cache_locksSumAggregateOutputType | null
    _min: Cache_locksMinAggregateOutputType | null
    _max: Cache_locksMaxAggregateOutputType | null
  }

  type GetCache_locksGroupByPayload<T extends cache_locksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cache_locksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cache_locksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cache_locksGroupByOutputType[P]>
            : GetScalarType<T[P], Cache_locksGroupByOutputType[P]>
        }
      >
    >


  export type cache_locksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    owner?: boolean
    expiration?: boolean
  }, ExtArgs["result"]["cache_locks"]>



  export type cache_locksSelectScalar = {
    key?: boolean
    owner?: boolean
    expiration?: boolean
  }

  export type cache_locksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "owner" | "expiration", ExtArgs["result"]["cache_locks"]>

  export type $cache_locksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cache_locks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      owner: string
      expiration: number
    }, ExtArgs["result"]["cache_locks"]>
    composites: {}
  }

  type cache_locksGetPayload<S extends boolean | null | undefined | cache_locksDefaultArgs> = $Result.GetResult<Prisma.$cache_locksPayload, S>

  type cache_locksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cache_locksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cache_locksCountAggregateInputType | true
    }

  export interface cache_locksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cache_locks'], meta: { name: 'cache_locks' } }
    /**
     * Find zero or one Cache_locks that matches the filter.
     * @param {cache_locksFindUniqueArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cache_locksFindUniqueArgs>(args: SelectSubset<T, cache_locksFindUniqueArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cache_locks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cache_locksFindUniqueOrThrowArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cache_locksFindUniqueOrThrowArgs>(args: SelectSubset<T, cache_locksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache_locks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksFindFirstArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cache_locksFindFirstArgs>(args?: SelectSubset<T, cache_locksFindFirstArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache_locks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksFindFirstOrThrowArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cache_locksFindFirstOrThrowArgs>(args?: SelectSubset<T, cache_locksFindFirstOrThrowArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cache_locks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cache_locks
     * const cache_locks = await prisma.cache_locks.findMany()
     * 
     * // Get first 10 Cache_locks
     * const cache_locks = await prisma.cache_locks.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const cache_locksWithKeyOnly = await prisma.cache_locks.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends cache_locksFindManyArgs>(args?: SelectSubset<T, cache_locksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cache_locks.
     * @param {cache_locksCreateArgs} args - Arguments to create a Cache_locks.
     * @example
     * // Create one Cache_locks
     * const Cache_locks = await prisma.cache_locks.create({
     *   data: {
     *     // ... data to create a Cache_locks
     *   }
     * })
     * 
     */
    create<T extends cache_locksCreateArgs>(args: SelectSubset<T, cache_locksCreateArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cache_locks.
     * @param {cache_locksCreateManyArgs} args - Arguments to create many Cache_locks.
     * @example
     * // Create many Cache_locks
     * const cache_locks = await prisma.cache_locks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cache_locksCreateManyArgs>(args?: SelectSubset<T, cache_locksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cache_locks.
     * @param {cache_locksDeleteArgs} args - Arguments to delete one Cache_locks.
     * @example
     * // Delete one Cache_locks
     * const Cache_locks = await prisma.cache_locks.delete({
     *   where: {
     *     // ... filter to delete one Cache_locks
     *   }
     * })
     * 
     */
    delete<T extends cache_locksDeleteArgs>(args: SelectSubset<T, cache_locksDeleteArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cache_locks.
     * @param {cache_locksUpdateArgs} args - Arguments to update one Cache_locks.
     * @example
     * // Update one Cache_locks
     * const cache_locks = await prisma.cache_locks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cache_locksUpdateArgs>(args: SelectSubset<T, cache_locksUpdateArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cache_locks.
     * @param {cache_locksDeleteManyArgs} args - Arguments to filter Cache_locks to delete.
     * @example
     * // Delete a few Cache_locks
     * const { count } = await prisma.cache_locks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cache_locksDeleteManyArgs>(args?: SelectSubset<T, cache_locksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cache_locks
     * const cache_locks = await prisma.cache_locks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cache_locksUpdateManyArgs>(args: SelectSubset<T, cache_locksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cache_locks.
     * @param {cache_locksUpsertArgs} args - Arguments to update or create a Cache_locks.
     * @example
     * // Update or create a Cache_locks
     * const cache_locks = await prisma.cache_locks.upsert({
     *   create: {
     *     // ... data to create a Cache_locks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cache_locks we want to update
     *   }
     * })
     */
    upsert<T extends cache_locksUpsertArgs>(args: SelectSubset<T, cache_locksUpsertArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksCountArgs} args - Arguments to filter Cache_locks to count.
     * @example
     * // Count the number of Cache_locks
     * const count = await prisma.cache_locks.count({
     *   where: {
     *     // ... the filter for the Cache_locks we want to count
     *   }
     * })
    **/
    count<T extends cache_locksCountArgs>(
      args?: Subset<T, cache_locksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cache_locksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cache_locksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cache_locksAggregateArgs>(args: Subset<T, Cache_locksAggregateArgs>): Prisma.PrismaPromise<GetCache_locksAggregateType<T>>

    /**
     * Group by Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cache_locksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cache_locksGroupByArgs['orderBy'] }
        : { orderBy?: cache_locksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cache_locksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCache_locksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cache_locks model
   */
  readonly fields: cache_locksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cache_locks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cache_locksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cache_locks model
   */
  interface cache_locksFieldRefs {
    readonly key: FieldRef<"cache_locks", 'String'>
    readonly owner: FieldRef<"cache_locks", 'String'>
    readonly expiration: FieldRef<"cache_locks", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cache_locks findUnique
   */
  export type cache_locksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks findUniqueOrThrow
   */
  export type cache_locksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks findFirst
   */
  export type cache_locksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cache_locks.
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cache_locks.
     */
    distinct?: Cache_locksScalarFieldEnum | Cache_locksScalarFieldEnum[]
  }

  /**
   * cache_locks findFirstOrThrow
   */
  export type cache_locksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cache_locks.
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cache_locks.
     */
    distinct?: Cache_locksScalarFieldEnum | Cache_locksScalarFieldEnum[]
  }

  /**
   * cache_locks findMany
   */
  export type cache_locksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cache_locks.
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    distinct?: Cache_locksScalarFieldEnum | Cache_locksScalarFieldEnum[]
  }

  /**
   * cache_locks create
   */
  export type cache_locksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The data needed to create a cache_locks.
     */
    data: XOR<cache_locksCreateInput, cache_locksUncheckedCreateInput>
  }

  /**
   * cache_locks createMany
   */
  export type cache_locksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cache_locks.
     */
    data: cache_locksCreateManyInput | cache_locksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache_locks update
   */
  export type cache_locksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The data needed to update a cache_locks.
     */
    data: XOR<cache_locksUpdateInput, cache_locksUncheckedUpdateInput>
    /**
     * Choose, which cache_locks to update.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks updateMany
   */
  export type cache_locksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cache_locks.
     */
    data: XOR<cache_locksUpdateManyMutationInput, cache_locksUncheckedUpdateManyInput>
    /**
     * Filter which cache_locks to update
     */
    where?: cache_locksWhereInput
    /**
     * Limit how many cache_locks to update.
     */
    limit?: number
  }

  /**
   * cache_locks upsert
   */
  export type cache_locksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The filter to search for the cache_locks to update in case it exists.
     */
    where: cache_locksWhereUniqueInput
    /**
     * In case the cache_locks found by the `where` argument doesn't exist, create a new cache_locks with this data.
     */
    create: XOR<cache_locksCreateInput, cache_locksUncheckedCreateInput>
    /**
     * In case the cache_locks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cache_locksUpdateInput, cache_locksUncheckedUpdateInput>
  }

  /**
   * cache_locks delete
   */
  export type cache_locksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter which cache_locks to delete.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks deleteMany
   */
  export type cache_locksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache_locks to delete
     */
    where?: cache_locksWhereInput
    /**
     * Limit how many cache_locks to delete.
     */
    limit?: number
  }

  /**
   * cache_locks without action
   */
  export type cache_locksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
  }


  /**
   * Model clientes
   */

  export type AggregateClientes = {
    _count: ClientesCountAggregateOutputType | null
    _avg: ClientesAvgAggregateOutputType | null
    _sum: ClientesSumAggregateOutputType | null
    _min: ClientesMinAggregateOutputType | null
    _max: ClientesMaxAggregateOutputType | null
  }

  export type ClientesAvgAggregateOutputType = {
    id: number | null
    estado_id: number | null
  }

  export type ClientesSumAggregateOutputType = {
    id: bigint | null
    estado_id: bigint | null
  }

  export type ClientesMinAggregateOutputType = {
    id: bigint | null
    rfc: string | null
    nombre: string | null
    fechaNacimiento: Date | null
    direccion: string | null
    colonia: string | null
    codigoPostal: string | null
    estado_id: bigint | null
    ciudad: string | null
    correo: string | null
    telefono: string | null
    celular: string | null
    oficina: string | null
    casa: string | null
    observaciones: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientesMaxAggregateOutputType = {
    id: bigint | null
    rfc: string | null
    nombre: string | null
    fechaNacimiento: Date | null
    direccion: string | null
    colonia: string | null
    codigoPostal: string | null
    estado_id: bigint | null
    ciudad: string | null
    correo: string | null
    telefono: string | null
    celular: string | null
    oficina: string | null
    casa: string | null
    observaciones: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientesCountAggregateOutputType = {
    id: number
    rfc: number
    nombre: number
    fechaNacimiento: number
    direccion: number
    colonia: number
    codigoPostal: number
    estado_id: number
    ciudad: number
    correo: number
    telefono: number
    celular: number
    oficina: number
    casa: number
    observaciones: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientesAvgAggregateInputType = {
    id?: true
    estado_id?: true
  }

  export type ClientesSumAggregateInputType = {
    id?: true
    estado_id?: true
  }

  export type ClientesMinAggregateInputType = {
    id?: true
    rfc?: true
    nombre?: true
    fechaNacimiento?: true
    direccion?: true
    colonia?: true
    codigoPostal?: true
    estado_id?: true
    ciudad?: true
    correo?: true
    telefono?: true
    celular?: true
    oficina?: true
    casa?: true
    observaciones?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientesMaxAggregateInputType = {
    id?: true
    rfc?: true
    nombre?: true
    fechaNacimiento?: true
    direccion?: true
    colonia?: true
    codigoPostal?: true
    estado_id?: true
    ciudad?: true
    correo?: true
    telefono?: true
    celular?: true
    oficina?: true
    casa?: true
    observaciones?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientesCountAggregateInputType = {
    id?: true
    rfc?: true
    nombre?: true
    fechaNacimiento?: true
    direccion?: true
    colonia?: true
    codigoPostal?: true
    estado_id?: true
    ciudad?: true
    correo?: true
    telefono?: true
    celular?: true
    oficina?: true
    casa?: true
    observaciones?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientes to aggregate.
     */
    where?: clientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clientesOrderByWithRelationInput | clientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientes
    **/
    _count?: true | ClientesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientesMaxAggregateInputType
  }

  export type GetClientesAggregateType<T extends ClientesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientes[P]>
      : GetScalarType<T[P], AggregateClientes[P]>
  }




  export type clientesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientesWhereInput
    orderBy?: clientesOrderByWithAggregationInput | clientesOrderByWithAggregationInput[]
    by: ClientesScalarFieldEnum[] | ClientesScalarFieldEnum
    having?: clientesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientesCountAggregateInputType | true
    _avg?: ClientesAvgAggregateInputType
    _sum?: ClientesSumAggregateInputType
    _min?: ClientesMinAggregateInputType
    _max?: ClientesMaxAggregateInputType
  }

  export type ClientesGroupByOutputType = {
    id: bigint
    rfc: string
    nombre: string
    fechaNacimiento: Date
    direccion: string
    colonia: string
    codigoPostal: string
    estado_id: bigint
    ciudad: string
    correo: string | null
    telefono: string | null
    celular: string | null
    oficina: string | null
    casa: string | null
    observaciones: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: ClientesCountAggregateOutputType | null
    _avg: ClientesAvgAggregateOutputType | null
    _sum: ClientesSumAggregateOutputType | null
    _min: ClientesMinAggregateOutputType | null
    _max: ClientesMaxAggregateOutputType | null
  }

  type GetClientesGroupByPayload<T extends clientesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientesGroupByOutputType[P]>
        }
      >
    >


  export type clientesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfc?: boolean
    nombre?: boolean
    fechaNacimiento?: boolean
    direccion?: boolean
    colonia?: boolean
    codigoPostal?: boolean
    estado_id?: boolean
    ciudad?: boolean
    correo?: boolean
    telefono?: boolean
    celular?: boolean
    oficina?: boolean
    casa?: boolean
    observaciones?: boolean
    created_at?: boolean
    updated_at?: boolean
    polizas?: boolean | clientes$polizasArgs<ExtArgs>
    _count?: boolean | ClientesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientes"]>



  export type clientesSelectScalar = {
    id?: boolean
    rfc?: boolean
    nombre?: boolean
    fechaNacimiento?: boolean
    direccion?: boolean
    colonia?: boolean
    codigoPostal?: boolean
    estado_id?: boolean
    ciudad?: boolean
    correo?: boolean
    telefono?: boolean
    celular?: boolean
    oficina?: boolean
    casa?: boolean
    observaciones?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type clientesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfc" | "nombre" | "fechaNacimiento" | "direccion" | "colonia" | "codigoPostal" | "estado_id" | "ciudad" | "correo" | "telefono" | "celular" | "oficina" | "casa" | "observaciones" | "created_at" | "updated_at", ExtArgs["result"]["clientes"]>
  export type clientesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | clientes$polizasArgs<ExtArgs>
    _count?: boolean | ClientesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $clientesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clientes"
    objects: {
      polizas: Prisma.$polizasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      rfc: string
      nombre: string
      fechaNacimiento: Date
      direccion: string
      colonia: string
      codigoPostal: string
      estado_id: bigint
      ciudad: string
      correo: string | null
      telefono: string | null
      celular: string | null
      oficina: string | null
      casa: string | null
      observaciones: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["clientes"]>
    composites: {}
  }

  type clientesGetPayload<S extends boolean | null | undefined | clientesDefaultArgs> = $Result.GetResult<Prisma.$clientesPayload, S>

  type clientesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clientesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientesCountAggregateInputType | true
    }

  export interface clientesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clientes'], meta: { name: 'clientes' } }
    /**
     * Find zero or one Clientes that matches the filter.
     * @param {clientesFindUniqueArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientesFindUniqueArgs>(args: SelectSubset<T, clientesFindUniqueArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clientes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clientesFindUniqueOrThrowArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientesFindUniqueOrThrowArgs>(args: SelectSubset<T, clientesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesFindFirstArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientesFindFirstArgs>(args?: SelectSubset<T, clientesFindFirstArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clientes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesFindFirstOrThrowArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientesFindFirstOrThrowArgs>(args?: SelectSubset<T, clientesFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.clientes.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.clientes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientesWithIdOnly = await prisma.clientes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clientesFindManyArgs>(args?: SelectSubset<T, clientesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clientes.
     * @param {clientesCreateArgs} args - Arguments to create a Clientes.
     * @example
     * // Create one Clientes
     * const Clientes = await prisma.clientes.create({
     *   data: {
     *     // ... data to create a Clientes
     *   }
     * })
     * 
     */
    create<T extends clientesCreateArgs>(args: SelectSubset<T, clientesCreateArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clientes.
     * @param {clientesCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const clientes = await prisma.clientes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientesCreateManyArgs>(args?: SelectSubset<T, clientesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clientes.
     * @param {clientesDeleteArgs} args - Arguments to delete one Clientes.
     * @example
     * // Delete one Clientes
     * const Clientes = await prisma.clientes.delete({
     *   where: {
     *     // ... filter to delete one Clientes
     *   }
     * })
     * 
     */
    delete<T extends clientesDeleteArgs>(args: SelectSubset<T, clientesDeleteArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clientes.
     * @param {clientesUpdateArgs} args - Arguments to update one Clientes.
     * @example
     * // Update one Clientes
     * const clientes = await prisma.clientes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientesUpdateArgs>(args: SelectSubset<T, clientesUpdateArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clientes.
     * @param {clientesDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.clientes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientesDeleteManyArgs>(args?: SelectSubset<T, clientesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const clientes = await prisma.clientes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientesUpdateManyArgs>(args: SelectSubset<T, clientesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientes.
     * @param {clientesUpsertArgs} args - Arguments to update or create a Clientes.
     * @example
     * // Update or create a Clientes
     * const clientes = await prisma.clientes.upsert({
     *   create: {
     *     // ... data to create a Clientes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientes we want to update
     *   }
     * })
     */
    upsert<T extends clientesUpsertArgs>(args: SelectSubset<T, clientesUpsertArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.clientes.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends clientesCountArgs>(
      args?: Subset<T, clientesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientesAggregateArgs>(args: Subset<T, ClientesAggregateArgs>): Prisma.PrismaPromise<GetClientesAggregateType<T>>

    /**
     * Group by Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientesGroupByArgs['orderBy'] }
        : { orderBy?: clientesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clientes model
   */
  readonly fields: clientesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    polizas<T extends clientes$polizasArgs<ExtArgs> = {}>(args?: Subset<T, clientes$polizasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clientes model
   */
  interface clientesFieldRefs {
    readonly id: FieldRef<"clientes", 'BigInt'>
    readonly rfc: FieldRef<"clientes", 'String'>
    readonly nombre: FieldRef<"clientes", 'String'>
    readonly fechaNacimiento: FieldRef<"clientes", 'DateTime'>
    readonly direccion: FieldRef<"clientes", 'String'>
    readonly colonia: FieldRef<"clientes", 'String'>
    readonly codigoPostal: FieldRef<"clientes", 'String'>
    readonly estado_id: FieldRef<"clientes", 'BigInt'>
    readonly ciudad: FieldRef<"clientes", 'String'>
    readonly correo: FieldRef<"clientes", 'String'>
    readonly telefono: FieldRef<"clientes", 'String'>
    readonly celular: FieldRef<"clientes", 'String'>
    readonly oficina: FieldRef<"clientes", 'String'>
    readonly casa: FieldRef<"clientes", 'String'>
    readonly observaciones: FieldRef<"clientes", 'String'>
    readonly created_at: FieldRef<"clientes", 'DateTime'>
    readonly updated_at: FieldRef<"clientes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * clientes findUnique
   */
  export type clientesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientes
     */
    omit?: clientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where: clientesWhereUniqueInput
  }

  /**
   * clientes findUniqueOrThrow
   */
  export type clientesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientes
     */
    omit?: clientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where: clientesWhereUniqueInput
  }

  /**
   * clientes findFirst
   */
  export type clientesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientes
     */
    omit?: clientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where?: clientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clientesOrderByWithRelationInput | clientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     */
    cursor?: clientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     */
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }

  /**
   * clientes findFirstOrThrow
   */
  export type clientesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientes
     */
    omit?: clientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where?: clientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clientesOrderByWithRelationInput | clientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     */
    cursor?: clientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     */
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }

  /**
   * clientes findMany
   */
  export type clientesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientes
     */
    omit?: clientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where?: clientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clientesOrderByWithRelationInput | clientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientes.
     */
    cursor?: clientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }

  /**
   * clientes create
   */
  export type clientesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientes
     */
    omit?: clientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * The data needed to create a clientes.
     */
    data: XOR<clientesCreateInput, clientesUncheckedCreateInput>
  }

  /**
   * clientes createMany
   */
  export type clientesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clientes.
     */
    data: clientesCreateManyInput | clientesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clientes update
   */
  export type clientesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientes
     */
    omit?: clientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * The data needed to update a clientes.
     */
    data: XOR<clientesUpdateInput, clientesUncheckedUpdateInput>
    /**
     * Choose, which clientes to update.
     */
    where: clientesWhereUniqueInput
  }

  /**
   * clientes updateMany
   */
  export type clientesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clientes.
     */
    data: XOR<clientesUpdateManyMutationInput, clientesUncheckedUpdateManyInput>
    /**
     * Filter which clientes to update
     */
    where?: clientesWhereInput
    /**
     * Limit how many clientes to update.
     */
    limit?: number
  }

  /**
   * clientes upsert
   */
  export type clientesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientes
     */
    omit?: clientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * The filter to search for the clientes to update in case it exists.
     */
    where: clientesWhereUniqueInput
    /**
     * In case the clientes found by the `where` argument doesn't exist, create a new clientes with this data.
     */
    create: XOR<clientesCreateInput, clientesUncheckedCreateInput>
    /**
     * In case the clientes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientesUpdateInput, clientesUncheckedUpdateInput>
  }

  /**
   * clientes delete
   */
  export type clientesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientes
     */
    omit?: clientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
    /**
     * Filter which clientes to delete.
     */
    where: clientesWhereUniqueInput
  }

  /**
   * clientes deleteMany
   */
  export type clientesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientes to delete
     */
    where?: clientesWhereInput
    /**
     * Limit how many clientes to delete.
     */
    limit?: number
  }

  /**
   * clientes.polizas
   */
  export type clientes$polizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    where?: polizasWhereInput
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    cursor?: polizasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * clientes without action
   */
  export type clientesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientes
     */
    select?: clientesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientes
     */
    omit?: clientesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientesInclude<ExtArgs> | null
  }


  /**
   * Model compania
   */

  export type AggregateCompania = {
    _count: CompaniaCountAggregateOutputType | null
    _avg: CompaniaAvgAggregateOutputType | null
    _sum: CompaniaSumAggregateOutputType | null
    _min: CompaniaMinAggregateOutputType | null
    _max: CompaniaMaxAggregateOutputType | null
  }

  export type CompaniaAvgAggregateOutputType = {
    id: number | null
    limitePrimerPago: Decimal | null
    limitePrimerSubsecuente: Decimal | null
  }

  export type CompaniaSumAggregateOutputType = {
    id: bigint | null
    limitePrimerPago: Decimal | null
    limitePrimerSubsecuente: Decimal | null
  }

  export type CompaniaMinAggregateOutputType = {
    id: bigint | null
    rfc: string | null
    nombre: string | null
    nombreCorto: string | null
    direccion: string | null
    estado: string | null
    codigoPostal: string | null
    ciudad: string | null
    limitePrimerPago: Decimal | null
    limitePrimerSubsecuente: Decimal | null
    estatus: boolean | null
    colonia: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompaniaMaxAggregateOutputType = {
    id: bigint | null
    rfc: string | null
    nombre: string | null
    nombreCorto: string | null
    direccion: string | null
    estado: string | null
    codigoPostal: string | null
    ciudad: string | null
    limitePrimerPago: Decimal | null
    limitePrimerSubsecuente: Decimal | null
    estatus: boolean | null
    colonia: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompaniaCountAggregateOutputType = {
    id: number
    rfc: number
    nombre: number
    nombreCorto: number
    direccion: number
    estado: number
    codigoPostal: number
    ciudad: number
    limitePrimerPago: number
    limitePrimerSubsecuente: number
    estatus: number
    colonia: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CompaniaAvgAggregateInputType = {
    id?: true
    limitePrimerPago?: true
    limitePrimerSubsecuente?: true
  }

  export type CompaniaSumAggregateInputType = {
    id?: true
    limitePrimerPago?: true
    limitePrimerSubsecuente?: true
  }

  export type CompaniaMinAggregateInputType = {
    id?: true
    rfc?: true
    nombre?: true
    nombreCorto?: true
    direccion?: true
    estado?: true
    codigoPostal?: true
    ciudad?: true
    limitePrimerPago?: true
    limitePrimerSubsecuente?: true
    estatus?: true
    colonia?: true
    created_at?: true
    updated_at?: true
  }

  export type CompaniaMaxAggregateInputType = {
    id?: true
    rfc?: true
    nombre?: true
    nombreCorto?: true
    direccion?: true
    estado?: true
    codigoPostal?: true
    ciudad?: true
    limitePrimerPago?: true
    limitePrimerSubsecuente?: true
    estatus?: true
    colonia?: true
    created_at?: true
    updated_at?: true
  }

  export type CompaniaCountAggregateInputType = {
    id?: true
    rfc?: true
    nombre?: true
    nombreCorto?: true
    direccion?: true
    estado?: true
    codigoPostal?: true
    ciudad?: true
    limitePrimerPago?: true
    limitePrimerSubsecuente?: true
    estatus?: true
    colonia?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CompaniaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compania to aggregate.
     */
    where?: companiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias to fetch.
     */
    orderBy?: companiaOrderByWithRelationInput | companiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companias
    **/
    _count?: true | CompaniaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniaMaxAggregateInputType
  }

  export type GetCompaniaAggregateType<T extends CompaniaAggregateArgs> = {
        [P in keyof T & keyof AggregateCompania]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompania[P]>
      : GetScalarType<T[P], AggregateCompania[P]>
  }




  export type companiaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiaWhereInput
    orderBy?: companiaOrderByWithAggregationInput | companiaOrderByWithAggregationInput[]
    by: CompaniaScalarFieldEnum[] | CompaniaScalarFieldEnum
    having?: companiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniaCountAggregateInputType | true
    _avg?: CompaniaAvgAggregateInputType
    _sum?: CompaniaSumAggregateInputType
    _min?: CompaniaMinAggregateInputType
    _max?: CompaniaMaxAggregateInputType
  }

  export type CompaniaGroupByOutputType = {
    id: bigint
    rfc: string
    nombre: string
    nombreCorto: string
    direccion: string | null
    estado: string | null
    codigoPostal: string | null
    ciudad: string | null
    limitePrimerPago: Decimal | null
    limitePrimerSubsecuente: Decimal | null
    estatus: boolean | null
    colonia: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: CompaniaCountAggregateOutputType | null
    _avg: CompaniaAvgAggregateOutputType | null
    _sum: CompaniaSumAggregateOutputType | null
    _min: CompaniaMinAggregateOutputType | null
    _max: CompaniaMaxAggregateOutputType | null
  }

  type GetCompaniaGroupByPayload<T extends companiaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniaGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniaGroupByOutputType[P]>
        }
      >
    >


  export type companiaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfc?: boolean
    nombre?: boolean
    nombreCorto?: boolean
    direccion?: boolean
    estado?: boolean
    codigoPostal?: boolean
    ciudad?: boolean
    limitePrimerPago?: boolean
    limitePrimerSubsecuente?: boolean
    estatus?: boolean
    colonia?: boolean
    created_at?: boolean
    updated_at?: boolean
    compania_representantes?: boolean | compania$compania_representantesArgs<ExtArgs>
    companias_productos?: boolean | compania$companias_productosArgs<ExtArgs>
    companias_ramos?: boolean | compania$companias_ramosArgs<ExtArgs>
    polizas?: boolean | compania$polizasArgs<ExtArgs>
    usuario_claves?: boolean | compania$usuario_clavesArgs<ExtArgs>
    _count?: boolean | CompaniaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["compania"]>



  export type companiaSelectScalar = {
    id?: boolean
    rfc?: boolean
    nombre?: boolean
    nombreCorto?: boolean
    direccion?: boolean
    estado?: boolean
    codigoPostal?: boolean
    ciudad?: boolean
    limitePrimerPago?: boolean
    limitePrimerSubsecuente?: boolean
    estatus?: boolean
    colonia?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type companiaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfc" | "nombre" | "nombreCorto" | "direccion" | "estado" | "codigoPostal" | "ciudad" | "limitePrimerPago" | "limitePrimerSubsecuente" | "estatus" | "colonia" | "created_at" | "updated_at", ExtArgs["result"]["compania"]>
  export type companiaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compania_representantes?: boolean | compania$compania_representantesArgs<ExtArgs>
    companias_productos?: boolean | compania$companias_productosArgs<ExtArgs>
    companias_ramos?: boolean | compania$companias_ramosArgs<ExtArgs>
    polizas?: boolean | compania$polizasArgs<ExtArgs>
    usuario_claves?: boolean | compania$usuario_clavesArgs<ExtArgs>
    _count?: boolean | CompaniaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $companiaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "compania"
    objects: {
      compania_representantes: Prisma.$compania_representantesPayload<ExtArgs>[]
      companias_productos: Prisma.$companias_productosPayload<ExtArgs>[]
      companias_ramos: Prisma.$companias_ramosPayload<ExtArgs>[]
      polizas: Prisma.$polizasPayload<ExtArgs>[]
      usuario_claves: Prisma.$usuario_clavesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      rfc: string
      nombre: string
      nombreCorto: string
      direccion: string | null
      estado: string | null
      codigoPostal: string | null
      ciudad: string | null
      limitePrimerPago: Prisma.Decimal | null
      limitePrimerSubsecuente: Prisma.Decimal | null
      estatus: boolean | null
      colonia: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["compania"]>
    composites: {}
  }

  type companiaGetPayload<S extends boolean | null | undefined | companiaDefaultArgs> = $Result.GetResult<Prisma.$companiaPayload, S>

  type companiaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companiaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniaCountAggregateInputType | true
    }

  export interface companiaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['compania'], meta: { name: 'compania' } }
    /**
     * Find zero or one Compania that matches the filter.
     * @param {companiaFindUniqueArgs} args - Arguments to find a Compania
     * @example
     * // Get one Compania
     * const compania = await prisma.compania.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companiaFindUniqueArgs>(args: SelectSubset<T, companiaFindUniqueArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Compania that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companiaFindUniqueOrThrowArgs} args - Arguments to find a Compania
     * @example
     * // Get one Compania
     * const compania = await prisma.compania.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companiaFindUniqueOrThrowArgs>(args: SelectSubset<T, companiaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compania that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiaFindFirstArgs} args - Arguments to find a Compania
     * @example
     * // Get one Compania
     * const compania = await prisma.compania.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companiaFindFirstArgs>(args?: SelectSubset<T, companiaFindFirstArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compania that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiaFindFirstOrThrowArgs} args - Arguments to find a Compania
     * @example
     * // Get one Compania
     * const compania = await prisma.compania.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companiaFindFirstOrThrowArgs>(args?: SelectSubset<T, companiaFindFirstOrThrowArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companias
     * const companias = await prisma.compania.findMany()
     * 
     * // Get first 10 Companias
     * const companias = await prisma.compania.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiaWithIdOnly = await prisma.compania.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companiaFindManyArgs>(args?: SelectSubset<T, companiaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Compania.
     * @param {companiaCreateArgs} args - Arguments to create a Compania.
     * @example
     * // Create one Compania
     * const Compania = await prisma.compania.create({
     *   data: {
     *     // ... data to create a Compania
     *   }
     * })
     * 
     */
    create<T extends companiaCreateArgs>(args: SelectSubset<T, companiaCreateArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companias.
     * @param {companiaCreateManyArgs} args - Arguments to create many Companias.
     * @example
     * // Create many Companias
     * const compania = await prisma.compania.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companiaCreateManyArgs>(args?: SelectSubset<T, companiaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Compania.
     * @param {companiaDeleteArgs} args - Arguments to delete one Compania.
     * @example
     * // Delete one Compania
     * const Compania = await prisma.compania.delete({
     *   where: {
     *     // ... filter to delete one Compania
     *   }
     * })
     * 
     */
    delete<T extends companiaDeleteArgs>(args: SelectSubset<T, companiaDeleteArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Compania.
     * @param {companiaUpdateArgs} args - Arguments to update one Compania.
     * @example
     * // Update one Compania
     * const compania = await prisma.compania.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companiaUpdateArgs>(args: SelectSubset<T, companiaUpdateArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companias.
     * @param {companiaDeleteManyArgs} args - Arguments to filter Companias to delete.
     * @example
     * // Delete a few Companias
     * const { count } = await prisma.compania.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companiaDeleteManyArgs>(args?: SelectSubset<T, companiaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companias
     * const compania = await prisma.compania.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companiaUpdateManyArgs>(args: SelectSubset<T, companiaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Compania.
     * @param {companiaUpsertArgs} args - Arguments to update or create a Compania.
     * @example
     * // Update or create a Compania
     * const compania = await prisma.compania.upsert({
     *   create: {
     *     // ... data to create a Compania
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compania we want to update
     *   }
     * })
     */
    upsert<T extends companiaUpsertArgs>(args: SelectSubset<T, companiaUpsertArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiaCountArgs} args - Arguments to filter Companias to count.
     * @example
     * // Count the number of Companias
     * const count = await prisma.compania.count({
     *   where: {
     *     // ... the filter for the Companias we want to count
     *   }
     * })
    **/
    count<T extends companiaCountArgs>(
      args?: Subset<T, companiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compania.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniaAggregateArgs>(args: Subset<T, CompaniaAggregateArgs>): Prisma.PrismaPromise<GetCompaniaAggregateType<T>>

    /**
     * Group by Compania.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companiaGroupByArgs['orderBy'] }
        : { orderBy?: companiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the compania model
   */
  readonly fields: companiaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for compania.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companiaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    compania_representantes<T extends compania$compania_representantesArgs<ExtArgs> = {}>(args?: Subset<T, compania$compania_representantesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$compania_representantesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companias_productos<T extends compania$companias_productosArgs<ExtArgs> = {}>(args?: Subset<T, compania$companias_productosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companias_ramos<T extends compania$companias_ramosArgs<ExtArgs> = {}>(args?: Subset<T, compania$companias_ramosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    polizas<T extends compania$polizasArgs<ExtArgs> = {}>(args?: Subset<T, compania$polizasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuario_claves<T extends compania$usuario_clavesArgs<ExtArgs> = {}>(args?: Subset<T, compania$usuario_clavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuario_clavesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the compania model
   */
  interface companiaFieldRefs {
    readonly id: FieldRef<"compania", 'BigInt'>
    readonly rfc: FieldRef<"compania", 'String'>
    readonly nombre: FieldRef<"compania", 'String'>
    readonly nombreCorto: FieldRef<"compania", 'String'>
    readonly direccion: FieldRef<"compania", 'String'>
    readonly estado: FieldRef<"compania", 'String'>
    readonly codigoPostal: FieldRef<"compania", 'String'>
    readonly ciudad: FieldRef<"compania", 'String'>
    readonly limitePrimerPago: FieldRef<"compania", 'Decimal'>
    readonly limitePrimerSubsecuente: FieldRef<"compania", 'Decimal'>
    readonly estatus: FieldRef<"compania", 'Boolean'>
    readonly colonia: FieldRef<"compania", 'String'>
    readonly created_at: FieldRef<"compania", 'DateTime'>
    readonly updated_at: FieldRef<"compania", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * compania findUnique
   */
  export type companiaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania
     */
    select?: companiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania
     */
    omit?: companiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiaInclude<ExtArgs> | null
    /**
     * Filter, which compania to fetch.
     */
    where: companiaWhereUniqueInput
  }

  /**
   * compania findUniqueOrThrow
   */
  export type companiaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania
     */
    select?: companiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania
     */
    omit?: companiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiaInclude<ExtArgs> | null
    /**
     * Filter, which compania to fetch.
     */
    where: companiaWhereUniqueInput
  }

  /**
   * compania findFirst
   */
  export type companiaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania
     */
    select?: companiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania
     */
    omit?: companiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiaInclude<ExtArgs> | null
    /**
     * Filter, which compania to fetch.
     */
    where?: companiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias to fetch.
     */
    orderBy?: companiaOrderByWithRelationInput | companiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companias.
     */
    cursor?: companiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companias.
     */
    distinct?: CompaniaScalarFieldEnum | CompaniaScalarFieldEnum[]
  }

  /**
   * compania findFirstOrThrow
   */
  export type companiaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania
     */
    select?: companiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania
     */
    omit?: companiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiaInclude<ExtArgs> | null
    /**
     * Filter, which compania to fetch.
     */
    where?: companiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias to fetch.
     */
    orderBy?: companiaOrderByWithRelationInput | companiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companias.
     */
    cursor?: companiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companias.
     */
    distinct?: CompaniaScalarFieldEnum | CompaniaScalarFieldEnum[]
  }

  /**
   * compania findMany
   */
  export type companiaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania
     */
    select?: companiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania
     */
    omit?: companiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiaInclude<ExtArgs> | null
    /**
     * Filter, which companias to fetch.
     */
    where?: companiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias to fetch.
     */
    orderBy?: companiaOrderByWithRelationInput | companiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companias.
     */
    cursor?: companiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias.
     */
    skip?: number
    distinct?: CompaniaScalarFieldEnum | CompaniaScalarFieldEnum[]
  }

  /**
   * compania create
   */
  export type companiaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania
     */
    select?: companiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania
     */
    omit?: companiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiaInclude<ExtArgs> | null
    /**
     * The data needed to create a compania.
     */
    data: XOR<companiaCreateInput, companiaUncheckedCreateInput>
  }

  /**
   * compania createMany
   */
  export type companiaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companias.
     */
    data: companiaCreateManyInput | companiaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * compania update
   */
  export type companiaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania
     */
    select?: companiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania
     */
    omit?: companiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiaInclude<ExtArgs> | null
    /**
     * The data needed to update a compania.
     */
    data: XOR<companiaUpdateInput, companiaUncheckedUpdateInput>
    /**
     * Choose, which compania to update.
     */
    where: companiaWhereUniqueInput
  }

  /**
   * compania updateMany
   */
  export type companiaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companias.
     */
    data: XOR<companiaUpdateManyMutationInput, companiaUncheckedUpdateManyInput>
    /**
     * Filter which companias to update
     */
    where?: companiaWhereInput
    /**
     * Limit how many companias to update.
     */
    limit?: number
  }

  /**
   * compania upsert
   */
  export type companiaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania
     */
    select?: companiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania
     */
    omit?: companiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiaInclude<ExtArgs> | null
    /**
     * The filter to search for the compania to update in case it exists.
     */
    where: companiaWhereUniqueInput
    /**
     * In case the compania found by the `where` argument doesn't exist, create a new compania with this data.
     */
    create: XOR<companiaCreateInput, companiaUncheckedCreateInput>
    /**
     * In case the compania was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companiaUpdateInput, companiaUncheckedUpdateInput>
  }

  /**
   * compania delete
   */
  export type companiaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania
     */
    select?: companiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania
     */
    omit?: companiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiaInclude<ExtArgs> | null
    /**
     * Filter which compania to delete.
     */
    where: companiaWhereUniqueInput
  }

  /**
   * compania deleteMany
   */
  export type companiaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companias to delete
     */
    where?: companiaWhereInput
    /**
     * Limit how many companias to delete.
     */
    limit?: number
  }

  /**
   * compania.compania_representantes
   */
  export type compania$compania_representantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
    where?: compania_representantesWhereInput
    orderBy?: compania_representantesOrderByWithRelationInput | compania_representantesOrderByWithRelationInput[]
    cursor?: compania_representantesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Compania_representantesScalarFieldEnum | Compania_representantesScalarFieldEnum[]
  }

  /**
   * compania.companias_productos
   */
  export type compania$companias_productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    where?: companias_productosWhereInput
    orderBy?: companias_productosOrderByWithRelationInput | companias_productosOrderByWithRelationInput[]
    cursor?: companias_productosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Companias_productosScalarFieldEnum | Companias_productosScalarFieldEnum[]
  }

  /**
   * compania.companias_ramos
   */
  export type compania$companias_ramosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    where?: companias_ramosWhereInput
    orderBy?: companias_ramosOrderByWithRelationInput | companias_ramosOrderByWithRelationInput[]
    cursor?: companias_ramosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Companias_ramosScalarFieldEnum | Companias_ramosScalarFieldEnum[]
  }

  /**
   * compania.polizas
   */
  export type compania$polizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    where?: polizasWhereInput
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    cursor?: polizasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * compania.usuario_claves
   */
  export type compania$usuario_clavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
    where?: usuario_clavesWhereInput
    orderBy?: usuario_clavesOrderByWithRelationInput | usuario_clavesOrderByWithRelationInput[]
    cursor?: usuario_clavesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Usuario_clavesScalarFieldEnum | Usuario_clavesScalarFieldEnum[]
  }

  /**
   * compania without action
   */
  export type companiaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania
     */
    select?: companiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania
     */
    omit?: companiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiaInclude<ExtArgs> | null
  }


  /**
   * Model compania_representantes
   */

  export type AggregateCompania_representantes = {
    _count: Compania_representantesCountAggregateOutputType | null
    _avg: Compania_representantesAvgAggregateOutputType | null
    _sum: Compania_representantesSumAggregateOutputType | null
    _min: Compania_representantesMinAggregateOutputType | null
    _max: Compania_representantesMaxAggregateOutputType | null
  }

  export type Compania_representantesAvgAggregateOutputType = {
    id: number | null
    compania_id: number | null
  }

  export type Compania_representantesSumAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
  }

  export type Compania_representantesMinAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    nombre: string | null
    telefono: string | null
    correo: string | null
    cargo: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Compania_representantesMaxAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    nombre: string | null
    telefono: string | null
    correo: string | null
    cargo: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Compania_representantesCountAggregateOutputType = {
    id: number
    compania_id: number
    nombre: number
    telefono: number
    correo: number
    cargo: number
    estatus: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Compania_representantesAvgAggregateInputType = {
    id?: true
    compania_id?: true
  }

  export type Compania_representantesSumAggregateInputType = {
    id?: true
    compania_id?: true
  }

  export type Compania_representantesMinAggregateInputType = {
    id?: true
    compania_id?: true
    nombre?: true
    telefono?: true
    correo?: true
    cargo?: true
    estatus?: true
    created_at?: true
    updated_at?: true
  }

  export type Compania_representantesMaxAggregateInputType = {
    id?: true
    compania_id?: true
    nombre?: true
    telefono?: true
    correo?: true
    cargo?: true
    estatus?: true
    created_at?: true
    updated_at?: true
  }

  export type Compania_representantesCountAggregateInputType = {
    id?: true
    compania_id?: true
    nombre?: true
    telefono?: true
    correo?: true
    cargo?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Compania_representantesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compania_representantes to aggregate.
     */
    where?: compania_representantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compania_representantes to fetch.
     */
    orderBy?: compania_representantesOrderByWithRelationInput | compania_representantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: compania_representantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compania_representantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compania_representantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned compania_representantes
    **/
    _count?: true | Compania_representantesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Compania_representantesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Compania_representantesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Compania_representantesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Compania_representantesMaxAggregateInputType
  }

  export type GetCompania_representantesAggregateType<T extends Compania_representantesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompania_representantes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompania_representantes[P]>
      : GetScalarType<T[P], AggregateCompania_representantes[P]>
  }




  export type compania_representantesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: compania_representantesWhereInput
    orderBy?: compania_representantesOrderByWithAggregationInput | compania_representantesOrderByWithAggregationInput[]
    by: Compania_representantesScalarFieldEnum[] | Compania_representantesScalarFieldEnum
    having?: compania_representantesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Compania_representantesCountAggregateInputType | true
    _avg?: Compania_representantesAvgAggregateInputType
    _sum?: Compania_representantesSumAggregateInputType
    _min?: Compania_representantesMinAggregateInputType
    _max?: Compania_representantesMaxAggregateInputType
  }

  export type Compania_representantesGroupByOutputType = {
    id: bigint
    compania_id: bigint
    nombre: string
    telefono: string
    correo: string
    cargo: string
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    _count: Compania_representantesCountAggregateOutputType | null
    _avg: Compania_representantesAvgAggregateOutputType | null
    _sum: Compania_representantesSumAggregateOutputType | null
    _min: Compania_representantesMinAggregateOutputType | null
    _max: Compania_representantesMaxAggregateOutputType | null
  }

  type GetCompania_representantesGroupByPayload<T extends compania_representantesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Compania_representantesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Compania_representantesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Compania_representantesGroupByOutputType[P]>
            : GetScalarType<T[P], Compania_representantesGroupByOutputType[P]>
        }
      >
    >


  export type compania_representantesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    compania_id?: boolean
    nombre?: boolean
    telefono?: boolean
    correo?: boolean
    cargo?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    compania?: boolean | companiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["compania_representantes"]>



  export type compania_representantesSelectScalar = {
    id?: boolean
    compania_id?: boolean
    nombre?: boolean
    telefono?: boolean
    correo?: boolean
    cargo?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type compania_representantesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "compania_id" | "nombre" | "telefono" | "correo" | "cargo" | "estatus" | "created_at" | "updated_at", ExtArgs["result"]["compania_representantes"]>
  export type compania_representantesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compania?: boolean | companiaDefaultArgs<ExtArgs>
  }

  export type $compania_representantesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "compania_representantes"
    objects: {
      compania: Prisma.$companiaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      compania_id: bigint
      nombre: string
      telefono: string
      correo: string
      cargo: string
      estatus: boolean | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["compania_representantes"]>
    composites: {}
  }

  type compania_representantesGetPayload<S extends boolean | null | undefined | compania_representantesDefaultArgs> = $Result.GetResult<Prisma.$compania_representantesPayload, S>

  type compania_representantesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<compania_representantesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Compania_representantesCountAggregateInputType | true
    }

  export interface compania_representantesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['compania_representantes'], meta: { name: 'compania_representantes' } }
    /**
     * Find zero or one Compania_representantes that matches the filter.
     * @param {compania_representantesFindUniqueArgs} args - Arguments to find a Compania_representantes
     * @example
     * // Get one Compania_representantes
     * const compania_representantes = await prisma.compania_representantes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends compania_representantesFindUniqueArgs>(args: SelectSubset<T, compania_representantesFindUniqueArgs<ExtArgs>>): Prisma__compania_representantesClient<$Result.GetResult<Prisma.$compania_representantesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Compania_representantes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {compania_representantesFindUniqueOrThrowArgs} args - Arguments to find a Compania_representantes
     * @example
     * // Get one Compania_representantes
     * const compania_representantes = await prisma.compania_representantes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends compania_representantesFindUniqueOrThrowArgs>(args: SelectSubset<T, compania_representantesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__compania_representantesClient<$Result.GetResult<Prisma.$compania_representantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compania_representantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compania_representantesFindFirstArgs} args - Arguments to find a Compania_representantes
     * @example
     * // Get one Compania_representantes
     * const compania_representantes = await prisma.compania_representantes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends compania_representantesFindFirstArgs>(args?: SelectSubset<T, compania_representantesFindFirstArgs<ExtArgs>>): Prisma__compania_representantesClient<$Result.GetResult<Prisma.$compania_representantesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compania_representantes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compania_representantesFindFirstOrThrowArgs} args - Arguments to find a Compania_representantes
     * @example
     * // Get one Compania_representantes
     * const compania_representantes = await prisma.compania_representantes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends compania_representantesFindFirstOrThrowArgs>(args?: SelectSubset<T, compania_representantesFindFirstOrThrowArgs<ExtArgs>>): Prisma__compania_representantesClient<$Result.GetResult<Prisma.$compania_representantesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Compania_representantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compania_representantesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Compania_representantes
     * const compania_representantes = await prisma.compania_representantes.findMany()
     * 
     * // Get first 10 Compania_representantes
     * const compania_representantes = await prisma.compania_representantes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const compania_representantesWithIdOnly = await prisma.compania_representantes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends compania_representantesFindManyArgs>(args?: SelectSubset<T, compania_representantesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$compania_representantesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Compania_representantes.
     * @param {compania_representantesCreateArgs} args - Arguments to create a Compania_representantes.
     * @example
     * // Create one Compania_representantes
     * const Compania_representantes = await prisma.compania_representantes.create({
     *   data: {
     *     // ... data to create a Compania_representantes
     *   }
     * })
     * 
     */
    create<T extends compania_representantesCreateArgs>(args: SelectSubset<T, compania_representantesCreateArgs<ExtArgs>>): Prisma__compania_representantesClient<$Result.GetResult<Prisma.$compania_representantesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Compania_representantes.
     * @param {compania_representantesCreateManyArgs} args - Arguments to create many Compania_representantes.
     * @example
     * // Create many Compania_representantes
     * const compania_representantes = await prisma.compania_representantes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends compania_representantesCreateManyArgs>(args?: SelectSubset<T, compania_representantesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Compania_representantes.
     * @param {compania_representantesDeleteArgs} args - Arguments to delete one Compania_representantes.
     * @example
     * // Delete one Compania_representantes
     * const Compania_representantes = await prisma.compania_representantes.delete({
     *   where: {
     *     // ... filter to delete one Compania_representantes
     *   }
     * })
     * 
     */
    delete<T extends compania_representantesDeleteArgs>(args: SelectSubset<T, compania_representantesDeleteArgs<ExtArgs>>): Prisma__compania_representantesClient<$Result.GetResult<Prisma.$compania_representantesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Compania_representantes.
     * @param {compania_representantesUpdateArgs} args - Arguments to update one Compania_representantes.
     * @example
     * // Update one Compania_representantes
     * const compania_representantes = await prisma.compania_representantes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends compania_representantesUpdateArgs>(args: SelectSubset<T, compania_representantesUpdateArgs<ExtArgs>>): Prisma__compania_representantesClient<$Result.GetResult<Prisma.$compania_representantesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Compania_representantes.
     * @param {compania_representantesDeleteManyArgs} args - Arguments to filter Compania_representantes to delete.
     * @example
     * // Delete a few Compania_representantes
     * const { count } = await prisma.compania_representantes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends compania_representantesDeleteManyArgs>(args?: SelectSubset<T, compania_representantesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Compania_representantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compania_representantesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Compania_representantes
     * const compania_representantes = await prisma.compania_representantes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends compania_representantesUpdateManyArgs>(args: SelectSubset<T, compania_representantesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Compania_representantes.
     * @param {compania_representantesUpsertArgs} args - Arguments to update or create a Compania_representantes.
     * @example
     * // Update or create a Compania_representantes
     * const compania_representantes = await prisma.compania_representantes.upsert({
     *   create: {
     *     // ... data to create a Compania_representantes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compania_representantes we want to update
     *   }
     * })
     */
    upsert<T extends compania_representantesUpsertArgs>(args: SelectSubset<T, compania_representantesUpsertArgs<ExtArgs>>): Prisma__compania_representantesClient<$Result.GetResult<Prisma.$compania_representantesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Compania_representantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compania_representantesCountArgs} args - Arguments to filter Compania_representantes to count.
     * @example
     * // Count the number of Compania_representantes
     * const count = await prisma.compania_representantes.count({
     *   where: {
     *     // ... the filter for the Compania_representantes we want to count
     *   }
     * })
    **/
    count<T extends compania_representantesCountArgs>(
      args?: Subset<T, compania_representantesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Compania_representantesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compania_representantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Compania_representantesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Compania_representantesAggregateArgs>(args: Subset<T, Compania_representantesAggregateArgs>): Prisma.PrismaPromise<GetCompania_representantesAggregateType<T>>

    /**
     * Group by Compania_representantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compania_representantesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends compania_representantesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: compania_representantesGroupByArgs['orderBy'] }
        : { orderBy?: compania_representantesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, compania_representantesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompania_representantesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the compania_representantes model
   */
  readonly fields: compania_representantesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for compania_representantes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__compania_representantesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    compania<T extends companiaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiaDefaultArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the compania_representantes model
   */
  interface compania_representantesFieldRefs {
    readonly id: FieldRef<"compania_representantes", 'BigInt'>
    readonly compania_id: FieldRef<"compania_representantes", 'BigInt'>
    readonly nombre: FieldRef<"compania_representantes", 'String'>
    readonly telefono: FieldRef<"compania_representantes", 'String'>
    readonly correo: FieldRef<"compania_representantes", 'String'>
    readonly cargo: FieldRef<"compania_representantes", 'String'>
    readonly estatus: FieldRef<"compania_representantes", 'Boolean'>
    readonly created_at: FieldRef<"compania_representantes", 'DateTime'>
    readonly updated_at: FieldRef<"compania_representantes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * compania_representantes findUnique
   */
  export type compania_representantesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
    /**
     * Filter, which compania_representantes to fetch.
     */
    where: compania_representantesWhereUniqueInput
  }

  /**
   * compania_representantes findUniqueOrThrow
   */
  export type compania_representantesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
    /**
     * Filter, which compania_representantes to fetch.
     */
    where: compania_representantesWhereUniqueInput
  }

  /**
   * compania_representantes findFirst
   */
  export type compania_representantesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
    /**
     * Filter, which compania_representantes to fetch.
     */
    where?: compania_representantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compania_representantes to fetch.
     */
    orderBy?: compania_representantesOrderByWithRelationInput | compania_representantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for compania_representantes.
     */
    cursor?: compania_representantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compania_representantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compania_representantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of compania_representantes.
     */
    distinct?: Compania_representantesScalarFieldEnum | Compania_representantesScalarFieldEnum[]
  }

  /**
   * compania_representantes findFirstOrThrow
   */
  export type compania_representantesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
    /**
     * Filter, which compania_representantes to fetch.
     */
    where?: compania_representantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compania_representantes to fetch.
     */
    orderBy?: compania_representantesOrderByWithRelationInput | compania_representantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for compania_representantes.
     */
    cursor?: compania_representantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compania_representantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compania_representantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of compania_representantes.
     */
    distinct?: Compania_representantesScalarFieldEnum | Compania_representantesScalarFieldEnum[]
  }

  /**
   * compania_representantes findMany
   */
  export type compania_representantesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
    /**
     * Filter, which compania_representantes to fetch.
     */
    where?: compania_representantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compania_representantes to fetch.
     */
    orderBy?: compania_representantesOrderByWithRelationInput | compania_representantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing compania_representantes.
     */
    cursor?: compania_representantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compania_representantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compania_representantes.
     */
    skip?: number
    distinct?: Compania_representantesScalarFieldEnum | Compania_representantesScalarFieldEnum[]
  }

  /**
   * compania_representantes create
   */
  export type compania_representantesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
    /**
     * The data needed to create a compania_representantes.
     */
    data: XOR<compania_representantesCreateInput, compania_representantesUncheckedCreateInput>
  }

  /**
   * compania_representantes createMany
   */
  export type compania_representantesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many compania_representantes.
     */
    data: compania_representantesCreateManyInput | compania_representantesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * compania_representantes update
   */
  export type compania_representantesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
    /**
     * The data needed to update a compania_representantes.
     */
    data: XOR<compania_representantesUpdateInput, compania_representantesUncheckedUpdateInput>
    /**
     * Choose, which compania_representantes to update.
     */
    where: compania_representantesWhereUniqueInput
  }

  /**
   * compania_representantes updateMany
   */
  export type compania_representantesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update compania_representantes.
     */
    data: XOR<compania_representantesUpdateManyMutationInput, compania_representantesUncheckedUpdateManyInput>
    /**
     * Filter which compania_representantes to update
     */
    where?: compania_representantesWhereInput
    /**
     * Limit how many compania_representantes to update.
     */
    limit?: number
  }

  /**
   * compania_representantes upsert
   */
  export type compania_representantesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
    /**
     * The filter to search for the compania_representantes to update in case it exists.
     */
    where: compania_representantesWhereUniqueInput
    /**
     * In case the compania_representantes found by the `where` argument doesn't exist, create a new compania_representantes with this data.
     */
    create: XOR<compania_representantesCreateInput, compania_representantesUncheckedCreateInput>
    /**
     * In case the compania_representantes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<compania_representantesUpdateInput, compania_representantesUncheckedUpdateInput>
  }

  /**
   * compania_representantes delete
   */
  export type compania_representantesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
    /**
     * Filter which compania_representantes to delete.
     */
    where: compania_representantesWhereUniqueInput
  }

  /**
   * compania_representantes deleteMany
   */
  export type compania_representantesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compania_representantes to delete
     */
    where?: compania_representantesWhereInput
    /**
     * Limit how many compania_representantes to delete.
     */
    limit?: number
  }

  /**
   * compania_representantes without action
   */
  export type compania_representantesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compania_representantes
     */
    select?: compania_representantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compania_representantes
     */
    omit?: compania_representantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: compania_representantesInclude<ExtArgs> | null
  }


  /**
   * Model companias_productos
   */

  export type AggregateCompanias_productos = {
    _count: Companias_productosCountAggregateOutputType | null
    _avg: Companias_productosAvgAggregateOutputType | null
    _sum: Companias_productosSumAggregateOutputType | null
    _min: Companias_productosMinAggregateOutputType | null
    _max: Companias_productosMaxAggregateOutputType | null
  }

  export type Companias_productosAvgAggregateOutputType = {
    id: number | null
    compania_id: number | null
    ramo_id: number | null
  }

  export type Companias_productosSumAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    ramo_id: bigint | null
  }

  export type Companias_productosMinAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    ramo_id: bigint | null
    nombre: string | null
    created_at: Date | null
    updated_at: Date | null
    estatus: boolean | null
  }

  export type Companias_productosMaxAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    ramo_id: bigint | null
    nombre: string | null
    created_at: Date | null
    updated_at: Date | null
    estatus: boolean | null
  }

  export type Companias_productosCountAggregateOutputType = {
    id: number
    compania_id: number
    ramo_id: number
    nombre: number
    created_at: number
    updated_at: number
    estatus: number
    _all: number
  }


  export type Companias_productosAvgAggregateInputType = {
    id?: true
    compania_id?: true
    ramo_id?: true
  }

  export type Companias_productosSumAggregateInputType = {
    id?: true
    compania_id?: true
    ramo_id?: true
  }

  export type Companias_productosMinAggregateInputType = {
    id?: true
    compania_id?: true
    ramo_id?: true
    nombre?: true
    created_at?: true
    updated_at?: true
    estatus?: true
  }

  export type Companias_productosMaxAggregateInputType = {
    id?: true
    compania_id?: true
    ramo_id?: true
    nombre?: true
    created_at?: true
    updated_at?: true
    estatus?: true
  }

  export type Companias_productosCountAggregateInputType = {
    id?: true
    compania_id?: true
    ramo_id?: true
    nombre?: true
    created_at?: true
    updated_at?: true
    estatus?: true
    _all?: true
  }

  export type Companias_productosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companias_productos to aggregate.
     */
    where?: companias_productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias_productos to fetch.
     */
    orderBy?: companias_productosOrderByWithRelationInput | companias_productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companias_productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias_productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias_productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companias_productos
    **/
    _count?: true | Companias_productosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Companias_productosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Companias_productosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Companias_productosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Companias_productosMaxAggregateInputType
  }

  export type GetCompanias_productosAggregateType<T extends Companias_productosAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanias_productos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanias_productos[P]>
      : GetScalarType<T[P], AggregateCompanias_productos[P]>
  }




  export type companias_productosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companias_productosWhereInput
    orderBy?: companias_productosOrderByWithAggregationInput | companias_productosOrderByWithAggregationInput[]
    by: Companias_productosScalarFieldEnum[] | Companias_productosScalarFieldEnum
    having?: companias_productosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Companias_productosCountAggregateInputType | true
    _avg?: Companias_productosAvgAggregateInputType
    _sum?: Companias_productosSumAggregateInputType
    _min?: Companias_productosMinAggregateInputType
    _max?: Companias_productosMaxAggregateInputType
  }

  export type Companias_productosGroupByOutputType = {
    id: bigint
    compania_id: bigint
    ramo_id: bigint
    nombre: string
    created_at: Date | null
    updated_at: Date | null
    estatus: boolean | null
    _count: Companias_productosCountAggregateOutputType | null
    _avg: Companias_productosAvgAggregateOutputType | null
    _sum: Companias_productosSumAggregateOutputType | null
    _min: Companias_productosMinAggregateOutputType | null
    _max: Companias_productosMaxAggregateOutputType | null
  }

  type GetCompanias_productosGroupByPayload<T extends companias_productosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Companias_productosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Companias_productosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Companias_productosGroupByOutputType[P]>
            : GetScalarType<T[P], Companias_productosGroupByOutputType[P]>
        }
      >
    >


  export type companias_productosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    compania_id?: boolean
    ramo_id?: boolean
    nombre?: boolean
    created_at?: boolean
    updated_at?: boolean
    estatus?: boolean
    compania?: boolean | companiaDefaultArgs<ExtArgs>
    ramos?: boolean | ramosDefaultArgs<ExtArgs>
    polizas?: boolean | companias_productos$polizasArgs<ExtArgs>
    _count?: boolean | Companias_productosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companias_productos"]>



  export type companias_productosSelectScalar = {
    id?: boolean
    compania_id?: boolean
    ramo_id?: boolean
    nombre?: boolean
    created_at?: boolean
    updated_at?: boolean
    estatus?: boolean
  }

  export type companias_productosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "compania_id" | "ramo_id" | "nombre" | "created_at" | "updated_at" | "estatus", ExtArgs["result"]["companias_productos"]>
  export type companias_productosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compania?: boolean | companiaDefaultArgs<ExtArgs>
    ramos?: boolean | ramosDefaultArgs<ExtArgs>
    polizas?: boolean | companias_productos$polizasArgs<ExtArgs>
    _count?: boolean | Companias_productosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $companias_productosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companias_productos"
    objects: {
      compania: Prisma.$companiaPayload<ExtArgs>
      ramos: Prisma.$ramosPayload<ExtArgs>
      polizas: Prisma.$polizasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      compania_id: bigint
      ramo_id: bigint
      nombre: string
      created_at: Date | null
      updated_at: Date | null
      estatus: boolean | null
    }, ExtArgs["result"]["companias_productos"]>
    composites: {}
  }

  type companias_productosGetPayload<S extends boolean | null | undefined | companias_productosDefaultArgs> = $Result.GetResult<Prisma.$companias_productosPayload, S>

  type companias_productosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companias_productosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Companias_productosCountAggregateInputType | true
    }

  export interface companias_productosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companias_productos'], meta: { name: 'companias_productos' } }
    /**
     * Find zero or one Companias_productos that matches the filter.
     * @param {companias_productosFindUniqueArgs} args - Arguments to find a Companias_productos
     * @example
     * // Get one Companias_productos
     * const companias_productos = await prisma.companias_productos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companias_productosFindUniqueArgs>(args: SelectSubset<T, companias_productosFindUniqueArgs<ExtArgs>>): Prisma__companias_productosClient<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companias_productos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companias_productosFindUniqueOrThrowArgs} args - Arguments to find a Companias_productos
     * @example
     * // Get one Companias_productos
     * const companias_productos = await prisma.companias_productos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companias_productosFindUniqueOrThrowArgs>(args: SelectSubset<T, companias_productosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companias_productosClient<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companias_productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_productosFindFirstArgs} args - Arguments to find a Companias_productos
     * @example
     * // Get one Companias_productos
     * const companias_productos = await prisma.companias_productos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companias_productosFindFirstArgs>(args?: SelectSubset<T, companias_productosFindFirstArgs<ExtArgs>>): Prisma__companias_productosClient<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companias_productos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_productosFindFirstOrThrowArgs} args - Arguments to find a Companias_productos
     * @example
     * // Get one Companias_productos
     * const companias_productos = await prisma.companias_productos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companias_productosFindFirstOrThrowArgs>(args?: SelectSubset<T, companias_productosFindFirstOrThrowArgs<ExtArgs>>): Prisma__companias_productosClient<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companias_productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_productosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companias_productos
     * const companias_productos = await prisma.companias_productos.findMany()
     * 
     * // Get first 10 Companias_productos
     * const companias_productos = await prisma.companias_productos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companias_productosWithIdOnly = await prisma.companias_productos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companias_productosFindManyArgs>(args?: SelectSubset<T, companias_productosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companias_productos.
     * @param {companias_productosCreateArgs} args - Arguments to create a Companias_productos.
     * @example
     * // Create one Companias_productos
     * const Companias_productos = await prisma.companias_productos.create({
     *   data: {
     *     // ... data to create a Companias_productos
     *   }
     * })
     * 
     */
    create<T extends companias_productosCreateArgs>(args: SelectSubset<T, companias_productosCreateArgs<ExtArgs>>): Prisma__companias_productosClient<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companias_productos.
     * @param {companias_productosCreateManyArgs} args - Arguments to create many Companias_productos.
     * @example
     * // Create many Companias_productos
     * const companias_productos = await prisma.companias_productos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companias_productosCreateManyArgs>(args?: SelectSubset<T, companias_productosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Companias_productos.
     * @param {companias_productosDeleteArgs} args - Arguments to delete one Companias_productos.
     * @example
     * // Delete one Companias_productos
     * const Companias_productos = await prisma.companias_productos.delete({
     *   where: {
     *     // ... filter to delete one Companias_productos
     *   }
     * })
     * 
     */
    delete<T extends companias_productosDeleteArgs>(args: SelectSubset<T, companias_productosDeleteArgs<ExtArgs>>): Prisma__companias_productosClient<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companias_productos.
     * @param {companias_productosUpdateArgs} args - Arguments to update one Companias_productos.
     * @example
     * // Update one Companias_productos
     * const companias_productos = await prisma.companias_productos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companias_productosUpdateArgs>(args: SelectSubset<T, companias_productosUpdateArgs<ExtArgs>>): Prisma__companias_productosClient<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companias_productos.
     * @param {companias_productosDeleteManyArgs} args - Arguments to filter Companias_productos to delete.
     * @example
     * // Delete a few Companias_productos
     * const { count } = await prisma.companias_productos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companias_productosDeleteManyArgs>(args?: SelectSubset<T, companias_productosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companias_productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_productosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companias_productos
     * const companias_productos = await prisma.companias_productos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companias_productosUpdateManyArgs>(args: SelectSubset<T, companias_productosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Companias_productos.
     * @param {companias_productosUpsertArgs} args - Arguments to update or create a Companias_productos.
     * @example
     * // Update or create a Companias_productos
     * const companias_productos = await prisma.companias_productos.upsert({
     *   create: {
     *     // ... data to create a Companias_productos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companias_productos we want to update
     *   }
     * })
     */
    upsert<T extends companias_productosUpsertArgs>(args: SelectSubset<T, companias_productosUpsertArgs<ExtArgs>>): Prisma__companias_productosClient<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companias_productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_productosCountArgs} args - Arguments to filter Companias_productos to count.
     * @example
     * // Count the number of Companias_productos
     * const count = await prisma.companias_productos.count({
     *   where: {
     *     // ... the filter for the Companias_productos we want to count
     *   }
     * })
    **/
    count<T extends companias_productosCountArgs>(
      args?: Subset<T, companias_productosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Companias_productosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companias_productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companias_productosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Companias_productosAggregateArgs>(args: Subset<T, Companias_productosAggregateArgs>): Prisma.PrismaPromise<GetCompanias_productosAggregateType<T>>

    /**
     * Group by Companias_productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_productosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companias_productosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companias_productosGroupByArgs['orderBy'] }
        : { orderBy?: companias_productosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companias_productosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanias_productosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companias_productos model
   */
  readonly fields: companias_productosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companias_productos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companias_productosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    compania<T extends companiaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiaDefaultArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ramos<T extends ramosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ramosDefaultArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    polizas<T extends companias_productos$polizasArgs<ExtArgs> = {}>(args?: Subset<T, companias_productos$polizasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companias_productos model
   */
  interface companias_productosFieldRefs {
    readonly id: FieldRef<"companias_productos", 'BigInt'>
    readonly compania_id: FieldRef<"companias_productos", 'BigInt'>
    readonly ramo_id: FieldRef<"companias_productos", 'BigInt'>
    readonly nombre: FieldRef<"companias_productos", 'String'>
    readonly created_at: FieldRef<"companias_productos", 'DateTime'>
    readonly updated_at: FieldRef<"companias_productos", 'DateTime'>
    readonly estatus: FieldRef<"companias_productos", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * companias_productos findUnique
   */
  export type companias_productosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    /**
     * Filter, which companias_productos to fetch.
     */
    where: companias_productosWhereUniqueInput
  }

  /**
   * companias_productos findUniqueOrThrow
   */
  export type companias_productosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    /**
     * Filter, which companias_productos to fetch.
     */
    where: companias_productosWhereUniqueInput
  }

  /**
   * companias_productos findFirst
   */
  export type companias_productosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    /**
     * Filter, which companias_productos to fetch.
     */
    where?: companias_productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias_productos to fetch.
     */
    orderBy?: companias_productosOrderByWithRelationInput | companias_productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companias_productos.
     */
    cursor?: companias_productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias_productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias_productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companias_productos.
     */
    distinct?: Companias_productosScalarFieldEnum | Companias_productosScalarFieldEnum[]
  }

  /**
   * companias_productos findFirstOrThrow
   */
  export type companias_productosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    /**
     * Filter, which companias_productos to fetch.
     */
    where?: companias_productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias_productos to fetch.
     */
    orderBy?: companias_productosOrderByWithRelationInput | companias_productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companias_productos.
     */
    cursor?: companias_productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias_productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias_productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companias_productos.
     */
    distinct?: Companias_productosScalarFieldEnum | Companias_productosScalarFieldEnum[]
  }

  /**
   * companias_productos findMany
   */
  export type companias_productosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    /**
     * Filter, which companias_productos to fetch.
     */
    where?: companias_productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias_productos to fetch.
     */
    orderBy?: companias_productosOrderByWithRelationInput | companias_productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companias_productos.
     */
    cursor?: companias_productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias_productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias_productos.
     */
    skip?: number
    distinct?: Companias_productosScalarFieldEnum | Companias_productosScalarFieldEnum[]
  }

  /**
   * companias_productos create
   */
  export type companias_productosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    /**
     * The data needed to create a companias_productos.
     */
    data: XOR<companias_productosCreateInput, companias_productosUncheckedCreateInput>
  }

  /**
   * companias_productos createMany
   */
  export type companias_productosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companias_productos.
     */
    data: companias_productosCreateManyInput | companias_productosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companias_productos update
   */
  export type companias_productosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    /**
     * The data needed to update a companias_productos.
     */
    data: XOR<companias_productosUpdateInput, companias_productosUncheckedUpdateInput>
    /**
     * Choose, which companias_productos to update.
     */
    where: companias_productosWhereUniqueInput
  }

  /**
   * companias_productos updateMany
   */
  export type companias_productosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companias_productos.
     */
    data: XOR<companias_productosUpdateManyMutationInput, companias_productosUncheckedUpdateManyInput>
    /**
     * Filter which companias_productos to update
     */
    where?: companias_productosWhereInput
    /**
     * Limit how many companias_productos to update.
     */
    limit?: number
  }

  /**
   * companias_productos upsert
   */
  export type companias_productosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    /**
     * The filter to search for the companias_productos to update in case it exists.
     */
    where: companias_productosWhereUniqueInput
    /**
     * In case the companias_productos found by the `where` argument doesn't exist, create a new companias_productos with this data.
     */
    create: XOR<companias_productosCreateInput, companias_productosUncheckedCreateInput>
    /**
     * In case the companias_productos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companias_productosUpdateInput, companias_productosUncheckedUpdateInput>
  }

  /**
   * companias_productos delete
   */
  export type companias_productosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    /**
     * Filter which companias_productos to delete.
     */
    where: companias_productosWhereUniqueInput
  }

  /**
   * companias_productos deleteMany
   */
  export type companias_productosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companias_productos to delete
     */
    where?: companias_productosWhereInput
    /**
     * Limit how many companias_productos to delete.
     */
    limit?: number
  }

  /**
   * companias_productos.polizas
   */
  export type companias_productos$polizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    where?: polizasWhereInput
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    cursor?: polizasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * companias_productos without action
   */
  export type companias_productosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
  }


  /**
   * Model companias_ramos
   */

  export type AggregateCompanias_ramos = {
    _count: Companias_ramosCountAggregateOutputType | null
    _avg: Companias_ramosAvgAggregateOutputType | null
    _sum: Companias_ramosSumAggregateOutputType | null
    _min: Companias_ramosMinAggregateOutputType | null
    _max: Companias_ramosMaxAggregateOutputType | null
  }

  export type Companias_ramosAvgAggregateOutputType = {
    id: number | null
    compania_id: number | null
    ramo_id: number | null
  }

  export type Companias_ramosSumAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    ramo_id: bigint | null
  }

  export type Companias_ramosMinAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    ramo_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
    estatus: boolean | null
  }

  export type Companias_ramosMaxAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    ramo_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
    estatus: boolean | null
  }

  export type Companias_ramosCountAggregateOutputType = {
    id: number
    compania_id: number
    ramo_id: number
    created_at: number
    updated_at: number
    estatus: number
    _all: number
  }


  export type Companias_ramosAvgAggregateInputType = {
    id?: true
    compania_id?: true
    ramo_id?: true
  }

  export type Companias_ramosSumAggregateInputType = {
    id?: true
    compania_id?: true
    ramo_id?: true
  }

  export type Companias_ramosMinAggregateInputType = {
    id?: true
    compania_id?: true
    ramo_id?: true
    created_at?: true
    updated_at?: true
    estatus?: true
  }

  export type Companias_ramosMaxAggregateInputType = {
    id?: true
    compania_id?: true
    ramo_id?: true
    created_at?: true
    updated_at?: true
    estatus?: true
  }

  export type Companias_ramosCountAggregateInputType = {
    id?: true
    compania_id?: true
    ramo_id?: true
    created_at?: true
    updated_at?: true
    estatus?: true
    _all?: true
  }

  export type Companias_ramosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companias_ramos to aggregate.
     */
    where?: companias_ramosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias_ramos to fetch.
     */
    orderBy?: companias_ramosOrderByWithRelationInput | companias_ramosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companias_ramosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias_ramos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias_ramos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companias_ramos
    **/
    _count?: true | Companias_ramosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Companias_ramosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Companias_ramosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Companias_ramosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Companias_ramosMaxAggregateInputType
  }

  export type GetCompanias_ramosAggregateType<T extends Companias_ramosAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanias_ramos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanias_ramos[P]>
      : GetScalarType<T[P], AggregateCompanias_ramos[P]>
  }




  export type companias_ramosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companias_ramosWhereInput
    orderBy?: companias_ramosOrderByWithAggregationInput | companias_ramosOrderByWithAggregationInput[]
    by: Companias_ramosScalarFieldEnum[] | Companias_ramosScalarFieldEnum
    having?: companias_ramosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Companias_ramosCountAggregateInputType | true
    _avg?: Companias_ramosAvgAggregateInputType
    _sum?: Companias_ramosSumAggregateInputType
    _min?: Companias_ramosMinAggregateInputType
    _max?: Companias_ramosMaxAggregateInputType
  }

  export type Companias_ramosGroupByOutputType = {
    id: bigint
    compania_id: bigint
    ramo_id: bigint
    created_at: Date | null
    updated_at: Date | null
    estatus: boolean | null
    _count: Companias_ramosCountAggregateOutputType | null
    _avg: Companias_ramosAvgAggregateOutputType | null
    _sum: Companias_ramosSumAggregateOutputType | null
    _min: Companias_ramosMinAggregateOutputType | null
    _max: Companias_ramosMaxAggregateOutputType | null
  }

  type GetCompanias_ramosGroupByPayload<T extends companias_ramosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Companias_ramosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Companias_ramosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Companias_ramosGroupByOutputType[P]>
            : GetScalarType<T[P], Companias_ramosGroupByOutputType[P]>
        }
      >
    >


  export type companias_ramosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    compania_id?: boolean
    ramo_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    estatus?: boolean
    compania?: boolean | companiaDefaultArgs<ExtArgs>
    ramos?: boolean | ramosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companias_ramos"]>



  export type companias_ramosSelectScalar = {
    id?: boolean
    compania_id?: boolean
    ramo_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    estatus?: boolean
  }

  export type companias_ramosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "compania_id" | "ramo_id" | "created_at" | "updated_at" | "estatus", ExtArgs["result"]["companias_ramos"]>
  export type companias_ramosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compania?: boolean | companiaDefaultArgs<ExtArgs>
    ramos?: boolean | ramosDefaultArgs<ExtArgs>
  }

  export type $companias_ramosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companias_ramos"
    objects: {
      compania: Prisma.$companiaPayload<ExtArgs>
      ramos: Prisma.$ramosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      compania_id: bigint
      ramo_id: bigint
      created_at: Date | null
      updated_at: Date | null
      estatus: boolean | null
    }, ExtArgs["result"]["companias_ramos"]>
    composites: {}
  }

  type companias_ramosGetPayload<S extends boolean | null | undefined | companias_ramosDefaultArgs> = $Result.GetResult<Prisma.$companias_ramosPayload, S>

  type companias_ramosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companias_ramosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Companias_ramosCountAggregateInputType | true
    }

  export interface companias_ramosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companias_ramos'], meta: { name: 'companias_ramos' } }
    /**
     * Find zero or one Companias_ramos that matches the filter.
     * @param {companias_ramosFindUniqueArgs} args - Arguments to find a Companias_ramos
     * @example
     * // Get one Companias_ramos
     * const companias_ramos = await prisma.companias_ramos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companias_ramosFindUniqueArgs>(args: SelectSubset<T, companias_ramosFindUniqueArgs<ExtArgs>>): Prisma__companias_ramosClient<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companias_ramos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companias_ramosFindUniqueOrThrowArgs} args - Arguments to find a Companias_ramos
     * @example
     * // Get one Companias_ramos
     * const companias_ramos = await prisma.companias_ramos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companias_ramosFindUniqueOrThrowArgs>(args: SelectSubset<T, companias_ramosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companias_ramosClient<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companias_ramos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_ramosFindFirstArgs} args - Arguments to find a Companias_ramos
     * @example
     * // Get one Companias_ramos
     * const companias_ramos = await prisma.companias_ramos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companias_ramosFindFirstArgs>(args?: SelectSubset<T, companias_ramosFindFirstArgs<ExtArgs>>): Prisma__companias_ramosClient<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companias_ramos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_ramosFindFirstOrThrowArgs} args - Arguments to find a Companias_ramos
     * @example
     * // Get one Companias_ramos
     * const companias_ramos = await prisma.companias_ramos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companias_ramosFindFirstOrThrowArgs>(args?: SelectSubset<T, companias_ramosFindFirstOrThrowArgs<ExtArgs>>): Prisma__companias_ramosClient<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companias_ramos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_ramosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companias_ramos
     * const companias_ramos = await prisma.companias_ramos.findMany()
     * 
     * // Get first 10 Companias_ramos
     * const companias_ramos = await prisma.companias_ramos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companias_ramosWithIdOnly = await prisma.companias_ramos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companias_ramosFindManyArgs>(args?: SelectSubset<T, companias_ramosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companias_ramos.
     * @param {companias_ramosCreateArgs} args - Arguments to create a Companias_ramos.
     * @example
     * // Create one Companias_ramos
     * const Companias_ramos = await prisma.companias_ramos.create({
     *   data: {
     *     // ... data to create a Companias_ramos
     *   }
     * })
     * 
     */
    create<T extends companias_ramosCreateArgs>(args: SelectSubset<T, companias_ramosCreateArgs<ExtArgs>>): Prisma__companias_ramosClient<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companias_ramos.
     * @param {companias_ramosCreateManyArgs} args - Arguments to create many Companias_ramos.
     * @example
     * // Create many Companias_ramos
     * const companias_ramos = await prisma.companias_ramos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companias_ramosCreateManyArgs>(args?: SelectSubset<T, companias_ramosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Companias_ramos.
     * @param {companias_ramosDeleteArgs} args - Arguments to delete one Companias_ramos.
     * @example
     * // Delete one Companias_ramos
     * const Companias_ramos = await prisma.companias_ramos.delete({
     *   where: {
     *     // ... filter to delete one Companias_ramos
     *   }
     * })
     * 
     */
    delete<T extends companias_ramosDeleteArgs>(args: SelectSubset<T, companias_ramosDeleteArgs<ExtArgs>>): Prisma__companias_ramosClient<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companias_ramos.
     * @param {companias_ramosUpdateArgs} args - Arguments to update one Companias_ramos.
     * @example
     * // Update one Companias_ramos
     * const companias_ramos = await prisma.companias_ramos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companias_ramosUpdateArgs>(args: SelectSubset<T, companias_ramosUpdateArgs<ExtArgs>>): Prisma__companias_ramosClient<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companias_ramos.
     * @param {companias_ramosDeleteManyArgs} args - Arguments to filter Companias_ramos to delete.
     * @example
     * // Delete a few Companias_ramos
     * const { count } = await prisma.companias_ramos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companias_ramosDeleteManyArgs>(args?: SelectSubset<T, companias_ramosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companias_ramos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_ramosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companias_ramos
     * const companias_ramos = await prisma.companias_ramos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companias_ramosUpdateManyArgs>(args: SelectSubset<T, companias_ramosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Companias_ramos.
     * @param {companias_ramosUpsertArgs} args - Arguments to update or create a Companias_ramos.
     * @example
     * // Update or create a Companias_ramos
     * const companias_ramos = await prisma.companias_ramos.upsert({
     *   create: {
     *     // ... data to create a Companias_ramos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companias_ramos we want to update
     *   }
     * })
     */
    upsert<T extends companias_ramosUpsertArgs>(args: SelectSubset<T, companias_ramosUpsertArgs<ExtArgs>>): Prisma__companias_ramosClient<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companias_ramos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_ramosCountArgs} args - Arguments to filter Companias_ramos to count.
     * @example
     * // Count the number of Companias_ramos
     * const count = await prisma.companias_ramos.count({
     *   where: {
     *     // ... the filter for the Companias_ramos we want to count
     *   }
     * })
    **/
    count<T extends companias_ramosCountArgs>(
      args?: Subset<T, companias_ramosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Companias_ramosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companias_ramos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companias_ramosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Companias_ramosAggregateArgs>(args: Subset<T, Companias_ramosAggregateArgs>): Prisma.PrismaPromise<GetCompanias_ramosAggregateType<T>>

    /**
     * Group by Companias_ramos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companias_ramosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companias_ramosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companias_ramosGroupByArgs['orderBy'] }
        : { orderBy?: companias_ramosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companias_ramosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanias_ramosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companias_ramos model
   */
  readonly fields: companias_ramosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companias_ramos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companias_ramosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    compania<T extends companiaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiaDefaultArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ramos<T extends ramosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ramosDefaultArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companias_ramos model
   */
  interface companias_ramosFieldRefs {
    readonly id: FieldRef<"companias_ramos", 'BigInt'>
    readonly compania_id: FieldRef<"companias_ramos", 'BigInt'>
    readonly ramo_id: FieldRef<"companias_ramos", 'BigInt'>
    readonly created_at: FieldRef<"companias_ramos", 'DateTime'>
    readonly updated_at: FieldRef<"companias_ramos", 'DateTime'>
    readonly estatus: FieldRef<"companias_ramos", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * companias_ramos findUnique
   */
  export type companias_ramosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    /**
     * Filter, which companias_ramos to fetch.
     */
    where: companias_ramosWhereUniqueInput
  }

  /**
   * companias_ramos findUniqueOrThrow
   */
  export type companias_ramosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    /**
     * Filter, which companias_ramos to fetch.
     */
    where: companias_ramosWhereUniqueInput
  }

  /**
   * companias_ramos findFirst
   */
  export type companias_ramosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    /**
     * Filter, which companias_ramos to fetch.
     */
    where?: companias_ramosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias_ramos to fetch.
     */
    orderBy?: companias_ramosOrderByWithRelationInput | companias_ramosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companias_ramos.
     */
    cursor?: companias_ramosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias_ramos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias_ramos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companias_ramos.
     */
    distinct?: Companias_ramosScalarFieldEnum | Companias_ramosScalarFieldEnum[]
  }

  /**
   * companias_ramos findFirstOrThrow
   */
  export type companias_ramosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    /**
     * Filter, which companias_ramos to fetch.
     */
    where?: companias_ramosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias_ramos to fetch.
     */
    orderBy?: companias_ramosOrderByWithRelationInput | companias_ramosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companias_ramos.
     */
    cursor?: companias_ramosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias_ramos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias_ramos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companias_ramos.
     */
    distinct?: Companias_ramosScalarFieldEnum | Companias_ramosScalarFieldEnum[]
  }

  /**
   * companias_ramos findMany
   */
  export type companias_ramosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    /**
     * Filter, which companias_ramos to fetch.
     */
    where?: companias_ramosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companias_ramos to fetch.
     */
    orderBy?: companias_ramosOrderByWithRelationInput | companias_ramosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companias_ramos.
     */
    cursor?: companias_ramosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companias_ramos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companias_ramos.
     */
    skip?: number
    distinct?: Companias_ramosScalarFieldEnum | Companias_ramosScalarFieldEnum[]
  }

  /**
   * companias_ramos create
   */
  export type companias_ramosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    /**
     * The data needed to create a companias_ramos.
     */
    data: XOR<companias_ramosCreateInput, companias_ramosUncheckedCreateInput>
  }

  /**
   * companias_ramos createMany
   */
  export type companias_ramosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companias_ramos.
     */
    data: companias_ramosCreateManyInput | companias_ramosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companias_ramos update
   */
  export type companias_ramosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    /**
     * The data needed to update a companias_ramos.
     */
    data: XOR<companias_ramosUpdateInput, companias_ramosUncheckedUpdateInput>
    /**
     * Choose, which companias_ramos to update.
     */
    where: companias_ramosWhereUniqueInput
  }

  /**
   * companias_ramos updateMany
   */
  export type companias_ramosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companias_ramos.
     */
    data: XOR<companias_ramosUpdateManyMutationInput, companias_ramosUncheckedUpdateManyInput>
    /**
     * Filter which companias_ramos to update
     */
    where?: companias_ramosWhereInput
    /**
     * Limit how many companias_ramos to update.
     */
    limit?: number
  }

  /**
   * companias_ramos upsert
   */
  export type companias_ramosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    /**
     * The filter to search for the companias_ramos to update in case it exists.
     */
    where: companias_ramosWhereUniqueInput
    /**
     * In case the companias_ramos found by the `where` argument doesn't exist, create a new companias_ramos with this data.
     */
    create: XOR<companias_ramosCreateInput, companias_ramosUncheckedCreateInput>
    /**
     * In case the companias_ramos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companias_ramosUpdateInput, companias_ramosUncheckedUpdateInput>
  }

  /**
   * companias_ramos delete
   */
  export type companias_ramosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    /**
     * Filter which companias_ramos to delete.
     */
    where: companias_ramosWhereUniqueInput
  }

  /**
   * companias_ramos deleteMany
   */
  export type companias_ramosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companias_ramos to delete
     */
    where?: companias_ramosWhereInput
    /**
     * Limit how many companias_ramos to delete.
     */
    limit?: number
  }

  /**
   * companias_ramos without action
   */
  export type companias_ramosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
  }


  /**
   * Model estados
   */

  export type AggregateEstados = {
    _count: EstadosCountAggregateOutputType | null
    _avg: EstadosAvgAggregateOutputType | null
    _sum: EstadosSumAggregateOutputType | null
    _min: EstadosMinAggregateOutputType | null
    _max: EstadosMaxAggregateOutputType | null
  }

  export type EstadosAvgAggregateOutputType = {
    id: number | null
  }

  export type EstadosSumAggregateOutputType = {
    id: bigint | null
  }

  export type EstadosMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type EstadosMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type EstadosCountAggregateOutputType = {
    id: number
    label: number
    estatus: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type EstadosAvgAggregateInputType = {
    id?: true
  }

  export type EstadosSumAggregateInputType = {
    id?: true
  }

  export type EstadosMinAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type EstadosMaxAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type EstadosCountAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type EstadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estados to aggregate.
     */
    where?: estadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadosOrderByWithRelationInput | estadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estados
    **/
    _count?: true | EstadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadosMaxAggregateInputType
  }

  export type GetEstadosAggregateType<T extends EstadosAggregateArgs> = {
        [P in keyof T & keyof AggregateEstados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstados[P]>
      : GetScalarType<T[P], AggregateEstados[P]>
  }




  export type estadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estadosWhereInput
    orderBy?: estadosOrderByWithAggregationInput | estadosOrderByWithAggregationInput[]
    by: EstadosScalarFieldEnum[] | EstadosScalarFieldEnum
    having?: estadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadosCountAggregateInputType | true
    _avg?: EstadosAvgAggregateInputType
    _sum?: EstadosSumAggregateInputType
    _min?: EstadosMinAggregateInputType
    _max?: EstadosMaxAggregateInputType
  }

  export type EstadosGroupByOutputType = {
    id: bigint
    label: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: EstadosCountAggregateOutputType | null
    _avg: EstadosAvgAggregateOutputType | null
    _sum: EstadosSumAggregateOutputType | null
    _min: EstadosMinAggregateOutputType | null
    _max: EstadosMaxAggregateOutputType | null
  }

  type GetEstadosGroupByPayload<T extends estadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadosGroupByOutputType[P]>
            : GetScalarType<T[P], EstadosGroupByOutputType[P]>
        }
      >
    >


  export type estadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["estados"]>



  export type estadosSelectScalar = {
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type estadosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "estatus" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["estados"]>

  export type $estadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estados"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["estados"]>
    composites: {}
  }

  type estadosGetPayload<S extends boolean | null | undefined | estadosDefaultArgs> = $Result.GetResult<Prisma.$estadosPayload, S>

  type estadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estadosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstadosCountAggregateInputType | true
    }

  export interface estadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estados'], meta: { name: 'estados' } }
    /**
     * Find zero or one Estados that matches the filter.
     * @param {estadosFindUniqueArgs} args - Arguments to find a Estados
     * @example
     * // Get one Estados
     * const estados = await prisma.estados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estadosFindUniqueArgs>(args: SelectSubset<T, estadosFindUniqueArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estados that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estadosFindUniqueOrThrowArgs} args - Arguments to find a Estados
     * @example
     * // Get one Estados
     * const estados = await prisma.estados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estadosFindUniqueOrThrowArgs>(args: SelectSubset<T, estadosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosFindFirstArgs} args - Arguments to find a Estados
     * @example
     * // Get one Estados
     * const estados = await prisma.estados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estadosFindFirstArgs>(args?: SelectSubset<T, estadosFindFirstArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosFindFirstOrThrowArgs} args - Arguments to find a Estados
     * @example
     * // Get one Estados
     * const estados = await prisma.estados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estadosFindFirstOrThrowArgs>(args?: SelectSubset<T, estadosFindFirstOrThrowArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estados
     * const estados = await prisma.estados.findMany()
     * 
     * // Get first 10 Estados
     * const estados = await prisma.estados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estadosWithIdOnly = await prisma.estados.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estadosFindManyArgs>(args?: SelectSubset<T, estadosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estados.
     * @param {estadosCreateArgs} args - Arguments to create a Estados.
     * @example
     * // Create one Estados
     * const Estados = await prisma.estados.create({
     *   data: {
     *     // ... data to create a Estados
     *   }
     * })
     * 
     */
    create<T extends estadosCreateArgs>(args: SelectSubset<T, estadosCreateArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estados.
     * @param {estadosCreateManyArgs} args - Arguments to create many Estados.
     * @example
     * // Create many Estados
     * const estados = await prisma.estados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estadosCreateManyArgs>(args?: SelectSubset<T, estadosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estados.
     * @param {estadosDeleteArgs} args - Arguments to delete one Estados.
     * @example
     * // Delete one Estados
     * const Estados = await prisma.estados.delete({
     *   where: {
     *     // ... filter to delete one Estados
     *   }
     * })
     * 
     */
    delete<T extends estadosDeleteArgs>(args: SelectSubset<T, estadosDeleteArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estados.
     * @param {estadosUpdateArgs} args - Arguments to update one Estados.
     * @example
     * // Update one Estados
     * const estados = await prisma.estados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estadosUpdateArgs>(args: SelectSubset<T, estadosUpdateArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estados.
     * @param {estadosDeleteManyArgs} args - Arguments to filter Estados to delete.
     * @example
     * // Delete a few Estados
     * const { count } = await prisma.estados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estadosDeleteManyArgs>(args?: SelectSubset<T, estadosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estados
     * const estados = await prisma.estados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estadosUpdateManyArgs>(args: SelectSubset<T, estadosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estados.
     * @param {estadosUpsertArgs} args - Arguments to update or create a Estados.
     * @example
     * // Update or create a Estados
     * const estados = await prisma.estados.upsert({
     *   create: {
     *     // ... data to create a Estados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estados we want to update
     *   }
     * })
     */
    upsert<T extends estadosUpsertArgs>(args: SelectSubset<T, estadosUpsertArgs<ExtArgs>>): Prisma__estadosClient<$Result.GetResult<Prisma.$estadosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosCountArgs} args - Arguments to filter Estados to count.
     * @example
     * // Count the number of Estados
     * const count = await prisma.estados.count({
     *   where: {
     *     // ... the filter for the Estados we want to count
     *   }
     * })
    **/
    count<T extends estadosCountArgs>(
      args?: Subset<T, estadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadosAggregateArgs>(args: Subset<T, EstadosAggregateArgs>): Prisma.PrismaPromise<GetEstadosAggregateType<T>>

    /**
     * Group by Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estadosGroupByArgs['orderBy'] }
        : { orderBy?: estadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estados model
   */
  readonly fields: estadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estados model
   */
  interface estadosFieldRefs {
    readonly id: FieldRef<"estados", 'BigInt'>
    readonly label: FieldRef<"estados", 'String'>
    readonly estatus: FieldRef<"estados", 'Boolean'>
    readonly created_at: FieldRef<"estados", 'DateTime'>
    readonly updated_at: FieldRef<"estados", 'DateTime'>
    readonly deleted_at: FieldRef<"estados", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * estados findUnique
   */
  export type estadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estados
     */
    omit?: estadosOmit<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where: estadosWhereUniqueInput
  }

  /**
   * estados findUniqueOrThrow
   */
  export type estadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estados
     */
    omit?: estadosOmit<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where: estadosWhereUniqueInput
  }

  /**
   * estados findFirst
   */
  export type estadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estados
     */
    omit?: estadosOmit<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where?: estadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadosOrderByWithRelationInput | estadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estados.
     */
    cursor?: estadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estados.
     */
    distinct?: EstadosScalarFieldEnum | EstadosScalarFieldEnum[]
  }

  /**
   * estados findFirstOrThrow
   */
  export type estadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estados
     */
    omit?: estadosOmit<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where?: estadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadosOrderByWithRelationInput | estadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estados.
     */
    cursor?: estadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estados.
     */
    distinct?: EstadosScalarFieldEnum | EstadosScalarFieldEnum[]
  }

  /**
   * estados findMany
   */
  export type estadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estados
     */
    omit?: estadosOmit<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where?: estadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadosOrderByWithRelationInput | estadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estados.
     */
    cursor?: estadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    distinct?: EstadosScalarFieldEnum | EstadosScalarFieldEnum[]
  }

  /**
   * estados create
   */
  export type estadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estados
     */
    omit?: estadosOmit<ExtArgs> | null
    /**
     * The data needed to create a estados.
     */
    data: XOR<estadosCreateInput, estadosUncheckedCreateInput>
  }

  /**
   * estados createMany
   */
  export type estadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estados.
     */
    data: estadosCreateManyInput | estadosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estados update
   */
  export type estadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estados
     */
    omit?: estadosOmit<ExtArgs> | null
    /**
     * The data needed to update a estados.
     */
    data: XOR<estadosUpdateInput, estadosUncheckedUpdateInput>
    /**
     * Choose, which estados to update.
     */
    where: estadosWhereUniqueInput
  }

  /**
   * estados updateMany
   */
  export type estadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estados.
     */
    data: XOR<estadosUpdateManyMutationInput, estadosUncheckedUpdateManyInput>
    /**
     * Filter which estados to update
     */
    where?: estadosWhereInput
    /**
     * Limit how many estados to update.
     */
    limit?: number
  }

  /**
   * estados upsert
   */
  export type estadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estados
     */
    omit?: estadosOmit<ExtArgs> | null
    /**
     * The filter to search for the estados to update in case it exists.
     */
    where: estadosWhereUniqueInput
    /**
     * In case the estados found by the `where` argument doesn't exist, create a new estados with this data.
     */
    create: XOR<estadosCreateInput, estadosUncheckedCreateInput>
    /**
     * In case the estados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estadosUpdateInput, estadosUncheckedUpdateInput>
  }

  /**
   * estados delete
   */
  export type estadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estados
     */
    omit?: estadosOmit<ExtArgs> | null
    /**
     * Filter which estados to delete.
     */
    where: estadosWhereUniqueInput
  }

  /**
   * estados deleteMany
   */
  export type estadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estados to delete
     */
    where?: estadosWhereInput
    /**
     * Limit how many estados to delete.
     */
    limit?: number
  }

  /**
   * estados without action
   */
  export type estadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estados
     */
    select?: estadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estados
     */
    omit?: estadosOmit<ExtArgs> | null
  }


  /**
   * Model estatus_cliente
   */

  export type AggregateEstatus_cliente = {
    _count: Estatus_clienteCountAggregateOutputType | null
    _avg: Estatus_clienteAvgAggregateOutputType | null
    _sum: Estatus_clienteSumAggregateOutputType | null
    _min: Estatus_clienteMinAggregateOutputType | null
    _max: Estatus_clienteMaxAggregateOutputType | null
  }

  export type Estatus_clienteAvgAggregateOutputType = {
    id: number | null
  }

  export type Estatus_clienteSumAggregateOutputType = {
    id: bigint | null
  }

  export type Estatus_clienteMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Estatus_clienteMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Estatus_clienteCountAggregateOutputType = {
    id: number
    label: number
    estatus: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Estatus_clienteAvgAggregateInputType = {
    id?: true
  }

  export type Estatus_clienteSumAggregateInputType = {
    id?: true
  }

  export type Estatus_clienteMinAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Estatus_clienteMaxAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Estatus_clienteCountAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Estatus_clienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estatus_cliente to aggregate.
     */
    where?: estatus_clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estatus_clientes to fetch.
     */
    orderBy?: estatus_clienteOrderByWithRelationInput | estatus_clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estatus_clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estatus_clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estatus_clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estatus_clientes
    **/
    _count?: true | Estatus_clienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Estatus_clienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Estatus_clienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Estatus_clienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Estatus_clienteMaxAggregateInputType
  }

  export type GetEstatus_clienteAggregateType<T extends Estatus_clienteAggregateArgs> = {
        [P in keyof T & keyof AggregateEstatus_cliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstatus_cliente[P]>
      : GetScalarType<T[P], AggregateEstatus_cliente[P]>
  }




  export type estatus_clienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estatus_clienteWhereInput
    orderBy?: estatus_clienteOrderByWithAggregationInput | estatus_clienteOrderByWithAggregationInput[]
    by: Estatus_clienteScalarFieldEnum[] | Estatus_clienteScalarFieldEnum
    having?: estatus_clienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Estatus_clienteCountAggregateInputType | true
    _avg?: Estatus_clienteAvgAggregateInputType
    _sum?: Estatus_clienteSumAggregateInputType
    _min?: Estatus_clienteMinAggregateInputType
    _max?: Estatus_clienteMaxAggregateInputType
  }

  export type Estatus_clienteGroupByOutputType = {
    id: bigint
    label: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: Estatus_clienteCountAggregateOutputType | null
    _avg: Estatus_clienteAvgAggregateOutputType | null
    _sum: Estatus_clienteSumAggregateOutputType | null
    _min: Estatus_clienteMinAggregateOutputType | null
    _max: Estatus_clienteMaxAggregateOutputType | null
  }

  type GetEstatus_clienteGroupByPayload<T extends estatus_clienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Estatus_clienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Estatus_clienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Estatus_clienteGroupByOutputType[P]>
            : GetScalarType<T[P], Estatus_clienteGroupByOutputType[P]>
        }
      >
    >


  export type estatus_clienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["estatus_cliente"]>



  export type estatus_clienteSelectScalar = {
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type estatus_clienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "estatus" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["estatus_cliente"]>

  export type $estatus_clientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estatus_cliente"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["estatus_cliente"]>
    composites: {}
  }

  type estatus_clienteGetPayload<S extends boolean | null | undefined | estatus_clienteDefaultArgs> = $Result.GetResult<Prisma.$estatus_clientePayload, S>

  type estatus_clienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estatus_clienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Estatus_clienteCountAggregateInputType | true
    }

  export interface estatus_clienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estatus_cliente'], meta: { name: 'estatus_cliente' } }
    /**
     * Find zero or one Estatus_cliente that matches the filter.
     * @param {estatus_clienteFindUniqueArgs} args - Arguments to find a Estatus_cliente
     * @example
     * // Get one Estatus_cliente
     * const estatus_cliente = await prisma.estatus_cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estatus_clienteFindUniqueArgs>(args: SelectSubset<T, estatus_clienteFindUniqueArgs<ExtArgs>>): Prisma__estatus_clienteClient<$Result.GetResult<Prisma.$estatus_clientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estatus_cliente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estatus_clienteFindUniqueOrThrowArgs} args - Arguments to find a Estatus_cliente
     * @example
     * // Get one Estatus_cliente
     * const estatus_cliente = await prisma.estatus_cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estatus_clienteFindUniqueOrThrowArgs>(args: SelectSubset<T, estatus_clienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estatus_clienteClient<$Result.GetResult<Prisma.$estatus_clientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estatus_cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_clienteFindFirstArgs} args - Arguments to find a Estatus_cliente
     * @example
     * // Get one Estatus_cliente
     * const estatus_cliente = await prisma.estatus_cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estatus_clienteFindFirstArgs>(args?: SelectSubset<T, estatus_clienteFindFirstArgs<ExtArgs>>): Prisma__estatus_clienteClient<$Result.GetResult<Prisma.$estatus_clientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estatus_cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_clienteFindFirstOrThrowArgs} args - Arguments to find a Estatus_cliente
     * @example
     * // Get one Estatus_cliente
     * const estatus_cliente = await prisma.estatus_cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estatus_clienteFindFirstOrThrowArgs>(args?: SelectSubset<T, estatus_clienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__estatus_clienteClient<$Result.GetResult<Prisma.$estatus_clientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estatus_clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_clienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estatus_clientes
     * const estatus_clientes = await prisma.estatus_cliente.findMany()
     * 
     * // Get first 10 Estatus_clientes
     * const estatus_clientes = await prisma.estatus_cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estatus_clienteWithIdOnly = await prisma.estatus_cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estatus_clienteFindManyArgs>(args?: SelectSubset<T, estatus_clienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estatus_clientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estatus_cliente.
     * @param {estatus_clienteCreateArgs} args - Arguments to create a Estatus_cliente.
     * @example
     * // Create one Estatus_cliente
     * const Estatus_cliente = await prisma.estatus_cliente.create({
     *   data: {
     *     // ... data to create a Estatus_cliente
     *   }
     * })
     * 
     */
    create<T extends estatus_clienteCreateArgs>(args: SelectSubset<T, estatus_clienteCreateArgs<ExtArgs>>): Prisma__estatus_clienteClient<$Result.GetResult<Prisma.$estatus_clientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estatus_clientes.
     * @param {estatus_clienteCreateManyArgs} args - Arguments to create many Estatus_clientes.
     * @example
     * // Create many Estatus_clientes
     * const estatus_cliente = await prisma.estatus_cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estatus_clienteCreateManyArgs>(args?: SelectSubset<T, estatus_clienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estatus_cliente.
     * @param {estatus_clienteDeleteArgs} args - Arguments to delete one Estatus_cliente.
     * @example
     * // Delete one Estatus_cliente
     * const Estatus_cliente = await prisma.estatus_cliente.delete({
     *   where: {
     *     // ... filter to delete one Estatus_cliente
     *   }
     * })
     * 
     */
    delete<T extends estatus_clienteDeleteArgs>(args: SelectSubset<T, estatus_clienteDeleteArgs<ExtArgs>>): Prisma__estatus_clienteClient<$Result.GetResult<Prisma.$estatus_clientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estatus_cliente.
     * @param {estatus_clienteUpdateArgs} args - Arguments to update one Estatus_cliente.
     * @example
     * // Update one Estatus_cliente
     * const estatus_cliente = await prisma.estatus_cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estatus_clienteUpdateArgs>(args: SelectSubset<T, estatus_clienteUpdateArgs<ExtArgs>>): Prisma__estatus_clienteClient<$Result.GetResult<Prisma.$estatus_clientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estatus_clientes.
     * @param {estatus_clienteDeleteManyArgs} args - Arguments to filter Estatus_clientes to delete.
     * @example
     * // Delete a few Estatus_clientes
     * const { count } = await prisma.estatus_cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estatus_clienteDeleteManyArgs>(args?: SelectSubset<T, estatus_clienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estatus_clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_clienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estatus_clientes
     * const estatus_cliente = await prisma.estatus_cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estatus_clienteUpdateManyArgs>(args: SelectSubset<T, estatus_clienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estatus_cliente.
     * @param {estatus_clienteUpsertArgs} args - Arguments to update or create a Estatus_cliente.
     * @example
     * // Update or create a Estatus_cliente
     * const estatus_cliente = await prisma.estatus_cliente.upsert({
     *   create: {
     *     // ... data to create a Estatus_cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estatus_cliente we want to update
     *   }
     * })
     */
    upsert<T extends estatus_clienteUpsertArgs>(args: SelectSubset<T, estatus_clienteUpsertArgs<ExtArgs>>): Prisma__estatus_clienteClient<$Result.GetResult<Prisma.$estatus_clientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estatus_clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_clienteCountArgs} args - Arguments to filter Estatus_clientes to count.
     * @example
     * // Count the number of Estatus_clientes
     * const count = await prisma.estatus_cliente.count({
     *   where: {
     *     // ... the filter for the Estatus_clientes we want to count
     *   }
     * })
    **/
    count<T extends estatus_clienteCountArgs>(
      args?: Subset<T, estatus_clienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Estatus_clienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estatus_cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Estatus_clienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Estatus_clienteAggregateArgs>(args: Subset<T, Estatus_clienteAggregateArgs>): Prisma.PrismaPromise<GetEstatus_clienteAggregateType<T>>

    /**
     * Group by Estatus_cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_clienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estatus_clienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estatus_clienteGroupByArgs['orderBy'] }
        : { orderBy?: estatus_clienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estatus_clienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstatus_clienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estatus_cliente model
   */
  readonly fields: estatus_clienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estatus_cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estatus_clienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estatus_cliente model
   */
  interface estatus_clienteFieldRefs {
    readonly id: FieldRef<"estatus_cliente", 'BigInt'>
    readonly label: FieldRef<"estatus_cliente", 'String'>
    readonly estatus: FieldRef<"estatus_cliente", 'Boolean'>
    readonly created_at: FieldRef<"estatus_cliente", 'DateTime'>
    readonly updated_at: FieldRef<"estatus_cliente", 'DateTime'>
    readonly deleted_at: FieldRef<"estatus_cliente", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * estatus_cliente findUnique
   */
  export type estatus_clienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_cliente
     */
    select?: estatus_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_cliente
     */
    omit?: estatus_clienteOmit<ExtArgs> | null
    /**
     * Filter, which estatus_cliente to fetch.
     */
    where: estatus_clienteWhereUniqueInput
  }

  /**
   * estatus_cliente findUniqueOrThrow
   */
  export type estatus_clienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_cliente
     */
    select?: estatus_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_cliente
     */
    omit?: estatus_clienteOmit<ExtArgs> | null
    /**
     * Filter, which estatus_cliente to fetch.
     */
    where: estatus_clienteWhereUniqueInput
  }

  /**
   * estatus_cliente findFirst
   */
  export type estatus_clienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_cliente
     */
    select?: estatus_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_cliente
     */
    omit?: estatus_clienteOmit<ExtArgs> | null
    /**
     * Filter, which estatus_cliente to fetch.
     */
    where?: estatus_clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estatus_clientes to fetch.
     */
    orderBy?: estatus_clienteOrderByWithRelationInput | estatus_clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estatus_clientes.
     */
    cursor?: estatus_clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estatus_clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estatus_clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estatus_clientes.
     */
    distinct?: Estatus_clienteScalarFieldEnum | Estatus_clienteScalarFieldEnum[]
  }

  /**
   * estatus_cliente findFirstOrThrow
   */
  export type estatus_clienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_cliente
     */
    select?: estatus_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_cliente
     */
    omit?: estatus_clienteOmit<ExtArgs> | null
    /**
     * Filter, which estatus_cliente to fetch.
     */
    where?: estatus_clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estatus_clientes to fetch.
     */
    orderBy?: estatus_clienteOrderByWithRelationInput | estatus_clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estatus_clientes.
     */
    cursor?: estatus_clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estatus_clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estatus_clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estatus_clientes.
     */
    distinct?: Estatus_clienteScalarFieldEnum | Estatus_clienteScalarFieldEnum[]
  }

  /**
   * estatus_cliente findMany
   */
  export type estatus_clienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_cliente
     */
    select?: estatus_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_cliente
     */
    omit?: estatus_clienteOmit<ExtArgs> | null
    /**
     * Filter, which estatus_clientes to fetch.
     */
    where?: estatus_clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estatus_clientes to fetch.
     */
    orderBy?: estatus_clienteOrderByWithRelationInput | estatus_clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estatus_clientes.
     */
    cursor?: estatus_clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estatus_clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estatus_clientes.
     */
    skip?: number
    distinct?: Estatus_clienteScalarFieldEnum | Estatus_clienteScalarFieldEnum[]
  }

  /**
   * estatus_cliente create
   */
  export type estatus_clienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_cliente
     */
    select?: estatus_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_cliente
     */
    omit?: estatus_clienteOmit<ExtArgs> | null
    /**
     * The data needed to create a estatus_cliente.
     */
    data: XOR<estatus_clienteCreateInput, estatus_clienteUncheckedCreateInput>
  }

  /**
   * estatus_cliente createMany
   */
  export type estatus_clienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estatus_clientes.
     */
    data: estatus_clienteCreateManyInput | estatus_clienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estatus_cliente update
   */
  export type estatus_clienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_cliente
     */
    select?: estatus_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_cliente
     */
    omit?: estatus_clienteOmit<ExtArgs> | null
    /**
     * The data needed to update a estatus_cliente.
     */
    data: XOR<estatus_clienteUpdateInput, estatus_clienteUncheckedUpdateInput>
    /**
     * Choose, which estatus_cliente to update.
     */
    where: estatus_clienteWhereUniqueInput
  }

  /**
   * estatus_cliente updateMany
   */
  export type estatus_clienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estatus_clientes.
     */
    data: XOR<estatus_clienteUpdateManyMutationInput, estatus_clienteUncheckedUpdateManyInput>
    /**
     * Filter which estatus_clientes to update
     */
    where?: estatus_clienteWhereInput
    /**
     * Limit how many estatus_clientes to update.
     */
    limit?: number
  }

  /**
   * estatus_cliente upsert
   */
  export type estatus_clienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_cliente
     */
    select?: estatus_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_cliente
     */
    omit?: estatus_clienteOmit<ExtArgs> | null
    /**
     * The filter to search for the estatus_cliente to update in case it exists.
     */
    where: estatus_clienteWhereUniqueInput
    /**
     * In case the estatus_cliente found by the `where` argument doesn't exist, create a new estatus_cliente with this data.
     */
    create: XOR<estatus_clienteCreateInput, estatus_clienteUncheckedCreateInput>
    /**
     * In case the estatus_cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estatus_clienteUpdateInput, estatus_clienteUncheckedUpdateInput>
  }

  /**
   * estatus_cliente delete
   */
  export type estatus_clienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_cliente
     */
    select?: estatus_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_cliente
     */
    omit?: estatus_clienteOmit<ExtArgs> | null
    /**
     * Filter which estatus_cliente to delete.
     */
    where: estatus_clienteWhereUniqueInput
  }

  /**
   * estatus_cliente deleteMany
   */
  export type estatus_clienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estatus_clientes to delete
     */
    where?: estatus_clienteWhereInput
    /**
     * Limit how many estatus_clientes to delete.
     */
    limit?: number
  }

  /**
   * estatus_cliente without action
   */
  export type estatus_clienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_cliente
     */
    select?: estatus_clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_cliente
     */
    omit?: estatus_clienteOmit<ExtArgs> | null
  }


  /**
   * Model estatus_polizas
   */

  export type AggregateEstatus_polizas = {
    _count: Estatus_polizasCountAggregateOutputType | null
    _avg: Estatus_polizasAvgAggregateOutputType | null
    _sum: Estatus_polizasSumAggregateOutputType | null
    _min: Estatus_polizasMinAggregateOutputType | null
    _max: Estatus_polizasMaxAggregateOutputType | null
  }

  export type Estatus_polizasAvgAggregateOutputType = {
    id: number | null
  }

  export type Estatus_polizasSumAggregateOutputType = {
    id: bigint | null
  }

  export type Estatus_polizasMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Estatus_polizasMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Estatus_polizasCountAggregateOutputType = {
    id: number
    label: number
    estatus: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Estatus_polizasAvgAggregateInputType = {
    id?: true
  }

  export type Estatus_polizasSumAggregateInputType = {
    id?: true
  }

  export type Estatus_polizasMinAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Estatus_polizasMaxAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Estatus_polizasCountAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Estatus_polizasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estatus_polizas to aggregate.
     */
    where?: estatus_polizasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estatus_polizas to fetch.
     */
    orderBy?: estatus_polizasOrderByWithRelationInput | estatus_polizasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estatus_polizasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estatus_polizas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estatus_polizas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estatus_polizas
    **/
    _count?: true | Estatus_polizasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Estatus_polizasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Estatus_polizasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Estatus_polizasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Estatus_polizasMaxAggregateInputType
  }

  export type GetEstatus_polizasAggregateType<T extends Estatus_polizasAggregateArgs> = {
        [P in keyof T & keyof AggregateEstatus_polizas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstatus_polizas[P]>
      : GetScalarType<T[P], AggregateEstatus_polizas[P]>
  }




  export type estatus_polizasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estatus_polizasWhereInput
    orderBy?: estatus_polizasOrderByWithAggregationInput | estatus_polizasOrderByWithAggregationInput[]
    by: Estatus_polizasScalarFieldEnum[] | Estatus_polizasScalarFieldEnum
    having?: estatus_polizasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Estatus_polizasCountAggregateInputType | true
    _avg?: Estatus_polizasAvgAggregateInputType
    _sum?: Estatus_polizasSumAggregateInputType
    _min?: Estatus_polizasMinAggregateInputType
    _max?: Estatus_polizasMaxAggregateInputType
  }

  export type Estatus_polizasGroupByOutputType = {
    id: bigint
    label: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: Estatus_polizasCountAggregateOutputType | null
    _avg: Estatus_polizasAvgAggregateOutputType | null
    _sum: Estatus_polizasSumAggregateOutputType | null
    _min: Estatus_polizasMinAggregateOutputType | null
    _max: Estatus_polizasMaxAggregateOutputType | null
  }

  type GetEstatus_polizasGroupByPayload<T extends estatus_polizasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Estatus_polizasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Estatus_polizasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Estatus_polizasGroupByOutputType[P]>
            : GetScalarType<T[P], Estatus_polizasGroupByOutputType[P]>
        }
      >
    >


  export type estatus_polizasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["estatus_polizas"]>



  export type estatus_polizasSelectScalar = {
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type estatus_polizasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "estatus" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["estatus_polizas"]>

  export type $estatus_polizasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estatus_polizas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["estatus_polizas"]>
    composites: {}
  }

  type estatus_polizasGetPayload<S extends boolean | null | undefined | estatus_polizasDefaultArgs> = $Result.GetResult<Prisma.$estatus_polizasPayload, S>

  type estatus_polizasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estatus_polizasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Estatus_polizasCountAggregateInputType | true
    }

  export interface estatus_polizasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estatus_polizas'], meta: { name: 'estatus_polizas' } }
    /**
     * Find zero or one Estatus_polizas that matches the filter.
     * @param {estatus_polizasFindUniqueArgs} args - Arguments to find a Estatus_polizas
     * @example
     * // Get one Estatus_polizas
     * const estatus_polizas = await prisma.estatus_polizas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estatus_polizasFindUniqueArgs>(args: SelectSubset<T, estatus_polizasFindUniqueArgs<ExtArgs>>): Prisma__estatus_polizasClient<$Result.GetResult<Prisma.$estatus_polizasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estatus_polizas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estatus_polizasFindUniqueOrThrowArgs} args - Arguments to find a Estatus_polizas
     * @example
     * // Get one Estatus_polizas
     * const estatus_polizas = await prisma.estatus_polizas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estatus_polizasFindUniqueOrThrowArgs>(args: SelectSubset<T, estatus_polizasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estatus_polizasClient<$Result.GetResult<Prisma.$estatus_polizasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estatus_polizas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_polizasFindFirstArgs} args - Arguments to find a Estatus_polizas
     * @example
     * // Get one Estatus_polizas
     * const estatus_polizas = await prisma.estatus_polizas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estatus_polizasFindFirstArgs>(args?: SelectSubset<T, estatus_polizasFindFirstArgs<ExtArgs>>): Prisma__estatus_polizasClient<$Result.GetResult<Prisma.$estatus_polizasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estatus_polizas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_polizasFindFirstOrThrowArgs} args - Arguments to find a Estatus_polizas
     * @example
     * // Get one Estatus_polizas
     * const estatus_polizas = await prisma.estatus_polizas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estatus_polizasFindFirstOrThrowArgs>(args?: SelectSubset<T, estatus_polizasFindFirstOrThrowArgs<ExtArgs>>): Prisma__estatus_polizasClient<$Result.GetResult<Prisma.$estatus_polizasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estatus_polizas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_polizasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estatus_polizas
     * const estatus_polizas = await prisma.estatus_polizas.findMany()
     * 
     * // Get first 10 Estatus_polizas
     * const estatus_polizas = await prisma.estatus_polizas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estatus_polizasWithIdOnly = await prisma.estatus_polizas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estatus_polizasFindManyArgs>(args?: SelectSubset<T, estatus_polizasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estatus_polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estatus_polizas.
     * @param {estatus_polizasCreateArgs} args - Arguments to create a Estatus_polizas.
     * @example
     * // Create one Estatus_polizas
     * const Estatus_polizas = await prisma.estatus_polizas.create({
     *   data: {
     *     // ... data to create a Estatus_polizas
     *   }
     * })
     * 
     */
    create<T extends estatus_polizasCreateArgs>(args: SelectSubset<T, estatus_polizasCreateArgs<ExtArgs>>): Prisma__estatus_polizasClient<$Result.GetResult<Prisma.$estatus_polizasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estatus_polizas.
     * @param {estatus_polizasCreateManyArgs} args - Arguments to create many Estatus_polizas.
     * @example
     * // Create many Estatus_polizas
     * const estatus_polizas = await prisma.estatus_polizas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estatus_polizasCreateManyArgs>(args?: SelectSubset<T, estatus_polizasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estatus_polizas.
     * @param {estatus_polizasDeleteArgs} args - Arguments to delete one Estatus_polizas.
     * @example
     * // Delete one Estatus_polizas
     * const Estatus_polizas = await prisma.estatus_polizas.delete({
     *   where: {
     *     // ... filter to delete one Estatus_polizas
     *   }
     * })
     * 
     */
    delete<T extends estatus_polizasDeleteArgs>(args: SelectSubset<T, estatus_polizasDeleteArgs<ExtArgs>>): Prisma__estatus_polizasClient<$Result.GetResult<Prisma.$estatus_polizasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estatus_polizas.
     * @param {estatus_polizasUpdateArgs} args - Arguments to update one Estatus_polizas.
     * @example
     * // Update one Estatus_polizas
     * const estatus_polizas = await prisma.estatus_polizas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estatus_polizasUpdateArgs>(args: SelectSubset<T, estatus_polizasUpdateArgs<ExtArgs>>): Prisma__estatus_polizasClient<$Result.GetResult<Prisma.$estatus_polizasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estatus_polizas.
     * @param {estatus_polizasDeleteManyArgs} args - Arguments to filter Estatus_polizas to delete.
     * @example
     * // Delete a few Estatus_polizas
     * const { count } = await prisma.estatus_polizas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estatus_polizasDeleteManyArgs>(args?: SelectSubset<T, estatus_polizasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estatus_polizas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_polizasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estatus_polizas
     * const estatus_polizas = await prisma.estatus_polizas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estatus_polizasUpdateManyArgs>(args: SelectSubset<T, estatus_polizasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estatus_polizas.
     * @param {estatus_polizasUpsertArgs} args - Arguments to update or create a Estatus_polizas.
     * @example
     * // Update or create a Estatus_polizas
     * const estatus_polizas = await prisma.estatus_polizas.upsert({
     *   create: {
     *     // ... data to create a Estatus_polizas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estatus_polizas we want to update
     *   }
     * })
     */
    upsert<T extends estatus_polizasUpsertArgs>(args: SelectSubset<T, estatus_polizasUpsertArgs<ExtArgs>>): Prisma__estatus_polizasClient<$Result.GetResult<Prisma.$estatus_polizasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estatus_polizas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_polizasCountArgs} args - Arguments to filter Estatus_polizas to count.
     * @example
     * // Count the number of Estatus_polizas
     * const count = await prisma.estatus_polizas.count({
     *   where: {
     *     // ... the filter for the Estatus_polizas we want to count
     *   }
     * })
    **/
    count<T extends estatus_polizasCountArgs>(
      args?: Subset<T, estatus_polizasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Estatus_polizasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estatus_polizas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Estatus_polizasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Estatus_polizasAggregateArgs>(args: Subset<T, Estatus_polizasAggregateArgs>): Prisma.PrismaPromise<GetEstatus_polizasAggregateType<T>>

    /**
     * Group by Estatus_polizas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estatus_polizasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estatus_polizasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estatus_polizasGroupByArgs['orderBy'] }
        : { orderBy?: estatus_polizasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estatus_polizasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstatus_polizasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estatus_polizas model
   */
  readonly fields: estatus_polizasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estatus_polizas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estatus_polizasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estatus_polizas model
   */
  interface estatus_polizasFieldRefs {
    readonly id: FieldRef<"estatus_polizas", 'BigInt'>
    readonly label: FieldRef<"estatus_polizas", 'String'>
    readonly estatus: FieldRef<"estatus_polizas", 'Boolean'>
    readonly created_at: FieldRef<"estatus_polizas", 'DateTime'>
    readonly updated_at: FieldRef<"estatus_polizas", 'DateTime'>
    readonly deleted_at: FieldRef<"estatus_polizas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * estatus_polizas findUnique
   */
  export type estatus_polizasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_polizas
     */
    select?: estatus_polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_polizas
     */
    omit?: estatus_polizasOmit<ExtArgs> | null
    /**
     * Filter, which estatus_polizas to fetch.
     */
    where: estatus_polizasWhereUniqueInput
  }

  /**
   * estatus_polizas findUniqueOrThrow
   */
  export type estatus_polizasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_polizas
     */
    select?: estatus_polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_polizas
     */
    omit?: estatus_polizasOmit<ExtArgs> | null
    /**
     * Filter, which estatus_polizas to fetch.
     */
    where: estatus_polizasWhereUniqueInput
  }

  /**
   * estatus_polizas findFirst
   */
  export type estatus_polizasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_polizas
     */
    select?: estatus_polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_polizas
     */
    omit?: estatus_polizasOmit<ExtArgs> | null
    /**
     * Filter, which estatus_polizas to fetch.
     */
    where?: estatus_polizasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estatus_polizas to fetch.
     */
    orderBy?: estatus_polizasOrderByWithRelationInput | estatus_polizasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estatus_polizas.
     */
    cursor?: estatus_polizasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estatus_polizas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estatus_polizas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estatus_polizas.
     */
    distinct?: Estatus_polizasScalarFieldEnum | Estatus_polizasScalarFieldEnum[]
  }

  /**
   * estatus_polizas findFirstOrThrow
   */
  export type estatus_polizasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_polizas
     */
    select?: estatus_polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_polizas
     */
    omit?: estatus_polizasOmit<ExtArgs> | null
    /**
     * Filter, which estatus_polizas to fetch.
     */
    where?: estatus_polizasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estatus_polizas to fetch.
     */
    orderBy?: estatus_polizasOrderByWithRelationInput | estatus_polizasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estatus_polizas.
     */
    cursor?: estatus_polizasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estatus_polizas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estatus_polizas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estatus_polizas.
     */
    distinct?: Estatus_polizasScalarFieldEnum | Estatus_polizasScalarFieldEnum[]
  }

  /**
   * estatus_polizas findMany
   */
  export type estatus_polizasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_polizas
     */
    select?: estatus_polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_polizas
     */
    omit?: estatus_polizasOmit<ExtArgs> | null
    /**
     * Filter, which estatus_polizas to fetch.
     */
    where?: estatus_polizasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estatus_polizas to fetch.
     */
    orderBy?: estatus_polizasOrderByWithRelationInput | estatus_polizasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estatus_polizas.
     */
    cursor?: estatus_polizasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estatus_polizas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estatus_polizas.
     */
    skip?: number
    distinct?: Estatus_polizasScalarFieldEnum | Estatus_polizasScalarFieldEnum[]
  }

  /**
   * estatus_polizas create
   */
  export type estatus_polizasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_polizas
     */
    select?: estatus_polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_polizas
     */
    omit?: estatus_polizasOmit<ExtArgs> | null
    /**
     * The data needed to create a estatus_polizas.
     */
    data: XOR<estatus_polizasCreateInput, estatus_polizasUncheckedCreateInput>
  }

  /**
   * estatus_polizas createMany
   */
  export type estatus_polizasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estatus_polizas.
     */
    data: estatus_polizasCreateManyInput | estatus_polizasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estatus_polizas update
   */
  export type estatus_polizasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_polizas
     */
    select?: estatus_polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_polizas
     */
    omit?: estatus_polizasOmit<ExtArgs> | null
    /**
     * The data needed to update a estatus_polizas.
     */
    data: XOR<estatus_polizasUpdateInput, estatus_polizasUncheckedUpdateInput>
    /**
     * Choose, which estatus_polizas to update.
     */
    where: estatus_polizasWhereUniqueInput
  }

  /**
   * estatus_polizas updateMany
   */
  export type estatus_polizasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estatus_polizas.
     */
    data: XOR<estatus_polizasUpdateManyMutationInput, estatus_polizasUncheckedUpdateManyInput>
    /**
     * Filter which estatus_polizas to update
     */
    where?: estatus_polizasWhereInput
    /**
     * Limit how many estatus_polizas to update.
     */
    limit?: number
  }

  /**
   * estatus_polizas upsert
   */
  export type estatus_polizasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_polizas
     */
    select?: estatus_polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_polizas
     */
    omit?: estatus_polizasOmit<ExtArgs> | null
    /**
     * The filter to search for the estatus_polizas to update in case it exists.
     */
    where: estatus_polizasWhereUniqueInput
    /**
     * In case the estatus_polizas found by the `where` argument doesn't exist, create a new estatus_polizas with this data.
     */
    create: XOR<estatus_polizasCreateInput, estatus_polizasUncheckedCreateInput>
    /**
     * In case the estatus_polizas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estatus_polizasUpdateInput, estatus_polizasUncheckedUpdateInput>
  }

  /**
   * estatus_polizas delete
   */
  export type estatus_polizasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_polizas
     */
    select?: estatus_polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_polizas
     */
    omit?: estatus_polizasOmit<ExtArgs> | null
    /**
     * Filter which estatus_polizas to delete.
     */
    where: estatus_polizasWhereUniqueInput
  }

  /**
   * estatus_polizas deleteMany
   */
  export type estatus_polizasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estatus_polizas to delete
     */
    where?: estatus_polizasWhereInput
    /**
     * Limit how many estatus_polizas to delete.
     */
    limit?: number
  }

  /**
   * estatus_polizas without action
   */
  export type estatus_polizasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estatus_polizas
     */
    select?: estatus_polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estatus_polizas
     */
    omit?: estatus_polizasOmit<ExtArgs> | null
  }


  /**
   * Model failed_jobs
   */

  export type AggregateFailed_jobs = {
    _count: Failed_jobsCountAggregateOutputType | null
    _avg: Failed_jobsAvgAggregateOutputType | null
    _sum: Failed_jobsSumAggregateOutputType | null
    _min: Failed_jobsMinAggregateOutputType | null
    _max: Failed_jobsMaxAggregateOutputType | null
  }

  export type Failed_jobsAvgAggregateOutputType = {
    id: number | null
  }

  export type Failed_jobsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Failed_jobsMinAggregateOutputType = {
    id: bigint | null
    uuid: string | null
    connection: string | null
    queue: string | null
    payload: string | null
    exception: string | null
    failed_at: Date | null
  }

  export type Failed_jobsMaxAggregateOutputType = {
    id: bigint | null
    uuid: string | null
    connection: string | null
    queue: string | null
    payload: string | null
    exception: string | null
    failed_at: Date | null
  }

  export type Failed_jobsCountAggregateOutputType = {
    id: number
    uuid: number
    connection: number
    queue: number
    payload: number
    exception: number
    failed_at: number
    _all: number
  }


  export type Failed_jobsAvgAggregateInputType = {
    id?: true
  }

  export type Failed_jobsSumAggregateInputType = {
    id?: true
  }

  export type Failed_jobsMinAggregateInputType = {
    id?: true
    uuid?: true
    connection?: true
    queue?: true
    payload?: true
    exception?: true
    failed_at?: true
  }

  export type Failed_jobsMaxAggregateInputType = {
    id?: true
    uuid?: true
    connection?: true
    queue?: true
    payload?: true
    exception?: true
    failed_at?: true
  }

  export type Failed_jobsCountAggregateInputType = {
    id?: true
    uuid?: true
    connection?: true
    queue?: true
    payload?: true
    exception?: true
    failed_at?: true
    _all?: true
  }

  export type Failed_jobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which failed_jobs to aggregate.
     */
    where?: failed_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of failed_jobs to fetch.
     */
    orderBy?: failed_jobsOrderByWithRelationInput | failed_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: failed_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` failed_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` failed_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned failed_jobs
    **/
    _count?: true | Failed_jobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Failed_jobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Failed_jobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Failed_jobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Failed_jobsMaxAggregateInputType
  }

  export type GetFailed_jobsAggregateType<T extends Failed_jobsAggregateArgs> = {
        [P in keyof T & keyof AggregateFailed_jobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFailed_jobs[P]>
      : GetScalarType<T[P], AggregateFailed_jobs[P]>
  }




  export type failed_jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: failed_jobsWhereInput
    orderBy?: failed_jobsOrderByWithAggregationInput | failed_jobsOrderByWithAggregationInput[]
    by: Failed_jobsScalarFieldEnum[] | Failed_jobsScalarFieldEnum
    having?: failed_jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Failed_jobsCountAggregateInputType | true
    _avg?: Failed_jobsAvgAggregateInputType
    _sum?: Failed_jobsSumAggregateInputType
    _min?: Failed_jobsMinAggregateInputType
    _max?: Failed_jobsMaxAggregateInputType
  }

  export type Failed_jobsGroupByOutputType = {
    id: bigint
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failed_at: Date
    _count: Failed_jobsCountAggregateOutputType | null
    _avg: Failed_jobsAvgAggregateOutputType | null
    _sum: Failed_jobsSumAggregateOutputType | null
    _min: Failed_jobsMinAggregateOutputType | null
    _max: Failed_jobsMaxAggregateOutputType | null
  }

  type GetFailed_jobsGroupByPayload<T extends failed_jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Failed_jobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Failed_jobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Failed_jobsGroupByOutputType[P]>
            : GetScalarType<T[P], Failed_jobsGroupByOutputType[P]>
        }
      >
    >


  export type failed_jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    connection?: boolean
    queue?: boolean
    payload?: boolean
    exception?: boolean
    failed_at?: boolean
  }, ExtArgs["result"]["failed_jobs"]>



  export type failed_jobsSelectScalar = {
    id?: boolean
    uuid?: boolean
    connection?: boolean
    queue?: boolean
    payload?: boolean
    exception?: boolean
    failed_at?: boolean
  }

  export type failed_jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "connection" | "queue" | "payload" | "exception" | "failed_at", ExtArgs["result"]["failed_jobs"]>

  export type $failed_jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "failed_jobs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      uuid: string
      connection: string
      queue: string
      payload: string
      exception: string
      failed_at: Date
    }, ExtArgs["result"]["failed_jobs"]>
    composites: {}
  }

  type failed_jobsGetPayload<S extends boolean | null | undefined | failed_jobsDefaultArgs> = $Result.GetResult<Prisma.$failed_jobsPayload, S>

  type failed_jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<failed_jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Failed_jobsCountAggregateInputType | true
    }

  export interface failed_jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['failed_jobs'], meta: { name: 'failed_jobs' } }
    /**
     * Find zero or one Failed_jobs that matches the filter.
     * @param {failed_jobsFindUniqueArgs} args - Arguments to find a Failed_jobs
     * @example
     * // Get one Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends failed_jobsFindUniqueArgs>(args: SelectSubset<T, failed_jobsFindUniqueArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Failed_jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {failed_jobsFindUniqueOrThrowArgs} args - Arguments to find a Failed_jobs
     * @example
     * // Get one Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends failed_jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, failed_jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Failed_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsFindFirstArgs} args - Arguments to find a Failed_jobs
     * @example
     * // Get one Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends failed_jobsFindFirstArgs>(args?: SelectSubset<T, failed_jobsFindFirstArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Failed_jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsFindFirstOrThrowArgs} args - Arguments to find a Failed_jobs
     * @example
     * // Get one Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends failed_jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, failed_jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Failed_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findMany()
     * 
     * // Get first 10 Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const failed_jobsWithIdOnly = await prisma.failed_jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends failed_jobsFindManyArgs>(args?: SelectSubset<T, failed_jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Failed_jobs.
     * @param {failed_jobsCreateArgs} args - Arguments to create a Failed_jobs.
     * @example
     * // Create one Failed_jobs
     * const Failed_jobs = await prisma.failed_jobs.create({
     *   data: {
     *     // ... data to create a Failed_jobs
     *   }
     * })
     * 
     */
    create<T extends failed_jobsCreateArgs>(args: SelectSubset<T, failed_jobsCreateArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Failed_jobs.
     * @param {failed_jobsCreateManyArgs} args - Arguments to create many Failed_jobs.
     * @example
     * // Create many Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends failed_jobsCreateManyArgs>(args?: SelectSubset<T, failed_jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Failed_jobs.
     * @param {failed_jobsDeleteArgs} args - Arguments to delete one Failed_jobs.
     * @example
     * // Delete one Failed_jobs
     * const Failed_jobs = await prisma.failed_jobs.delete({
     *   where: {
     *     // ... filter to delete one Failed_jobs
     *   }
     * })
     * 
     */
    delete<T extends failed_jobsDeleteArgs>(args: SelectSubset<T, failed_jobsDeleteArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Failed_jobs.
     * @param {failed_jobsUpdateArgs} args - Arguments to update one Failed_jobs.
     * @example
     * // Update one Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends failed_jobsUpdateArgs>(args: SelectSubset<T, failed_jobsUpdateArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Failed_jobs.
     * @param {failed_jobsDeleteManyArgs} args - Arguments to filter Failed_jobs to delete.
     * @example
     * // Delete a few Failed_jobs
     * const { count } = await prisma.failed_jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends failed_jobsDeleteManyArgs>(args?: SelectSubset<T, failed_jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Failed_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends failed_jobsUpdateManyArgs>(args: SelectSubset<T, failed_jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Failed_jobs.
     * @param {failed_jobsUpsertArgs} args - Arguments to update or create a Failed_jobs.
     * @example
     * // Update or create a Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.upsert({
     *   create: {
     *     // ... data to create a Failed_jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Failed_jobs we want to update
     *   }
     * })
     */
    upsert<T extends failed_jobsUpsertArgs>(args: SelectSubset<T, failed_jobsUpsertArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Failed_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsCountArgs} args - Arguments to filter Failed_jobs to count.
     * @example
     * // Count the number of Failed_jobs
     * const count = await prisma.failed_jobs.count({
     *   where: {
     *     // ... the filter for the Failed_jobs we want to count
     *   }
     * })
    **/
    count<T extends failed_jobsCountArgs>(
      args?: Subset<T, failed_jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Failed_jobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Failed_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Failed_jobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Failed_jobsAggregateArgs>(args: Subset<T, Failed_jobsAggregateArgs>): Prisma.PrismaPromise<GetFailed_jobsAggregateType<T>>

    /**
     * Group by Failed_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends failed_jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: failed_jobsGroupByArgs['orderBy'] }
        : { orderBy?: failed_jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, failed_jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFailed_jobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the failed_jobs model
   */
  readonly fields: failed_jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for failed_jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__failed_jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the failed_jobs model
   */
  interface failed_jobsFieldRefs {
    readonly id: FieldRef<"failed_jobs", 'BigInt'>
    readonly uuid: FieldRef<"failed_jobs", 'String'>
    readonly connection: FieldRef<"failed_jobs", 'String'>
    readonly queue: FieldRef<"failed_jobs", 'String'>
    readonly payload: FieldRef<"failed_jobs", 'String'>
    readonly exception: FieldRef<"failed_jobs", 'String'>
    readonly failed_at: FieldRef<"failed_jobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * failed_jobs findUnique
   */
  export type failed_jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter, which failed_jobs to fetch.
     */
    where: failed_jobsWhereUniqueInput
  }

  /**
   * failed_jobs findUniqueOrThrow
   */
  export type failed_jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter, which failed_jobs to fetch.
     */
    where: failed_jobsWhereUniqueInput
  }

  /**
   * failed_jobs findFirst
   */
  export type failed_jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter, which failed_jobs to fetch.
     */
    where?: failed_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of failed_jobs to fetch.
     */
    orderBy?: failed_jobsOrderByWithRelationInput | failed_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for failed_jobs.
     */
    cursor?: failed_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` failed_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` failed_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of failed_jobs.
     */
    distinct?: Failed_jobsScalarFieldEnum | Failed_jobsScalarFieldEnum[]
  }

  /**
   * failed_jobs findFirstOrThrow
   */
  export type failed_jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter, which failed_jobs to fetch.
     */
    where?: failed_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of failed_jobs to fetch.
     */
    orderBy?: failed_jobsOrderByWithRelationInput | failed_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for failed_jobs.
     */
    cursor?: failed_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` failed_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` failed_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of failed_jobs.
     */
    distinct?: Failed_jobsScalarFieldEnum | Failed_jobsScalarFieldEnum[]
  }

  /**
   * failed_jobs findMany
   */
  export type failed_jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter, which failed_jobs to fetch.
     */
    where?: failed_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of failed_jobs to fetch.
     */
    orderBy?: failed_jobsOrderByWithRelationInput | failed_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing failed_jobs.
     */
    cursor?: failed_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` failed_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` failed_jobs.
     */
    skip?: number
    distinct?: Failed_jobsScalarFieldEnum | Failed_jobsScalarFieldEnum[]
  }

  /**
   * failed_jobs create
   */
  export type failed_jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * The data needed to create a failed_jobs.
     */
    data: XOR<failed_jobsCreateInput, failed_jobsUncheckedCreateInput>
  }

  /**
   * failed_jobs createMany
   */
  export type failed_jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many failed_jobs.
     */
    data: failed_jobsCreateManyInput | failed_jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * failed_jobs update
   */
  export type failed_jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * The data needed to update a failed_jobs.
     */
    data: XOR<failed_jobsUpdateInput, failed_jobsUncheckedUpdateInput>
    /**
     * Choose, which failed_jobs to update.
     */
    where: failed_jobsWhereUniqueInput
  }

  /**
   * failed_jobs updateMany
   */
  export type failed_jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update failed_jobs.
     */
    data: XOR<failed_jobsUpdateManyMutationInput, failed_jobsUncheckedUpdateManyInput>
    /**
     * Filter which failed_jobs to update
     */
    where?: failed_jobsWhereInput
    /**
     * Limit how many failed_jobs to update.
     */
    limit?: number
  }

  /**
   * failed_jobs upsert
   */
  export type failed_jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * The filter to search for the failed_jobs to update in case it exists.
     */
    where: failed_jobsWhereUniqueInput
    /**
     * In case the failed_jobs found by the `where` argument doesn't exist, create a new failed_jobs with this data.
     */
    create: XOR<failed_jobsCreateInput, failed_jobsUncheckedCreateInput>
    /**
     * In case the failed_jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<failed_jobsUpdateInput, failed_jobsUncheckedUpdateInput>
  }

  /**
   * failed_jobs delete
   */
  export type failed_jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter which failed_jobs to delete.
     */
    where: failed_jobsWhereUniqueInput
  }

  /**
   * failed_jobs deleteMany
   */
  export type failed_jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which failed_jobs to delete
     */
    where?: failed_jobsWhereInput
    /**
     * Limit how many failed_jobs to delete.
     */
    limit?: number
  }

  /**
   * failed_jobs without action
   */
  export type failed_jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
  }


  /**
   * Model formas_de_pago
   */

  export type AggregateFormas_de_pago = {
    _count: Formas_de_pagoCountAggregateOutputType | null
    _avg: Formas_de_pagoAvgAggregateOutputType | null
    _sum: Formas_de_pagoSumAggregateOutputType | null
    _min: Formas_de_pagoMinAggregateOutputType | null
    _max: Formas_de_pagoMaxAggregateOutputType | null
  }

  export type Formas_de_pagoAvgAggregateOutputType = {
    id: number | null
  }

  export type Formas_de_pagoSumAggregateOutputType = {
    id: bigint | null
  }

  export type Formas_de_pagoMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Formas_de_pagoMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Formas_de_pagoCountAggregateOutputType = {
    id: number
    label: number
    estatus: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Formas_de_pagoAvgAggregateInputType = {
    id?: true
  }

  export type Formas_de_pagoSumAggregateInputType = {
    id?: true
  }

  export type Formas_de_pagoMinAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Formas_de_pagoMaxAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Formas_de_pagoCountAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Formas_de_pagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formas_de_pago to aggregate.
     */
    where?: formas_de_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formas_de_pagos to fetch.
     */
    orderBy?: formas_de_pagoOrderByWithRelationInput | formas_de_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formas_de_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formas_de_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formas_de_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formas_de_pagos
    **/
    _count?: true | Formas_de_pagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Formas_de_pagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Formas_de_pagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Formas_de_pagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Formas_de_pagoMaxAggregateInputType
  }

  export type GetFormas_de_pagoAggregateType<T extends Formas_de_pagoAggregateArgs> = {
        [P in keyof T & keyof AggregateFormas_de_pago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormas_de_pago[P]>
      : GetScalarType<T[P], AggregateFormas_de_pago[P]>
  }




  export type formas_de_pagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formas_de_pagoWhereInput
    orderBy?: formas_de_pagoOrderByWithAggregationInput | formas_de_pagoOrderByWithAggregationInput[]
    by: Formas_de_pagoScalarFieldEnum[] | Formas_de_pagoScalarFieldEnum
    having?: formas_de_pagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Formas_de_pagoCountAggregateInputType | true
    _avg?: Formas_de_pagoAvgAggregateInputType
    _sum?: Formas_de_pagoSumAggregateInputType
    _min?: Formas_de_pagoMinAggregateInputType
    _max?: Formas_de_pagoMaxAggregateInputType
  }

  export type Formas_de_pagoGroupByOutputType = {
    id: bigint
    label: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: Formas_de_pagoCountAggregateOutputType | null
    _avg: Formas_de_pagoAvgAggregateOutputType | null
    _sum: Formas_de_pagoSumAggregateOutputType | null
    _min: Formas_de_pagoMinAggregateOutputType | null
    _max: Formas_de_pagoMaxAggregateOutputType | null
  }

  type GetFormas_de_pagoGroupByPayload<T extends formas_de_pagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Formas_de_pagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Formas_de_pagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Formas_de_pagoGroupByOutputType[P]>
            : GetScalarType<T[P], Formas_de_pagoGroupByOutputType[P]>
        }
      >
    >


  export type formas_de_pagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    polizas?: boolean | formas_de_pago$polizasArgs<ExtArgs>
    _count?: boolean | Formas_de_pagoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formas_de_pago"]>



  export type formas_de_pagoSelectScalar = {
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type formas_de_pagoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "estatus" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["formas_de_pago"]>
  export type formas_de_pagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | formas_de_pago$polizasArgs<ExtArgs>
    _count?: boolean | Formas_de_pagoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $formas_de_pagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "formas_de_pago"
    objects: {
      polizas: Prisma.$polizasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["formas_de_pago"]>
    composites: {}
  }

  type formas_de_pagoGetPayload<S extends boolean | null | undefined | formas_de_pagoDefaultArgs> = $Result.GetResult<Prisma.$formas_de_pagoPayload, S>

  type formas_de_pagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<formas_de_pagoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Formas_de_pagoCountAggregateInputType | true
    }

  export interface formas_de_pagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['formas_de_pago'], meta: { name: 'formas_de_pago' } }
    /**
     * Find zero or one Formas_de_pago that matches the filter.
     * @param {formas_de_pagoFindUniqueArgs} args - Arguments to find a Formas_de_pago
     * @example
     * // Get one Formas_de_pago
     * const formas_de_pago = await prisma.formas_de_pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formas_de_pagoFindUniqueArgs>(args: SelectSubset<T, formas_de_pagoFindUniqueArgs<ExtArgs>>): Prisma__formas_de_pagoClient<$Result.GetResult<Prisma.$formas_de_pagoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Formas_de_pago that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {formas_de_pagoFindUniqueOrThrowArgs} args - Arguments to find a Formas_de_pago
     * @example
     * // Get one Formas_de_pago
     * const formas_de_pago = await prisma.formas_de_pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formas_de_pagoFindUniqueOrThrowArgs>(args: SelectSubset<T, formas_de_pagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formas_de_pagoClient<$Result.GetResult<Prisma.$formas_de_pagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Formas_de_pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formas_de_pagoFindFirstArgs} args - Arguments to find a Formas_de_pago
     * @example
     * // Get one Formas_de_pago
     * const formas_de_pago = await prisma.formas_de_pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formas_de_pagoFindFirstArgs>(args?: SelectSubset<T, formas_de_pagoFindFirstArgs<ExtArgs>>): Prisma__formas_de_pagoClient<$Result.GetResult<Prisma.$formas_de_pagoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Formas_de_pago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formas_de_pagoFindFirstOrThrowArgs} args - Arguments to find a Formas_de_pago
     * @example
     * // Get one Formas_de_pago
     * const formas_de_pago = await prisma.formas_de_pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formas_de_pagoFindFirstOrThrowArgs>(args?: SelectSubset<T, formas_de_pagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__formas_de_pagoClient<$Result.GetResult<Prisma.$formas_de_pagoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Formas_de_pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formas_de_pagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Formas_de_pagos
     * const formas_de_pagos = await prisma.formas_de_pago.findMany()
     * 
     * // Get first 10 Formas_de_pagos
     * const formas_de_pagos = await prisma.formas_de_pago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formas_de_pagoWithIdOnly = await prisma.formas_de_pago.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends formas_de_pagoFindManyArgs>(args?: SelectSubset<T, formas_de_pagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formas_de_pagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Formas_de_pago.
     * @param {formas_de_pagoCreateArgs} args - Arguments to create a Formas_de_pago.
     * @example
     * // Create one Formas_de_pago
     * const Formas_de_pago = await prisma.formas_de_pago.create({
     *   data: {
     *     // ... data to create a Formas_de_pago
     *   }
     * })
     * 
     */
    create<T extends formas_de_pagoCreateArgs>(args: SelectSubset<T, formas_de_pagoCreateArgs<ExtArgs>>): Prisma__formas_de_pagoClient<$Result.GetResult<Prisma.$formas_de_pagoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Formas_de_pagos.
     * @param {formas_de_pagoCreateManyArgs} args - Arguments to create many Formas_de_pagos.
     * @example
     * // Create many Formas_de_pagos
     * const formas_de_pago = await prisma.formas_de_pago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formas_de_pagoCreateManyArgs>(args?: SelectSubset<T, formas_de_pagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Formas_de_pago.
     * @param {formas_de_pagoDeleteArgs} args - Arguments to delete one Formas_de_pago.
     * @example
     * // Delete one Formas_de_pago
     * const Formas_de_pago = await prisma.formas_de_pago.delete({
     *   where: {
     *     // ... filter to delete one Formas_de_pago
     *   }
     * })
     * 
     */
    delete<T extends formas_de_pagoDeleteArgs>(args: SelectSubset<T, formas_de_pagoDeleteArgs<ExtArgs>>): Prisma__formas_de_pagoClient<$Result.GetResult<Prisma.$formas_de_pagoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Formas_de_pago.
     * @param {formas_de_pagoUpdateArgs} args - Arguments to update one Formas_de_pago.
     * @example
     * // Update one Formas_de_pago
     * const formas_de_pago = await prisma.formas_de_pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formas_de_pagoUpdateArgs>(args: SelectSubset<T, formas_de_pagoUpdateArgs<ExtArgs>>): Prisma__formas_de_pagoClient<$Result.GetResult<Prisma.$formas_de_pagoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Formas_de_pagos.
     * @param {formas_de_pagoDeleteManyArgs} args - Arguments to filter Formas_de_pagos to delete.
     * @example
     * // Delete a few Formas_de_pagos
     * const { count } = await prisma.formas_de_pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formas_de_pagoDeleteManyArgs>(args?: SelectSubset<T, formas_de_pagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formas_de_pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formas_de_pagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Formas_de_pagos
     * const formas_de_pago = await prisma.formas_de_pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formas_de_pagoUpdateManyArgs>(args: SelectSubset<T, formas_de_pagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Formas_de_pago.
     * @param {formas_de_pagoUpsertArgs} args - Arguments to update or create a Formas_de_pago.
     * @example
     * // Update or create a Formas_de_pago
     * const formas_de_pago = await prisma.formas_de_pago.upsert({
     *   create: {
     *     // ... data to create a Formas_de_pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Formas_de_pago we want to update
     *   }
     * })
     */
    upsert<T extends formas_de_pagoUpsertArgs>(args: SelectSubset<T, formas_de_pagoUpsertArgs<ExtArgs>>): Prisma__formas_de_pagoClient<$Result.GetResult<Prisma.$formas_de_pagoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Formas_de_pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formas_de_pagoCountArgs} args - Arguments to filter Formas_de_pagos to count.
     * @example
     * // Count the number of Formas_de_pagos
     * const count = await prisma.formas_de_pago.count({
     *   where: {
     *     // ... the filter for the Formas_de_pagos we want to count
     *   }
     * })
    **/
    count<T extends formas_de_pagoCountArgs>(
      args?: Subset<T, formas_de_pagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Formas_de_pagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Formas_de_pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Formas_de_pagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Formas_de_pagoAggregateArgs>(args: Subset<T, Formas_de_pagoAggregateArgs>): Prisma.PrismaPromise<GetFormas_de_pagoAggregateType<T>>

    /**
     * Group by Formas_de_pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formas_de_pagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formas_de_pagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formas_de_pagoGroupByArgs['orderBy'] }
        : { orderBy?: formas_de_pagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formas_de_pagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormas_de_pagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the formas_de_pago model
   */
  readonly fields: formas_de_pagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for formas_de_pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formas_de_pagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    polizas<T extends formas_de_pago$polizasArgs<ExtArgs> = {}>(args?: Subset<T, formas_de_pago$polizasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the formas_de_pago model
   */
  interface formas_de_pagoFieldRefs {
    readonly id: FieldRef<"formas_de_pago", 'BigInt'>
    readonly label: FieldRef<"formas_de_pago", 'String'>
    readonly estatus: FieldRef<"formas_de_pago", 'Boolean'>
    readonly created_at: FieldRef<"formas_de_pago", 'DateTime'>
    readonly updated_at: FieldRef<"formas_de_pago", 'DateTime'>
    readonly deleted_at: FieldRef<"formas_de_pago", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * formas_de_pago findUnique
   */
  export type formas_de_pagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formas_de_pago
     */
    select?: formas_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formas_de_pago
     */
    omit?: formas_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formas_de_pagoInclude<ExtArgs> | null
    /**
     * Filter, which formas_de_pago to fetch.
     */
    where: formas_de_pagoWhereUniqueInput
  }

  /**
   * formas_de_pago findUniqueOrThrow
   */
  export type formas_de_pagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formas_de_pago
     */
    select?: formas_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formas_de_pago
     */
    omit?: formas_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formas_de_pagoInclude<ExtArgs> | null
    /**
     * Filter, which formas_de_pago to fetch.
     */
    where: formas_de_pagoWhereUniqueInput
  }

  /**
   * formas_de_pago findFirst
   */
  export type formas_de_pagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formas_de_pago
     */
    select?: formas_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formas_de_pago
     */
    omit?: formas_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formas_de_pagoInclude<ExtArgs> | null
    /**
     * Filter, which formas_de_pago to fetch.
     */
    where?: formas_de_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formas_de_pagos to fetch.
     */
    orderBy?: formas_de_pagoOrderByWithRelationInput | formas_de_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formas_de_pagos.
     */
    cursor?: formas_de_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formas_de_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formas_de_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formas_de_pagos.
     */
    distinct?: Formas_de_pagoScalarFieldEnum | Formas_de_pagoScalarFieldEnum[]
  }

  /**
   * formas_de_pago findFirstOrThrow
   */
  export type formas_de_pagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formas_de_pago
     */
    select?: formas_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formas_de_pago
     */
    omit?: formas_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formas_de_pagoInclude<ExtArgs> | null
    /**
     * Filter, which formas_de_pago to fetch.
     */
    where?: formas_de_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formas_de_pagos to fetch.
     */
    orderBy?: formas_de_pagoOrderByWithRelationInput | formas_de_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formas_de_pagos.
     */
    cursor?: formas_de_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formas_de_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formas_de_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formas_de_pagos.
     */
    distinct?: Formas_de_pagoScalarFieldEnum | Formas_de_pagoScalarFieldEnum[]
  }

  /**
   * formas_de_pago findMany
   */
  export type formas_de_pagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formas_de_pago
     */
    select?: formas_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formas_de_pago
     */
    omit?: formas_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formas_de_pagoInclude<ExtArgs> | null
    /**
     * Filter, which formas_de_pagos to fetch.
     */
    where?: formas_de_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formas_de_pagos to fetch.
     */
    orderBy?: formas_de_pagoOrderByWithRelationInput | formas_de_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formas_de_pagos.
     */
    cursor?: formas_de_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formas_de_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formas_de_pagos.
     */
    skip?: number
    distinct?: Formas_de_pagoScalarFieldEnum | Formas_de_pagoScalarFieldEnum[]
  }

  /**
   * formas_de_pago create
   */
  export type formas_de_pagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formas_de_pago
     */
    select?: formas_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formas_de_pago
     */
    omit?: formas_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formas_de_pagoInclude<ExtArgs> | null
    /**
     * The data needed to create a formas_de_pago.
     */
    data: XOR<formas_de_pagoCreateInput, formas_de_pagoUncheckedCreateInput>
  }

  /**
   * formas_de_pago createMany
   */
  export type formas_de_pagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many formas_de_pagos.
     */
    data: formas_de_pagoCreateManyInput | formas_de_pagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * formas_de_pago update
   */
  export type formas_de_pagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formas_de_pago
     */
    select?: formas_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formas_de_pago
     */
    omit?: formas_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formas_de_pagoInclude<ExtArgs> | null
    /**
     * The data needed to update a formas_de_pago.
     */
    data: XOR<formas_de_pagoUpdateInput, formas_de_pagoUncheckedUpdateInput>
    /**
     * Choose, which formas_de_pago to update.
     */
    where: formas_de_pagoWhereUniqueInput
  }

  /**
   * formas_de_pago updateMany
   */
  export type formas_de_pagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update formas_de_pagos.
     */
    data: XOR<formas_de_pagoUpdateManyMutationInput, formas_de_pagoUncheckedUpdateManyInput>
    /**
     * Filter which formas_de_pagos to update
     */
    where?: formas_de_pagoWhereInput
    /**
     * Limit how many formas_de_pagos to update.
     */
    limit?: number
  }

  /**
   * formas_de_pago upsert
   */
  export type formas_de_pagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formas_de_pago
     */
    select?: formas_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formas_de_pago
     */
    omit?: formas_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formas_de_pagoInclude<ExtArgs> | null
    /**
     * The filter to search for the formas_de_pago to update in case it exists.
     */
    where: formas_de_pagoWhereUniqueInput
    /**
     * In case the formas_de_pago found by the `where` argument doesn't exist, create a new formas_de_pago with this data.
     */
    create: XOR<formas_de_pagoCreateInput, formas_de_pagoUncheckedCreateInput>
    /**
     * In case the formas_de_pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formas_de_pagoUpdateInput, formas_de_pagoUncheckedUpdateInput>
  }

  /**
   * formas_de_pago delete
   */
  export type formas_de_pagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formas_de_pago
     */
    select?: formas_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formas_de_pago
     */
    omit?: formas_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formas_de_pagoInclude<ExtArgs> | null
    /**
     * Filter which formas_de_pago to delete.
     */
    where: formas_de_pagoWhereUniqueInput
  }

  /**
   * formas_de_pago deleteMany
   */
  export type formas_de_pagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formas_de_pagos to delete
     */
    where?: formas_de_pagoWhereInput
    /**
     * Limit how many formas_de_pagos to delete.
     */
    limit?: number
  }

  /**
   * formas_de_pago.polizas
   */
  export type formas_de_pago$polizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    where?: polizasWhereInput
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    cursor?: polizasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * formas_de_pago without action
   */
  export type formas_de_pagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formas_de_pago
     */
    select?: formas_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formas_de_pago
     */
    omit?: formas_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formas_de_pagoInclude<ExtArgs> | null
  }


  /**
   * Model job_batches
   */

  export type AggregateJob_batches = {
    _count: Job_batchesCountAggregateOutputType | null
    _avg: Job_batchesAvgAggregateOutputType | null
    _sum: Job_batchesSumAggregateOutputType | null
    _min: Job_batchesMinAggregateOutputType | null
    _max: Job_batchesMaxAggregateOutputType | null
  }

  export type Job_batchesAvgAggregateOutputType = {
    total_jobs: number | null
    pending_jobs: number | null
    failed_jobs: number | null
    cancelled_at: number | null
    created_at: number | null
    finished_at: number | null
  }

  export type Job_batchesSumAggregateOutputType = {
    total_jobs: number | null
    pending_jobs: number | null
    failed_jobs: number | null
    cancelled_at: number | null
    created_at: number | null
    finished_at: number | null
  }

  export type Job_batchesMinAggregateOutputType = {
    id: string | null
    name: string | null
    total_jobs: number | null
    pending_jobs: number | null
    failed_jobs: number | null
    failed_job_ids: string | null
    options: string | null
    cancelled_at: number | null
    created_at: number | null
    finished_at: number | null
  }

  export type Job_batchesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    total_jobs: number | null
    pending_jobs: number | null
    failed_jobs: number | null
    failed_job_ids: string | null
    options: string | null
    cancelled_at: number | null
    created_at: number | null
    finished_at: number | null
  }

  export type Job_batchesCountAggregateOutputType = {
    id: number
    name: number
    total_jobs: number
    pending_jobs: number
    failed_jobs: number
    failed_job_ids: number
    options: number
    cancelled_at: number
    created_at: number
    finished_at: number
    _all: number
  }


  export type Job_batchesAvgAggregateInputType = {
    total_jobs?: true
    pending_jobs?: true
    failed_jobs?: true
    cancelled_at?: true
    created_at?: true
    finished_at?: true
  }

  export type Job_batchesSumAggregateInputType = {
    total_jobs?: true
    pending_jobs?: true
    failed_jobs?: true
    cancelled_at?: true
    created_at?: true
    finished_at?: true
  }

  export type Job_batchesMinAggregateInputType = {
    id?: true
    name?: true
    total_jobs?: true
    pending_jobs?: true
    failed_jobs?: true
    failed_job_ids?: true
    options?: true
    cancelled_at?: true
    created_at?: true
    finished_at?: true
  }

  export type Job_batchesMaxAggregateInputType = {
    id?: true
    name?: true
    total_jobs?: true
    pending_jobs?: true
    failed_jobs?: true
    failed_job_ids?: true
    options?: true
    cancelled_at?: true
    created_at?: true
    finished_at?: true
  }

  export type Job_batchesCountAggregateInputType = {
    id?: true
    name?: true
    total_jobs?: true
    pending_jobs?: true
    failed_jobs?: true
    failed_job_ids?: true
    options?: true
    cancelled_at?: true
    created_at?: true
    finished_at?: true
    _all?: true
  }

  export type Job_batchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_batches to aggregate.
     */
    where?: job_batchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_batches to fetch.
     */
    orderBy?: job_batchesOrderByWithRelationInput | job_batchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_batchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_batches
    **/
    _count?: true | Job_batchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_batchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_batchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_batchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_batchesMaxAggregateInputType
  }

  export type GetJob_batchesAggregateType<T extends Job_batchesAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_batches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_batches[P]>
      : GetScalarType<T[P], AggregateJob_batches[P]>
  }




  export type job_batchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_batchesWhereInput
    orderBy?: job_batchesOrderByWithAggregationInput | job_batchesOrderByWithAggregationInput[]
    by: Job_batchesScalarFieldEnum[] | Job_batchesScalarFieldEnum
    having?: job_batchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_batchesCountAggregateInputType | true
    _avg?: Job_batchesAvgAggregateInputType
    _sum?: Job_batchesSumAggregateInputType
    _min?: Job_batchesMinAggregateInputType
    _max?: Job_batchesMaxAggregateInputType
  }

  export type Job_batchesGroupByOutputType = {
    id: string
    name: string
    total_jobs: number
    pending_jobs: number
    failed_jobs: number
    failed_job_ids: string
    options: string | null
    cancelled_at: number | null
    created_at: number
    finished_at: number | null
    _count: Job_batchesCountAggregateOutputType | null
    _avg: Job_batchesAvgAggregateOutputType | null
    _sum: Job_batchesSumAggregateOutputType | null
    _min: Job_batchesMinAggregateOutputType | null
    _max: Job_batchesMaxAggregateOutputType | null
  }

  type GetJob_batchesGroupByPayload<T extends job_batchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_batchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_batchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_batchesGroupByOutputType[P]>
            : GetScalarType<T[P], Job_batchesGroupByOutputType[P]>
        }
      >
    >


  export type job_batchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    total_jobs?: boolean
    pending_jobs?: boolean
    failed_jobs?: boolean
    failed_job_ids?: boolean
    options?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    finished_at?: boolean
  }, ExtArgs["result"]["job_batches"]>



  export type job_batchesSelectScalar = {
    id?: boolean
    name?: boolean
    total_jobs?: boolean
    pending_jobs?: boolean
    failed_jobs?: boolean
    failed_job_ids?: boolean
    options?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    finished_at?: boolean
  }

  export type job_batchesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "total_jobs" | "pending_jobs" | "failed_jobs" | "failed_job_ids" | "options" | "cancelled_at" | "created_at" | "finished_at", ExtArgs["result"]["job_batches"]>

  export type $job_batchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_batches"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      total_jobs: number
      pending_jobs: number
      failed_jobs: number
      failed_job_ids: string
      options: string | null
      cancelled_at: number | null
      created_at: number
      finished_at: number | null
    }, ExtArgs["result"]["job_batches"]>
    composites: {}
  }

  type job_batchesGetPayload<S extends boolean | null | undefined | job_batchesDefaultArgs> = $Result.GetResult<Prisma.$job_batchesPayload, S>

  type job_batchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_batchesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_batchesCountAggregateInputType | true
    }

  export interface job_batchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_batches'], meta: { name: 'job_batches' } }
    /**
     * Find zero or one Job_batches that matches the filter.
     * @param {job_batchesFindUniqueArgs} args - Arguments to find a Job_batches
     * @example
     * // Get one Job_batches
     * const job_batches = await prisma.job_batches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_batchesFindUniqueArgs>(args: SelectSubset<T, job_batchesFindUniqueArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_batches that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_batchesFindUniqueOrThrowArgs} args - Arguments to find a Job_batches
     * @example
     * // Get one Job_batches
     * const job_batches = await prisma.job_batches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_batchesFindUniqueOrThrowArgs>(args: SelectSubset<T, job_batchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesFindFirstArgs} args - Arguments to find a Job_batches
     * @example
     * // Get one Job_batches
     * const job_batches = await prisma.job_batches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_batchesFindFirstArgs>(args?: SelectSubset<T, job_batchesFindFirstArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_batches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesFindFirstOrThrowArgs} args - Arguments to find a Job_batches
     * @example
     * // Get one Job_batches
     * const job_batches = await prisma.job_batches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_batchesFindFirstOrThrowArgs>(args?: SelectSubset<T, job_batchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_batches
     * const job_batches = await prisma.job_batches.findMany()
     * 
     * // Get first 10 Job_batches
     * const job_batches = await prisma.job_batches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const job_batchesWithIdOnly = await prisma.job_batches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends job_batchesFindManyArgs>(args?: SelectSubset<T, job_batchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_batches.
     * @param {job_batchesCreateArgs} args - Arguments to create a Job_batches.
     * @example
     * // Create one Job_batches
     * const Job_batches = await prisma.job_batches.create({
     *   data: {
     *     // ... data to create a Job_batches
     *   }
     * })
     * 
     */
    create<T extends job_batchesCreateArgs>(args: SelectSubset<T, job_batchesCreateArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_batches.
     * @param {job_batchesCreateManyArgs} args - Arguments to create many Job_batches.
     * @example
     * // Create many Job_batches
     * const job_batches = await prisma.job_batches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_batchesCreateManyArgs>(args?: SelectSubset<T, job_batchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Job_batches.
     * @param {job_batchesDeleteArgs} args - Arguments to delete one Job_batches.
     * @example
     * // Delete one Job_batches
     * const Job_batches = await prisma.job_batches.delete({
     *   where: {
     *     // ... filter to delete one Job_batches
     *   }
     * })
     * 
     */
    delete<T extends job_batchesDeleteArgs>(args: SelectSubset<T, job_batchesDeleteArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_batches.
     * @param {job_batchesUpdateArgs} args - Arguments to update one Job_batches.
     * @example
     * // Update one Job_batches
     * const job_batches = await prisma.job_batches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_batchesUpdateArgs>(args: SelectSubset<T, job_batchesUpdateArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_batches.
     * @param {job_batchesDeleteManyArgs} args - Arguments to filter Job_batches to delete.
     * @example
     * // Delete a few Job_batches
     * const { count } = await prisma.job_batches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_batchesDeleteManyArgs>(args?: SelectSubset<T, job_batchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_batches
     * const job_batches = await prisma.job_batches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_batchesUpdateManyArgs>(args: SelectSubset<T, job_batchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Job_batches.
     * @param {job_batchesUpsertArgs} args - Arguments to update or create a Job_batches.
     * @example
     * // Update or create a Job_batches
     * const job_batches = await prisma.job_batches.upsert({
     *   create: {
     *     // ... data to create a Job_batches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_batches we want to update
     *   }
     * })
     */
    upsert<T extends job_batchesUpsertArgs>(args: SelectSubset<T, job_batchesUpsertArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesCountArgs} args - Arguments to filter Job_batches to count.
     * @example
     * // Count the number of Job_batches
     * const count = await prisma.job_batches.count({
     *   where: {
     *     // ... the filter for the Job_batches we want to count
     *   }
     * })
    **/
    count<T extends job_batchesCountArgs>(
      args?: Subset<T, job_batchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_batchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_batchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_batchesAggregateArgs>(args: Subset<T, Job_batchesAggregateArgs>): Prisma.PrismaPromise<GetJob_batchesAggregateType<T>>

    /**
     * Group by Job_batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_batchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_batchesGroupByArgs['orderBy'] }
        : { orderBy?: job_batchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_batchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_batchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_batches model
   */
  readonly fields: job_batchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_batches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_batchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_batches model
   */
  interface job_batchesFieldRefs {
    readonly id: FieldRef<"job_batches", 'String'>
    readonly name: FieldRef<"job_batches", 'String'>
    readonly total_jobs: FieldRef<"job_batches", 'Int'>
    readonly pending_jobs: FieldRef<"job_batches", 'Int'>
    readonly failed_jobs: FieldRef<"job_batches", 'Int'>
    readonly failed_job_ids: FieldRef<"job_batches", 'String'>
    readonly options: FieldRef<"job_batches", 'String'>
    readonly cancelled_at: FieldRef<"job_batches", 'Int'>
    readonly created_at: FieldRef<"job_batches", 'Int'>
    readonly finished_at: FieldRef<"job_batches", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * job_batches findUnique
   */
  export type job_batchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter, which job_batches to fetch.
     */
    where: job_batchesWhereUniqueInput
  }

  /**
   * job_batches findUniqueOrThrow
   */
  export type job_batchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter, which job_batches to fetch.
     */
    where: job_batchesWhereUniqueInput
  }

  /**
   * job_batches findFirst
   */
  export type job_batchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter, which job_batches to fetch.
     */
    where?: job_batchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_batches to fetch.
     */
    orderBy?: job_batchesOrderByWithRelationInput | job_batchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_batches.
     */
    cursor?: job_batchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_batches.
     */
    distinct?: Job_batchesScalarFieldEnum | Job_batchesScalarFieldEnum[]
  }

  /**
   * job_batches findFirstOrThrow
   */
  export type job_batchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter, which job_batches to fetch.
     */
    where?: job_batchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_batches to fetch.
     */
    orderBy?: job_batchesOrderByWithRelationInput | job_batchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_batches.
     */
    cursor?: job_batchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_batches.
     */
    distinct?: Job_batchesScalarFieldEnum | Job_batchesScalarFieldEnum[]
  }

  /**
   * job_batches findMany
   */
  export type job_batchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter, which job_batches to fetch.
     */
    where?: job_batchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_batches to fetch.
     */
    orderBy?: job_batchesOrderByWithRelationInput | job_batchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_batches.
     */
    cursor?: job_batchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_batches.
     */
    skip?: number
    distinct?: Job_batchesScalarFieldEnum | Job_batchesScalarFieldEnum[]
  }

  /**
   * job_batches create
   */
  export type job_batchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * The data needed to create a job_batches.
     */
    data: XOR<job_batchesCreateInput, job_batchesUncheckedCreateInput>
  }

  /**
   * job_batches createMany
   */
  export type job_batchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_batches.
     */
    data: job_batchesCreateManyInput | job_batchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_batches update
   */
  export type job_batchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * The data needed to update a job_batches.
     */
    data: XOR<job_batchesUpdateInput, job_batchesUncheckedUpdateInput>
    /**
     * Choose, which job_batches to update.
     */
    where: job_batchesWhereUniqueInput
  }

  /**
   * job_batches updateMany
   */
  export type job_batchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_batches.
     */
    data: XOR<job_batchesUpdateManyMutationInput, job_batchesUncheckedUpdateManyInput>
    /**
     * Filter which job_batches to update
     */
    where?: job_batchesWhereInput
    /**
     * Limit how many job_batches to update.
     */
    limit?: number
  }

  /**
   * job_batches upsert
   */
  export type job_batchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * The filter to search for the job_batches to update in case it exists.
     */
    where: job_batchesWhereUniqueInput
    /**
     * In case the job_batches found by the `where` argument doesn't exist, create a new job_batches with this data.
     */
    create: XOR<job_batchesCreateInput, job_batchesUncheckedCreateInput>
    /**
     * In case the job_batches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_batchesUpdateInput, job_batchesUncheckedUpdateInput>
  }

  /**
   * job_batches delete
   */
  export type job_batchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter which job_batches to delete.
     */
    where: job_batchesWhereUniqueInput
  }

  /**
   * job_batches deleteMany
   */
  export type job_batchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_batches to delete
     */
    where?: job_batchesWhereInput
    /**
     * Limit how many job_batches to delete.
     */
    limit?: number
  }

  /**
   * job_batches without action
   */
  export type job_batchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
  }


  /**
   * Model jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    id: number | null
    attempts: number | null
    reserved_at: number | null
    available_at: number | null
    created_at: number | null
  }

  export type JobsSumAggregateOutputType = {
    id: bigint | null
    attempts: number | null
    reserved_at: number | null
    available_at: number | null
    created_at: number | null
  }

  export type JobsMinAggregateOutputType = {
    id: bigint | null
    queue: string | null
    payload: string | null
    attempts: number | null
    reserved_at: number | null
    available_at: number | null
    created_at: number | null
  }

  export type JobsMaxAggregateOutputType = {
    id: bigint | null
    queue: string | null
    payload: string | null
    attempts: number | null
    reserved_at: number | null
    available_at: number | null
    created_at: number | null
  }

  export type JobsCountAggregateOutputType = {
    id: number
    queue: number
    payload: number
    attempts: number
    reserved_at: number
    available_at: number
    created_at: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    id?: true
    attempts?: true
    reserved_at?: true
    available_at?: true
    created_at?: true
  }

  export type JobsSumAggregateInputType = {
    id?: true
    attempts?: true
    reserved_at?: true
    available_at?: true
    created_at?: true
  }

  export type JobsMinAggregateInputType = {
    id?: true
    queue?: true
    payload?: true
    attempts?: true
    reserved_at?: true
    available_at?: true
    created_at?: true
  }

  export type JobsMaxAggregateInputType = {
    id?: true
    queue?: true
    payload?: true
    attempts?: true
    reserved_at?: true
    available_at?: true
    created_at?: true
  }

  export type JobsCountAggregateInputType = {
    id?: true
    queue?: true
    payload?: true
    attempts?: true
    reserved_at?: true
    available_at?: true
    created_at?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to aggregate.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithAggregationInput | jobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    id: bigint
    queue: string
    payload: string
    attempts: number
    reserved_at: number | null
    available_at: number
    created_at: number
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queue?: boolean
    payload?: boolean
    attempts?: boolean
    reserved_at?: boolean
    available_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["jobs"]>



  export type jobsSelectScalar = {
    id?: boolean
    queue?: boolean
    payload?: boolean
    attempts?: boolean
    reserved_at?: boolean
    available_at?: boolean
    created_at?: boolean
  }

  export type jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queue" | "payload" | "attempts" | "reserved_at" | "available_at" | "created_at", ExtArgs["result"]["jobs"]>

  export type $jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      queue: string
      payload: string
      attempts: number
      reserved_at: number | null
      available_at: number
      created_at: number
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }

  type jobsGetPayload<S extends boolean | null | undefined | jobsDefaultArgs> = $Result.GetResult<Prisma.$jobsPayload, S>

  type jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobs'], meta: { name: 'jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {jobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobsFindUniqueArgs>(args: SelectSubset<T, jobsFindUniqueArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobsFindFirstArgs>(args?: SelectSubset<T, jobsFindFirstArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobsWithIdOnly = await prisma.jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobsFindManyArgs>(args?: SelectSubset<T, jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobs.
     * @param {jobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
     */
    create<T extends jobsCreateArgs>(args: SelectSubset<T, jobsCreateArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {jobsCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobsCreateManyArgs>(args?: SelectSubset<T, jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobs.
     * @param {jobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
     */
    delete<T extends jobsDeleteArgs>(args: SelectSubset<T, jobsDeleteArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobs.
     * @param {jobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobsUpdateArgs>(args: SelectSubset<T, jobsUpdateArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {jobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobsDeleteManyArgs>(args?: SelectSubset<T, jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobsUpdateManyArgs>(args: SelectSubset<T, jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobs.
     * @param {jobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     */
    upsert<T extends jobsUpsertArgs>(args: SelectSubset<T, jobsUpsertArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends jobsCountArgs>(
      args?: Subset<T, jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobsGroupByArgs['orderBy'] }
        : { orderBy?: jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobs model
   */
  readonly fields: jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobs model
   */
  interface jobsFieldRefs {
    readonly id: FieldRef<"jobs", 'BigInt'>
    readonly queue: FieldRef<"jobs", 'String'>
    readonly payload: FieldRef<"jobs", 'String'>
    readonly attempts: FieldRef<"jobs", 'Int'>
    readonly reserved_at: FieldRef<"jobs", 'Int'>
    readonly available_at: FieldRef<"jobs", 'Int'>
    readonly created_at: FieldRef<"jobs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * jobs findUnique
   */
  export type jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs findUniqueOrThrow
   */
  export type jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs findFirst
   */
  export type jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs findFirstOrThrow
   */
  export type jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs findMany
   */
  export type jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs create
   */
  export type jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The data needed to create a jobs.
     */
    data: XOR<jobsCreateInput, jobsUncheckedCreateInput>
  }

  /**
   * jobs createMany
   */
  export type jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobs.
     */
    data: jobsCreateManyInput | jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobs update
   */
  export type jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The data needed to update a jobs.
     */
    data: XOR<jobsUpdateInput, jobsUncheckedUpdateInput>
    /**
     * Choose, which jobs to update.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs updateMany
   */
  export type jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobs.
     */
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
  }

  /**
   * jobs upsert
   */
  export type jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The filter to search for the jobs to update in case it exists.
     */
    where: jobsWhereUniqueInput
    /**
     * In case the jobs found by the `where` argument doesn't exist, create a new jobs with this data.
     */
    create: XOR<jobsCreateInput, jobsUncheckedCreateInput>
    /**
     * In case the jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobsUpdateInput, jobsUncheckedUpdateInput>
  }

  /**
   * jobs delete
   */
  export type jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter which jobs to delete.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs deleteMany
   */
  export type jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to delete
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to delete.
     */
    limit?: number
  }

  /**
   * jobs without action
   */
  export type jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
  }


  /**
   * Model metodos_de_pago
   */

  export type AggregateMetodos_de_pago = {
    _count: Metodos_de_pagoCountAggregateOutputType | null
    _avg: Metodos_de_pagoAvgAggregateOutputType | null
    _sum: Metodos_de_pagoSumAggregateOutputType | null
    _min: Metodos_de_pagoMinAggregateOutputType | null
    _max: Metodos_de_pagoMaxAggregateOutputType | null
  }

  export type Metodos_de_pagoAvgAggregateOutputType = {
    id: number | null
  }

  export type Metodos_de_pagoSumAggregateOutputType = {
    id: bigint | null
  }

  export type Metodos_de_pagoMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Metodos_de_pagoMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Metodos_de_pagoCountAggregateOutputType = {
    id: number
    label: number
    estatus: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Metodos_de_pagoAvgAggregateInputType = {
    id?: true
  }

  export type Metodos_de_pagoSumAggregateInputType = {
    id?: true
  }

  export type Metodos_de_pagoMinAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Metodos_de_pagoMaxAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Metodos_de_pagoCountAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Metodos_de_pagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which metodos_de_pago to aggregate.
     */
    where?: metodos_de_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodos_de_pagos to fetch.
     */
    orderBy?: metodos_de_pagoOrderByWithRelationInput | metodos_de_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: metodos_de_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodos_de_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodos_de_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned metodos_de_pagos
    **/
    _count?: true | Metodos_de_pagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Metodos_de_pagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Metodos_de_pagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Metodos_de_pagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Metodos_de_pagoMaxAggregateInputType
  }

  export type GetMetodos_de_pagoAggregateType<T extends Metodos_de_pagoAggregateArgs> = {
        [P in keyof T & keyof AggregateMetodos_de_pago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetodos_de_pago[P]>
      : GetScalarType<T[P], AggregateMetodos_de_pago[P]>
  }




  export type metodos_de_pagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: metodos_de_pagoWhereInput
    orderBy?: metodos_de_pagoOrderByWithAggregationInput | metodos_de_pagoOrderByWithAggregationInput[]
    by: Metodos_de_pagoScalarFieldEnum[] | Metodos_de_pagoScalarFieldEnum
    having?: metodos_de_pagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Metodos_de_pagoCountAggregateInputType | true
    _avg?: Metodos_de_pagoAvgAggregateInputType
    _sum?: Metodos_de_pagoSumAggregateInputType
    _min?: Metodos_de_pagoMinAggregateInputType
    _max?: Metodos_de_pagoMaxAggregateInputType
  }

  export type Metodos_de_pagoGroupByOutputType = {
    id: bigint
    label: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: Metodos_de_pagoCountAggregateOutputType | null
    _avg: Metodos_de_pagoAvgAggregateOutputType | null
    _sum: Metodos_de_pagoSumAggregateOutputType | null
    _min: Metodos_de_pagoMinAggregateOutputType | null
    _max: Metodos_de_pagoMaxAggregateOutputType | null
  }

  type GetMetodos_de_pagoGroupByPayload<T extends metodos_de_pagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Metodos_de_pagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Metodos_de_pagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Metodos_de_pagoGroupByOutputType[P]>
            : GetScalarType<T[P], Metodos_de_pagoGroupByOutputType[P]>
        }
      >
    >


  export type metodos_de_pagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    polizas?: boolean | metodos_de_pago$polizasArgs<ExtArgs>
    _count?: boolean | Metodos_de_pagoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metodos_de_pago"]>



  export type metodos_de_pagoSelectScalar = {
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type metodos_de_pagoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "estatus" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["metodos_de_pago"]>
  export type metodos_de_pagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | metodos_de_pago$polizasArgs<ExtArgs>
    _count?: boolean | Metodos_de_pagoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $metodos_de_pagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "metodos_de_pago"
    objects: {
      polizas: Prisma.$polizasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["metodos_de_pago"]>
    composites: {}
  }

  type metodos_de_pagoGetPayload<S extends boolean | null | undefined | metodos_de_pagoDefaultArgs> = $Result.GetResult<Prisma.$metodos_de_pagoPayload, S>

  type metodos_de_pagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<metodos_de_pagoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Metodos_de_pagoCountAggregateInputType | true
    }

  export interface metodos_de_pagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['metodos_de_pago'], meta: { name: 'metodos_de_pago' } }
    /**
     * Find zero or one Metodos_de_pago that matches the filter.
     * @param {metodos_de_pagoFindUniqueArgs} args - Arguments to find a Metodos_de_pago
     * @example
     * // Get one Metodos_de_pago
     * const metodos_de_pago = await prisma.metodos_de_pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends metodos_de_pagoFindUniqueArgs>(args: SelectSubset<T, metodos_de_pagoFindUniqueArgs<ExtArgs>>): Prisma__metodos_de_pagoClient<$Result.GetResult<Prisma.$metodos_de_pagoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Metodos_de_pago that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {metodos_de_pagoFindUniqueOrThrowArgs} args - Arguments to find a Metodos_de_pago
     * @example
     * // Get one Metodos_de_pago
     * const metodos_de_pago = await prisma.metodos_de_pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends metodos_de_pagoFindUniqueOrThrowArgs>(args: SelectSubset<T, metodos_de_pagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__metodos_de_pagoClient<$Result.GetResult<Prisma.$metodos_de_pagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metodos_de_pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodos_de_pagoFindFirstArgs} args - Arguments to find a Metodos_de_pago
     * @example
     * // Get one Metodos_de_pago
     * const metodos_de_pago = await prisma.metodos_de_pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends metodos_de_pagoFindFirstArgs>(args?: SelectSubset<T, metodos_de_pagoFindFirstArgs<ExtArgs>>): Prisma__metodos_de_pagoClient<$Result.GetResult<Prisma.$metodos_de_pagoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metodos_de_pago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodos_de_pagoFindFirstOrThrowArgs} args - Arguments to find a Metodos_de_pago
     * @example
     * // Get one Metodos_de_pago
     * const metodos_de_pago = await prisma.metodos_de_pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends metodos_de_pagoFindFirstOrThrowArgs>(args?: SelectSubset<T, metodos_de_pagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__metodos_de_pagoClient<$Result.GetResult<Prisma.$metodos_de_pagoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Metodos_de_pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodos_de_pagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metodos_de_pagos
     * const metodos_de_pagos = await prisma.metodos_de_pago.findMany()
     * 
     * // Get first 10 Metodos_de_pagos
     * const metodos_de_pagos = await prisma.metodos_de_pago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metodos_de_pagoWithIdOnly = await prisma.metodos_de_pago.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends metodos_de_pagoFindManyArgs>(args?: SelectSubset<T, metodos_de_pagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metodos_de_pagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Metodos_de_pago.
     * @param {metodos_de_pagoCreateArgs} args - Arguments to create a Metodos_de_pago.
     * @example
     * // Create one Metodos_de_pago
     * const Metodos_de_pago = await prisma.metodos_de_pago.create({
     *   data: {
     *     // ... data to create a Metodos_de_pago
     *   }
     * })
     * 
     */
    create<T extends metodos_de_pagoCreateArgs>(args: SelectSubset<T, metodos_de_pagoCreateArgs<ExtArgs>>): Prisma__metodos_de_pagoClient<$Result.GetResult<Prisma.$metodos_de_pagoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Metodos_de_pagos.
     * @param {metodos_de_pagoCreateManyArgs} args - Arguments to create many Metodos_de_pagos.
     * @example
     * // Create many Metodos_de_pagos
     * const metodos_de_pago = await prisma.metodos_de_pago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends metodos_de_pagoCreateManyArgs>(args?: SelectSubset<T, metodos_de_pagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Metodos_de_pago.
     * @param {metodos_de_pagoDeleteArgs} args - Arguments to delete one Metodos_de_pago.
     * @example
     * // Delete one Metodos_de_pago
     * const Metodos_de_pago = await prisma.metodos_de_pago.delete({
     *   where: {
     *     // ... filter to delete one Metodos_de_pago
     *   }
     * })
     * 
     */
    delete<T extends metodos_de_pagoDeleteArgs>(args: SelectSubset<T, metodos_de_pagoDeleteArgs<ExtArgs>>): Prisma__metodos_de_pagoClient<$Result.GetResult<Prisma.$metodos_de_pagoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Metodos_de_pago.
     * @param {metodos_de_pagoUpdateArgs} args - Arguments to update one Metodos_de_pago.
     * @example
     * // Update one Metodos_de_pago
     * const metodos_de_pago = await prisma.metodos_de_pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends metodos_de_pagoUpdateArgs>(args: SelectSubset<T, metodos_de_pagoUpdateArgs<ExtArgs>>): Prisma__metodos_de_pagoClient<$Result.GetResult<Prisma.$metodos_de_pagoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Metodos_de_pagos.
     * @param {metodos_de_pagoDeleteManyArgs} args - Arguments to filter Metodos_de_pagos to delete.
     * @example
     * // Delete a few Metodos_de_pagos
     * const { count } = await prisma.metodos_de_pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends metodos_de_pagoDeleteManyArgs>(args?: SelectSubset<T, metodos_de_pagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metodos_de_pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodos_de_pagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metodos_de_pagos
     * const metodos_de_pago = await prisma.metodos_de_pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends metodos_de_pagoUpdateManyArgs>(args: SelectSubset<T, metodos_de_pagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Metodos_de_pago.
     * @param {metodos_de_pagoUpsertArgs} args - Arguments to update or create a Metodos_de_pago.
     * @example
     * // Update or create a Metodos_de_pago
     * const metodos_de_pago = await prisma.metodos_de_pago.upsert({
     *   create: {
     *     // ... data to create a Metodos_de_pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metodos_de_pago we want to update
     *   }
     * })
     */
    upsert<T extends metodos_de_pagoUpsertArgs>(args: SelectSubset<T, metodos_de_pagoUpsertArgs<ExtArgs>>): Prisma__metodos_de_pagoClient<$Result.GetResult<Prisma.$metodos_de_pagoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Metodos_de_pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodos_de_pagoCountArgs} args - Arguments to filter Metodos_de_pagos to count.
     * @example
     * // Count the number of Metodos_de_pagos
     * const count = await prisma.metodos_de_pago.count({
     *   where: {
     *     // ... the filter for the Metodos_de_pagos we want to count
     *   }
     * })
    **/
    count<T extends metodos_de_pagoCountArgs>(
      args?: Subset<T, metodos_de_pagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Metodos_de_pagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metodos_de_pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Metodos_de_pagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Metodos_de_pagoAggregateArgs>(args: Subset<T, Metodos_de_pagoAggregateArgs>): Prisma.PrismaPromise<GetMetodos_de_pagoAggregateType<T>>

    /**
     * Group by Metodos_de_pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metodos_de_pagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends metodos_de_pagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: metodos_de_pagoGroupByArgs['orderBy'] }
        : { orderBy?: metodos_de_pagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, metodos_de_pagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetodos_de_pagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the metodos_de_pago model
   */
  readonly fields: metodos_de_pagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for metodos_de_pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__metodos_de_pagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    polizas<T extends metodos_de_pago$polizasArgs<ExtArgs> = {}>(args?: Subset<T, metodos_de_pago$polizasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the metodos_de_pago model
   */
  interface metodos_de_pagoFieldRefs {
    readonly id: FieldRef<"metodos_de_pago", 'BigInt'>
    readonly label: FieldRef<"metodos_de_pago", 'String'>
    readonly estatus: FieldRef<"metodos_de_pago", 'Boolean'>
    readonly created_at: FieldRef<"metodos_de_pago", 'DateTime'>
    readonly updated_at: FieldRef<"metodos_de_pago", 'DateTime'>
    readonly deleted_at: FieldRef<"metodos_de_pago", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * metodos_de_pago findUnique
   */
  export type metodos_de_pagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metodos_de_pago
     */
    select?: metodos_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metodos_de_pago
     */
    omit?: metodos_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metodos_de_pagoInclude<ExtArgs> | null
    /**
     * Filter, which metodos_de_pago to fetch.
     */
    where: metodos_de_pagoWhereUniqueInput
  }

  /**
   * metodos_de_pago findUniqueOrThrow
   */
  export type metodos_de_pagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metodos_de_pago
     */
    select?: metodos_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metodos_de_pago
     */
    omit?: metodos_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metodos_de_pagoInclude<ExtArgs> | null
    /**
     * Filter, which metodos_de_pago to fetch.
     */
    where: metodos_de_pagoWhereUniqueInput
  }

  /**
   * metodos_de_pago findFirst
   */
  export type metodos_de_pagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metodos_de_pago
     */
    select?: metodos_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metodos_de_pago
     */
    omit?: metodos_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metodos_de_pagoInclude<ExtArgs> | null
    /**
     * Filter, which metodos_de_pago to fetch.
     */
    where?: metodos_de_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodos_de_pagos to fetch.
     */
    orderBy?: metodos_de_pagoOrderByWithRelationInput | metodos_de_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metodos_de_pagos.
     */
    cursor?: metodos_de_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodos_de_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodos_de_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metodos_de_pagos.
     */
    distinct?: Metodos_de_pagoScalarFieldEnum | Metodos_de_pagoScalarFieldEnum[]
  }

  /**
   * metodos_de_pago findFirstOrThrow
   */
  export type metodos_de_pagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metodos_de_pago
     */
    select?: metodos_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metodos_de_pago
     */
    omit?: metodos_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metodos_de_pagoInclude<ExtArgs> | null
    /**
     * Filter, which metodos_de_pago to fetch.
     */
    where?: metodos_de_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodos_de_pagos to fetch.
     */
    orderBy?: metodos_de_pagoOrderByWithRelationInput | metodos_de_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metodos_de_pagos.
     */
    cursor?: metodos_de_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodos_de_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodos_de_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metodos_de_pagos.
     */
    distinct?: Metodos_de_pagoScalarFieldEnum | Metodos_de_pagoScalarFieldEnum[]
  }

  /**
   * metodos_de_pago findMany
   */
  export type metodos_de_pagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metodos_de_pago
     */
    select?: metodos_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metodos_de_pago
     */
    omit?: metodos_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metodos_de_pagoInclude<ExtArgs> | null
    /**
     * Filter, which metodos_de_pagos to fetch.
     */
    where?: metodos_de_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metodos_de_pagos to fetch.
     */
    orderBy?: metodos_de_pagoOrderByWithRelationInput | metodos_de_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing metodos_de_pagos.
     */
    cursor?: metodos_de_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metodos_de_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metodos_de_pagos.
     */
    skip?: number
    distinct?: Metodos_de_pagoScalarFieldEnum | Metodos_de_pagoScalarFieldEnum[]
  }

  /**
   * metodos_de_pago create
   */
  export type metodos_de_pagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metodos_de_pago
     */
    select?: metodos_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metodos_de_pago
     */
    omit?: metodos_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metodos_de_pagoInclude<ExtArgs> | null
    /**
     * The data needed to create a metodos_de_pago.
     */
    data: XOR<metodos_de_pagoCreateInput, metodos_de_pagoUncheckedCreateInput>
  }

  /**
   * metodos_de_pago createMany
   */
  export type metodos_de_pagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many metodos_de_pagos.
     */
    data: metodos_de_pagoCreateManyInput | metodos_de_pagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * metodos_de_pago update
   */
  export type metodos_de_pagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metodos_de_pago
     */
    select?: metodos_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metodos_de_pago
     */
    omit?: metodos_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metodos_de_pagoInclude<ExtArgs> | null
    /**
     * The data needed to update a metodos_de_pago.
     */
    data: XOR<metodos_de_pagoUpdateInput, metodos_de_pagoUncheckedUpdateInput>
    /**
     * Choose, which metodos_de_pago to update.
     */
    where: metodos_de_pagoWhereUniqueInput
  }

  /**
   * metodos_de_pago updateMany
   */
  export type metodos_de_pagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update metodos_de_pagos.
     */
    data: XOR<metodos_de_pagoUpdateManyMutationInput, metodos_de_pagoUncheckedUpdateManyInput>
    /**
     * Filter which metodos_de_pagos to update
     */
    where?: metodos_de_pagoWhereInput
    /**
     * Limit how many metodos_de_pagos to update.
     */
    limit?: number
  }

  /**
   * metodos_de_pago upsert
   */
  export type metodos_de_pagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metodos_de_pago
     */
    select?: metodos_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metodos_de_pago
     */
    omit?: metodos_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metodos_de_pagoInclude<ExtArgs> | null
    /**
     * The filter to search for the metodos_de_pago to update in case it exists.
     */
    where: metodos_de_pagoWhereUniqueInput
    /**
     * In case the metodos_de_pago found by the `where` argument doesn't exist, create a new metodos_de_pago with this data.
     */
    create: XOR<metodos_de_pagoCreateInput, metodos_de_pagoUncheckedCreateInput>
    /**
     * In case the metodos_de_pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<metodos_de_pagoUpdateInput, metodos_de_pagoUncheckedUpdateInput>
  }

  /**
   * metodos_de_pago delete
   */
  export type metodos_de_pagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metodos_de_pago
     */
    select?: metodos_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metodos_de_pago
     */
    omit?: metodos_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metodos_de_pagoInclude<ExtArgs> | null
    /**
     * Filter which metodos_de_pago to delete.
     */
    where: metodos_de_pagoWhereUniqueInput
  }

  /**
   * metodos_de_pago deleteMany
   */
  export type metodos_de_pagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which metodos_de_pagos to delete
     */
    where?: metodos_de_pagoWhereInput
    /**
     * Limit how many metodos_de_pagos to delete.
     */
    limit?: number
  }

  /**
   * metodos_de_pago.polizas
   */
  export type metodos_de_pago$polizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    where?: polizasWhereInput
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    cursor?: polizasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * metodos_de_pago without action
   */
  export type metodos_de_pagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the metodos_de_pago
     */
    select?: metodos_de_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the metodos_de_pago
     */
    omit?: metodos_de_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metodos_de_pagoInclude<ExtArgs> | null
  }


  /**
   * Model migrations
   */

  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    migration: number
    batch: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
    _all?: true
  }

  export type MigrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to aggregate.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationsWhereInput
    orderBy?: migrationsOrderByWithAggregationInput | migrationsOrderByWithAggregationInput[]
    by: MigrationsScalarFieldEnum[] | MigrationsScalarFieldEnum
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }

  export type MigrationsGroupByOutputType = {
    id: number
    migration: string
    batch: number
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    migration?: boolean
    batch?: boolean
  }, ExtArgs["result"]["migrations"]>



  export type migrationsSelectScalar = {
    id?: boolean
    migration?: boolean
    batch?: boolean
  }

  export type migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "migration" | "batch", ExtArgs["result"]["migrations"]>

  export type $migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      migration: string
      batch: number
    }, ExtArgs["result"]["migrations"]>
    composites: {}
  }

  type migrationsGetPayload<S extends boolean | null | undefined | migrationsDefaultArgs> = $Result.GetResult<Prisma.$migrationsPayload, S>

  type migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migrations'], meta: { name: 'migrations' } }
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends migrationsFindUniqueArgs>(args: SelectSubset<T, migrationsFindUniqueArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends migrationsFindFirstArgs>(args?: SelectSubset<T, migrationsFindFirstArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends migrationsFindManyArgs>(args?: SelectSubset<T, migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
     */
    create<T extends migrationsCreateArgs>(args: SelectSubset<T, migrationsCreateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Migrations.
     * @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends migrationsCreateManyArgs>(args?: SelectSubset<T, migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
     */
    delete<T extends migrationsDeleteArgs>(args: SelectSubset<T, migrationsDeleteArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends migrationsUpdateArgs>(args: SelectSubset<T, migrationsUpdateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends migrationsDeleteManyArgs>(args?: SelectSubset<T, migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends migrationsUpdateManyArgs>(args: SelectSubset<T, migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
     */
    upsert<T extends migrationsUpsertArgs>(args: SelectSubset<T, migrationsUpsertArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationsGroupByArgs['orderBy'] }
        : { orderBy?: migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migrations model
   */
  readonly fields: migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the migrations model
   */
  interface migrationsFieldRefs {
    readonly id: FieldRef<"migrations", 'Int'>
    readonly migration: FieldRef<"migrations", 'String'>
    readonly batch: FieldRef<"migrations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * migrations findUnique
   */
  export type migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findFirst
   */
  export type migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations create
   */
  export type migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a migrations.
     */
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
  }

  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations update
   */
  export type migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a migrations.
     */
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the migrations to update in case it exists.
     */
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     */
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
  }

  /**
   * migrations delete
   */
  export type migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter which migrations to delete.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to delete.
     */
    limit?: number
  }

  /**
   * migrations without action
   */
  export type migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
  }


  /**
   * Model monedas
   */

  export type AggregateMonedas = {
    _count: MonedasCountAggregateOutputType | null
    _avg: MonedasAvgAggregateOutputType | null
    _sum: MonedasSumAggregateOutputType | null
    _min: MonedasMinAggregateOutputType | null
    _max: MonedasMaxAggregateOutputType | null
  }

  export type MonedasAvgAggregateOutputType = {
    id: number | null
  }

  export type MonedasSumAggregateOutputType = {
    id: bigint | null
  }

  export type MonedasMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type MonedasMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type MonedasCountAggregateOutputType = {
    id: number
    label: number
    estatus: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type MonedasAvgAggregateInputType = {
    id?: true
  }

  export type MonedasSumAggregateInputType = {
    id?: true
  }

  export type MonedasMinAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type MonedasMaxAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type MonedasCountAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type MonedasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monedas to aggregate.
     */
    where?: monedasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monedas to fetch.
     */
    orderBy?: monedasOrderByWithRelationInput | monedasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monedasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monedas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monedas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monedas
    **/
    _count?: true | MonedasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonedasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonedasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonedasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonedasMaxAggregateInputType
  }

  export type GetMonedasAggregateType<T extends MonedasAggregateArgs> = {
        [P in keyof T & keyof AggregateMonedas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonedas[P]>
      : GetScalarType<T[P], AggregateMonedas[P]>
  }




  export type monedasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monedasWhereInput
    orderBy?: monedasOrderByWithAggregationInput | monedasOrderByWithAggregationInput[]
    by: MonedasScalarFieldEnum[] | MonedasScalarFieldEnum
    having?: monedasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonedasCountAggregateInputType | true
    _avg?: MonedasAvgAggregateInputType
    _sum?: MonedasSumAggregateInputType
    _min?: MonedasMinAggregateInputType
    _max?: MonedasMaxAggregateInputType
  }

  export type MonedasGroupByOutputType = {
    id: bigint
    label: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: MonedasCountAggregateOutputType | null
    _avg: MonedasAvgAggregateOutputType | null
    _sum: MonedasSumAggregateOutputType | null
    _min: MonedasMinAggregateOutputType | null
    _max: MonedasMaxAggregateOutputType | null
  }

  type GetMonedasGroupByPayload<T extends monedasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonedasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonedasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonedasGroupByOutputType[P]>
            : GetScalarType<T[P], MonedasGroupByOutputType[P]>
        }
      >
    >


  export type monedasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    polizas?: boolean | monedas$polizasArgs<ExtArgs>
    _count?: boolean | MonedasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monedas"]>



  export type monedasSelectScalar = {
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type monedasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "estatus" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["monedas"]>
  export type monedasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | monedas$polizasArgs<ExtArgs>
    _count?: boolean | MonedasCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $monedasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monedas"
    objects: {
      polizas: Prisma.$polizasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["monedas"]>
    composites: {}
  }

  type monedasGetPayload<S extends boolean | null | undefined | monedasDefaultArgs> = $Result.GetResult<Prisma.$monedasPayload, S>

  type monedasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<monedasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MonedasCountAggregateInputType | true
    }

  export interface monedasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monedas'], meta: { name: 'monedas' } }
    /**
     * Find zero or one Monedas that matches the filter.
     * @param {monedasFindUniqueArgs} args - Arguments to find a Monedas
     * @example
     * // Get one Monedas
     * const monedas = await prisma.monedas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monedasFindUniqueArgs>(args: SelectSubset<T, monedasFindUniqueArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Monedas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {monedasFindUniqueOrThrowArgs} args - Arguments to find a Monedas
     * @example
     * // Get one Monedas
     * const monedas = await prisma.monedas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monedasFindUniqueOrThrowArgs>(args: SelectSubset<T, monedasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Monedas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasFindFirstArgs} args - Arguments to find a Monedas
     * @example
     * // Get one Monedas
     * const monedas = await prisma.monedas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monedasFindFirstArgs>(args?: SelectSubset<T, monedasFindFirstArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Monedas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasFindFirstOrThrowArgs} args - Arguments to find a Monedas
     * @example
     * // Get one Monedas
     * const monedas = await prisma.monedas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monedasFindFirstOrThrowArgs>(args?: SelectSubset<T, monedasFindFirstOrThrowArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Monedas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monedas
     * const monedas = await prisma.monedas.findMany()
     * 
     * // Get first 10 Monedas
     * const monedas = await prisma.monedas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monedasWithIdOnly = await prisma.monedas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends monedasFindManyArgs>(args?: SelectSubset<T, monedasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Monedas.
     * @param {monedasCreateArgs} args - Arguments to create a Monedas.
     * @example
     * // Create one Monedas
     * const Monedas = await prisma.monedas.create({
     *   data: {
     *     // ... data to create a Monedas
     *   }
     * })
     * 
     */
    create<T extends monedasCreateArgs>(args: SelectSubset<T, monedasCreateArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Monedas.
     * @param {monedasCreateManyArgs} args - Arguments to create many Monedas.
     * @example
     * // Create many Monedas
     * const monedas = await prisma.monedas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monedasCreateManyArgs>(args?: SelectSubset<T, monedasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monedas.
     * @param {monedasDeleteArgs} args - Arguments to delete one Monedas.
     * @example
     * // Delete one Monedas
     * const Monedas = await prisma.monedas.delete({
     *   where: {
     *     // ... filter to delete one Monedas
     *   }
     * })
     * 
     */
    delete<T extends monedasDeleteArgs>(args: SelectSubset<T, monedasDeleteArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Monedas.
     * @param {monedasUpdateArgs} args - Arguments to update one Monedas.
     * @example
     * // Update one Monedas
     * const monedas = await prisma.monedas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monedasUpdateArgs>(args: SelectSubset<T, monedasUpdateArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Monedas.
     * @param {monedasDeleteManyArgs} args - Arguments to filter Monedas to delete.
     * @example
     * // Delete a few Monedas
     * const { count } = await prisma.monedas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monedasDeleteManyArgs>(args?: SelectSubset<T, monedasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monedas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monedas
     * const monedas = await prisma.monedas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monedasUpdateManyArgs>(args: SelectSubset<T, monedasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monedas.
     * @param {monedasUpsertArgs} args - Arguments to update or create a Monedas.
     * @example
     * // Update or create a Monedas
     * const monedas = await prisma.monedas.upsert({
     *   create: {
     *     // ... data to create a Monedas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monedas we want to update
     *   }
     * })
     */
    upsert<T extends monedasUpsertArgs>(args: SelectSubset<T, monedasUpsertArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Monedas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasCountArgs} args - Arguments to filter Monedas to count.
     * @example
     * // Count the number of Monedas
     * const count = await prisma.monedas.count({
     *   where: {
     *     // ... the filter for the Monedas we want to count
     *   }
     * })
    **/
    count<T extends monedasCountArgs>(
      args?: Subset<T, monedasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonedasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monedas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonedasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonedasAggregateArgs>(args: Subset<T, MonedasAggregateArgs>): Prisma.PrismaPromise<GetMonedasAggregateType<T>>

    /**
     * Group by Monedas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monedasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monedasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monedasGroupByArgs['orderBy'] }
        : { orderBy?: monedasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monedasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonedasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monedas model
   */
  readonly fields: monedasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monedas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monedasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    polizas<T extends monedas$polizasArgs<ExtArgs> = {}>(args?: Subset<T, monedas$polizasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monedas model
   */
  interface monedasFieldRefs {
    readonly id: FieldRef<"monedas", 'BigInt'>
    readonly label: FieldRef<"monedas", 'String'>
    readonly estatus: FieldRef<"monedas", 'Boolean'>
    readonly created_at: FieldRef<"monedas", 'DateTime'>
    readonly updated_at: FieldRef<"monedas", 'DateTime'>
    readonly deleted_at: FieldRef<"monedas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * monedas findUnique
   */
  export type monedasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the monedas
     */
    omit?: monedasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter, which monedas to fetch.
     */
    where: monedasWhereUniqueInput
  }

  /**
   * monedas findUniqueOrThrow
   */
  export type monedasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the monedas
     */
    omit?: monedasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter, which monedas to fetch.
     */
    where: monedasWhereUniqueInput
  }

  /**
   * monedas findFirst
   */
  export type monedasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the monedas
     */
    omit?: monedasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter, which monedas to fetch.
     */
    where?: monedasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monedas to fetch.
     */
    orderBy?: monedasOrderByWithRelationInput | monedasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monedas.
     */
    cursor?: monedasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monedas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monedas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monedas.
     */
    distinct?: MonedasScalarFieldEnum | MonedasScalarFieldEnum[]
  }

  /**
   * monedas findFirstOrThrow
   */
  export type monedasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the monedas
     */
    omit?: monedasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter, which monedas to fetch.
     */
    where?: monedasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monedas to fetch.
     */
    orderBy?: monedasOrderByWithRelationInput | monedasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monedas.
     */
    cursor?: monedasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monedas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monedas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monedas.
     */
    distinct?: MonedasScalarFieldEnum | MonedasScalarFieldEnum[]
  }

  /**
   * monedas findMany
   */
  export type monedasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the monedas
     */
    omit?: monedasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter, which monedas to fetch.
     */
    where?: monedasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monedas to fetch.
     */
    orderBy?: monedasOrderByWithRelationInput | monedasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monedas.
     */
    cursor?: monedasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monedas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monedas.
     */
    skip?: number
    distinct?: MonedasScalarFieldEnum | MonedasScalarFieldEnum[]
  }

  /**
   * monedas create
   */
  export type monedasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the monedas
     */
    omit?: monedasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * The data needed to create a monedas.
     */
    data: XOR<monedasCreateInput, monedasUncheckedCreateInput>
  }

  /**
   * monedas createMany
   */
  export type monedasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monedas.
     */
    data: monedasCreateManyInput | monedasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monedas update
   */
  export type monedasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the monedas
     */
    omit?: monedasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * The data needed to update a monedas.
     */
    data: XOR<monedasUpdateInput, monedasUncheckedUpdateInput>
    /**
     * Choose, which monedas to update.
     */
    where: monedasWhereUniqueInput
  }

  /**
   * monedas updateMany
   */
  export type monedasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monedas.
     */
    data: XOR<monedasUpdateManyMutationInput, monedasUncheckedUpdateManyInput>
    /**
     * Filter which monedas to update
     */
    where?: monedasWhereInput
    /**
     * Limit how many monedas to update.
     */
    limit?: number
  }

  /**
   * monedas upsert
   */
  export type monedasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the monedas
     */
    omit?: monedasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * The filter to search for the monedas to update in case it exists.
     */
    where: monedasWhereUniqueInput
    /**
     * In case the monedas found by the `where` argument doesn't exist, create a new monedas with this data.
     */
    create: XOR<monedasCreateInput, monedasUncheckedCreateInput>
    /**
     * In case the monedas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monedasUpdateInput, monedasUncheckedUpdateInput>
  }

  /**
   * monedas delete
   */
  export type monedasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the monedas
     */
    omit?: monedasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
    /**
     * Filter which monedas to delete.
     */
    where: monedasWhereUniqueInput
  }

  /**
   * monedas deleteMany
   */
  export type monedasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monedas to delete
     */
    where?: monedasWhereInput
    /**
     * Limit how many monedas to delete.
     */
    limit?: number
  }

  /**
   * monedas.polizas
   */
  export type monedas$polizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    where?: polizasWhereInput
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    cursor?: polizasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * monedas without action
   */
  export type monedasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monedas
     */
    select?: monedasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the monedas
     */
    omit?: monedasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: monedasInclude<ExtArgs> | null
  }


  /**
   * Model password_reset_tokens
   */

  export type AggregatePassword_reset_tokens = {
    _count: Password_reset_tokensCountAggregateOutputType | null
    _min: Password_reset_tokensMinAggregateOutputType | null
    _max: Password_reset_tokensMaxAggregateOutputType | null
  }

  export type Password_reset_tokensMinAggregateOutputType = {
    email: string | null
    token: string | null
    created_at: Date | null
  }

  export type Password_reset_tokensMaxAggregateOutputType = {
    email: string | null
    token: string | null
    created_at: Date | null
  }

  export type Password_reset_tokensCountAggregateOutputType = {
    email: number
    token: number
    created_at: number
    _all: number
  }


  export type Password_reset_tokensMinAggregateInputType = {
    email?: true
    token?: true
    created_at?: true
  }

  export type Password_reset_tokensMaxAggregateInputType = {
    email?: true
    token?: true
    created_at?: true
  }

  export type Password_reset_tokensCountAggregateInputType = {
    email?: true
    token?: true
    created_at?: true
    _all?: true
  }

  export type Password_reset_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to aggregate.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned password_reset_tokens
    **/
    _count?: true | Password_reset_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Password_reset_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Password_reset_tokensMaxAggregateInputType
  }

  export type GetPassword_reset_tokensAggregateType<T extends Password_reset_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_reset_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
      : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
  }




  export type password_reset_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_reset_tokensWhereInput
    orderBy?: password_reset_tokensOrderByWithAggregationInput | password_reset_tokensOrderByWithAggregationInput[]
    by: Password_reset_tokensScalarFieldEnum[] | Password_reset_tokensScalarFieldEnum
    having?: password_reset_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Password_reset_tokensCountAggregateInputType | true
    _min?: Password_reset_tokensMinAggregateInputType
    _max?: Password_reset_tokensMaxAggregateInputType
  }

  export type Password_reset_tokensGroupByOutputType = {
    email: string
    token: string
    created_at: Date | null
    _count: Password_reset_tokensCountAggregateOutputType | null
    _min: Password_reset_tokensMinAggregateOutputType | null
    _max: Password_reset_tokensMaxAggregateOutputType | null
  }

  type GetPassword_reset_tokensGroupByPayload<T extends password_reset_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Password_reset_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Password_reset_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
        }
      >
    >


  export type password_reset_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    token?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["password_reset_tokens"]>



  export type password_reset_tokensSelectScalar = {
    email?: boolean
    token?: boolean
    created_at?: boolean
  }

  export type password_reset_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"email" | "token" | "created_at", ExtArgs["result"]["password_reset_tokens"]>

  export type $password_reset_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "password_reset_tokens"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      email: string
      token: string
      created_at: Date | null
    }, ExtArgs["result"]["password_reset_tokens"]>
    composites: {}
  }

  type password_reset_tokensGetPayload<S extends boolean | null | undefined | password_reset_tokensDefaultArgs> = $Result.GetResult<Prisma.$password_reset_tokensPayload, S>

  type password_reset_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<password_reset_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Password_reset_tokensCountAggregateInputType | true
    }

  export interface password_reset_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['password_reset_tokens'], meta: { name: 'password_reset_tokens' } }
    /**
     * Find zero or one Password_reset_tokens that matches the filter.
     * @param {password_reset_tokensFindUniqueArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends password_reset_tokensFindUniqueArgs>(args: SelectSubset<T, password_reset_tokensFindUniqueArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password_reset_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {password_reset_tokensFindUniqueOrThrowArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends password_reset_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, password_reset_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindFirstArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends password_reset_tokensFindFirstArgs>(args?: SelectSubset<T, password_reset_tokensFindFirstArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindFirstOrThrowArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends password_reset_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, password_reset_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
     * 
     * // Get first 10 Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const password_reset_tokensWithEmailOnly = await prisma.password_reset_tokens.findMany({ select: { email: true } })
     * 
     */
    findMany<T extends password_reset_tokensFindManyArgs>(args?: SelectSubset<T, password_reset_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password_reset_tokens.
     * @param {password_reset_tokensCreateArgs} args - Arguments to create a Password_reset_tokens.
     * @example
     * // Create one Password_reset_tokens
     * const Password_reset_tokens = await prisma.password_reset_tokens.create({
     *   data: {
     *     // ... data to create a Password_reset_tokens
     *   }
     * })
     * 
     */
    create<T extends password_reset_tokensCreateArgs>(args: SelectSubset<T, password_reset_tokensCreateArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Password_reset_tokens.
     * @param {password_reset_tokensCreateManyArgs} args - Arguments to create many Password_reset_tokens.
     * @example
     * // Create many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends password_reset_tokensCreateManyArgs>(args?: SelectSubset<T, password_reset_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Password_reset_tokens.
     * @param {password_reset_tokensDeleteArgs} args - Arguments to delete one Password_reset_tokens.
     * @example
     * // Delete one Password_reset_tokens
     * const Password_reset_tokens = await prisma.password_reset_tokens.delete({
     *   where: {
     *     // ... filter to delete one Password_reset_tokens
     *   }
     * })
     * 
     */
    delete<T extends password_reset_tokensDeleteArgs>(args: SelectSubset<T, password_reset_tokensDeleteArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password_reset_tokens.
     * @param {password_reset_tokensUpdateArgs} args - Arguments to update one Password_reset_tokens.
     * @example
     * // Update one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends password_reset_tokensUpdateArgs>(args: SelectSubset<T, password_reset_tokensUpdateArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Password_reset_tokens.
     * @param {password_reset_tokensDeleteManyArgs} args - Arguments to filter Password_reset_tokens to delete.
     * @example
     * // Delete a few Password_reset_tokens
     * const { count } = await prisma.password_reset_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends password_reset_tokensDeleteManyArgs>(args?: SelectSubset<T, password_reset_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends password_reset_tokensUpdateManyArgs>(args: SelectSubset<T, password_reset_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Password_reset_tokens.
     * @param {password_reset_tokensUpsertArgs} args - Arguments to update or create a Password_reset_tokens.
     * @example
     * // Update or create a Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.upsert({
     *   create: {
     *     // ... data to create a Password_reset_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to update
     *   }
     * })
     */
    upsert<T extends password_reset_tokensUpsertArgs>(args: SelectSubset<T, password_reset_tokensUpsertArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensCountArgs} args - Arguments to filter Password_reset_tokens to count.
     * @example
     * // Count the number of Password_reset_tokens
     * const count = await prisma.password_reset_tokens.count({
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to count
     *   }
     * })
    **/
    count<T extends password_reset_tokensCountArgs>(
      args?: Subset<T, password_reset_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Password_reset_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_reset_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Password_reset_tokensAggregateArgs>(args: Subset<T, Password_reset_tokensAggregateArgs>): Prisma.PrismaPromise<GetPassword_reset_tokensAggregateType<T>>

    /**
     * Group by Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends password_reset_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: password_reset_tokensGroupByArgs['orderBy'] }
        : { orderBy?: password_reset_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, password_reset_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassword_reset_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the password_reset_tokens model
   */
  readonly fields: password_reset_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for password_reset_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__password_reset_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the password_reset_tokens model
   */
  interface password_reset_tokensFieldRefs {
    readonly email: FieldRef<"password_reset_tokens", 'String'>
    readonly token: FieldRef<"password_reset_tokens", 'String'>
    readonly created_at: FieldRef<"password_reset_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * password_reset_tokens findUnique
   */
  export type password_reset_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens findUniqueOrThrow
   */
  export type password_reset_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens findFirst
   */
  export type password_reset_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens findFirstOrThrow
   */
  export type password_reset_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens findMany
   */
  export type password_reset_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens create
   */
  export type password_reset_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data needed to create a password_reset_tokens.
     */
    data: XOR<password_reset_tokensCreateInput, password_reset_tokensUncheckedCreateInput>
  }

  /**
   * password_reset_tokens createMany
   */
  export type password_reset_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many password_reset_tokens.
     */
    data: password_reset_tokensCreateManyInput | password_reset_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * password_reset_tokens update
   */
  export type password_reset_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data needed to update a password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateInput, password_reset_tokensUncheckedUpdateInput>
    /**
     * Choose, which password_reset_tokens to update.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens updateMany
   */
  export type password_reset_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateManyMutationInput, password_reset_tokensUncheckedUpdateManyInput>
    /**
     * Filter which password_reset_tokens to update
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to update.
     */
    limit?: number
  }

  /**
   * password_reset_tokens upsert
   */
  export type password_reset_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The filter to search for the password_reset_tokens to update in case it exists.
     */
    where: password_reset_tokensWhereUniqueInput
    /**
     * In case the password_reset_tokens found by the `where` argument doesn't exist, create a new password_reset_tokens with this data.
     */
    create: XOR<password_reset_tokensCreateInput, password_reset_tokensUncheckedCreateInput>
    /**
     * In case the password_reset_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<password_reset_tokensUpdateInput, password_reset_tokensUncheckedUpdateInput>
  }

  /**
   * password_reset_tokens delete
   */
  export type password_reset_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter which password_reset_tokens to delete.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens deleteMany
   */
  export type password_reset_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to delete
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to delete.
     */
    limit?: number
  }

  /**
   * password_reset_tokens without action
   */
  export type password_reset_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
  }


  /**
   * Model personal_access_tokens
   */

  export type AggregatePersonal_access_tokens = {
    _count: Personal_access_tokensCountAggregateOutputType | null
    _avg: Personal_access_tokensAvgAggregateOutputType | null
    _sum: Personal_access_tokensSumAggregateOutputType | null
    _min: Personal_access_tokensMinAggregateOutputType | null
    _max: Personal_access_tokensMaxAggregateOutputType | null
  }

  export type Personal_access_tokensAvgAggregateOutputType = {
    id: number | null
    tokenable_id: number | null
  }

  export type Personal_access_tokensSumAggregateOutputType = {
    id: bigint | null
    tokenable_id: bigint | null
  }

  export type Personal_access_tokensMinAggregateOutputType = {
    id: bigint | null
    tokenable_type: string | null
    tokenable_id: bigint | null
    name: string | null
    token: string | null
    abilities: string | null
    last_used_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Personal_access_tokensMaxAggregateOutputType = {
    id: bigint | null
    tokenable_type: string | null
    tokenable_id: bigint | null
    name: string | null
    token: string | null
    abilities: string | null
    last_used_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Personal_access_tokensCountAggregateOutputType = {
    id: number
    tokenable_type: number
    tokenable_id: number
    name: number
    token: number
    abilities: number
    last_used_at: number
    expires_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Personal_access_tokensAvgAggregateInputType = {
    id?: true
    tokenable_id?: true
  }

  export type Personal_access_tokensSumAggregateInputType = {
    id?: true
    tokenable_id?: true
  }

  export type Personal_access_tokensMinAggregateInputType = {
    id?: true
    tokenable_type?: true
    tokenable_id?: true
    name?: true
    token?: true
    abilities?: true
    last_used_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Personal_access_tokensMaxAggregateInputType = {
    id?: true
    tokenable_type?: true
    tokenable_id?: true
    name?: true
    token?: true
    abilities?: true
    last_used_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Personal_access_tokensCountAggregateInputType = {
    id?: true
    tokenable_type?: true
    tokenable_id?: true
    name?: true
    token?: true
    abilities?: true
    last_used_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Personal_access_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which personal_access_tokens to aggregate.
     */
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     */
    orderBy?: personal_access_tokensOrderByWithRelationInput | personal_access_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personal_access_tokens
    **/
    _count?: true | Personal_access_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Personal_access_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Personal_access_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Personal_access_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Personal_access_tokensMaxAggregateInputType
  }

  export type GetPersonal_access_tokensAggregateType<T extends Personal_access_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonal_access_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonal_access_tokens[P]>
      : GetScalarType<T[P], AggregatePersonal_access_tokens[P]>
  }




  export type personal_access_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personal_access_tokensWhereInput
    orderBy?: personal_access_tokensOrderByWithAggregationInput | personal_access_tokensOrderByWithAggregationInput[]
    by: Personal_access_tokensScalarFieldEnum[] | Personal_access_tokensScalarFieldEnum
    having?: personal_access_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Personal_access_tokensCountAggregateInputType | true
    _avg?: Personal_access_tokensAvgAggregateInputType
    _sum?: Personal_access_tokensSumAggregateInputType
    _min?: Personal_access_tokensMinAggregateInputType
    _max?: Personal_access_tokensMaxAggregateInputType
  }

  export type Personal_access_tokensGroupByOutputType = {
    id: bigint
    tokenable_type: string
    tokenable_id: bigint
    name: string
    token: string
    abilities: string | null
    last_used_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: Personal_access_tokensCountAggregateOutputType | null
    _avg: Personal_access_tokensAvgAggregateOutputType | null
    _sum: Personal_access_tokensSumAggregateOutputType | null
    _min: Personal_access_tokensMinAggregateOutputType | null
    _max: Personal_access_tokensMaxAggregateOutputType | null
  }

  type GetPersonal_access_tokensGroupByPayload<T extends personal_access_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Personal_access_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Personal_access_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Personal_access_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Personal_access_tokensGroupByOutputType[P]>
        }
      >
    >


  export type personal_access_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenable_type?: boolean
    tokenable_id?: boolean
    name?: boolean
    token?: boolean
    abilities?: boolean
    last_used_at?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["personal_access_tokens"]>



  export type personal_access_tokensSelectScalar = {
    id?: boolean
    tokenable_type?: boolean
    tokenable_id?: boolean
    name?: boolean
    token?: boolean
    abilities?: boolean
    last_used_at?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type personal_access_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tokenable_type" | "tokenable_id" | "name" | "token" | "abilities" | "last_used_at" | "expires_at" | "created_at" | "updated_at", ExtArgs["result"]["personal_access_tokens"]>

  export type $personal_access_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "personal_access_tokens"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tokenable_type: string
      tokenable_id: bigint
      name: string
      token: string
      abilities: string | null
      last_used_at: Date | null
      expires_at: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["personal_access_tokens"]>
    composites: {}
  }

  type personal_access_tokensGetPayload<S extends boolean | null | undefined | personal_access_tokensDefaultArgs> = $Result.GetResult<Prisma.$personal_access_tokensPayload, S>

  type personal_access_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<personal_access_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Personal_access_tokensCountAggregateInputType | true
    }

  export interface personal_access_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['personal_access_tokens'], meta: { name: 'personal_access_tokens' } }
    /**
     * Find zero or one Personal_access_tokens that matches the filter.
     * @param {personal_access_tokensFindUniqueArgs} args - Arguments to find a Personal_access_tokens
     * @example
     * // Get one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends personal_access_tokensFindUniqueArgs>(args: SelectSubset<T, personal_access_tokensFindUniqueArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Personal_access_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {personal_access_tokensFindUniqueOrThrowArgs} args - Arguments to find a Personal_access_tokens
     * @example
     * // Get one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends personal_access_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, personal_access_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Personal_access_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensFindFirstArgs} args - Arguments to find a Personal_access_tokens
     * @example
     * // Get one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends personal_access_tokensFindFirstArgs>(args?: SelectSubset<T, personal_access_tokensFindFirstArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Personal_access_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensFindFirstOrThrowArgs} args - Arguments to find a Personal_access_tokens
     * @example
     * // Get one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends personal_access_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, personal_access_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Personal_access_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findMany()
     * 
     * // Get first 10 Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personal_access_tokensWithIdOnly = await prisma.personal_access_tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends personal_access_tokensFindManyArgs>(args?: SelectSubset<T, personal_access_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Personal_access_tokens.
     * @param {personal_access_tokensCreateArgs} args - Arguments to create a Personal_access_tokens.
     * @example
     * // Create one Personal_access_tokens
     * const Personal_access_tokens = await prisma.personal_access_tokens.create({
     *   data: {
     *     // ... data to create a Personal_access_tokens
     *   }
     * })
     * 
     */
    create<T extends personal_access_tokensCreateArgs>(args: SelectSubset<T, personal_access_tokensCreateArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Personal_access_tokens.
     * @param {personal_access_tokensCreateManyArgs} args - Arguments to create many Personal_access_tokens.
     * @example
     * // Create many Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends personal_access_tokensCreateManyArgs>(args?: SelectSubset<T, personal_access_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personal_access_tokens.
     * @param {personal_access_tokensDeleteArgs} args - Arguments to delete one Personal_access_tokens.
     * @example
     * // Delete one Personal_access_tokens
     * const Personal_access_tokens = await prisma.personal_access_tokens.delete({
     *   where: {
     *     // ... filter to delete one Personal_access_tokens
     *   }
     * })
     * 
     */
    delete<T extends personal_access_tokensDeleteArgs>(args: SelectSubset<T, personal_access_tokensDeleteArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Personal_access_tokens.
     * @param {personal_access_tokensUpdateArgs} args - Arguments to update one Personal_access_tokens.
     * @example
     * // Update one Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends personal_access_tokensUpdateArgs>(args: SelectSubset<T, personal_access_tokensUpdateArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Personal_access_tokens.
     * @param {personal_access_tokensDeleteManyArgs} args - Arguments to filter Personal_access_tokens to delete.
     * @example
     * // Delete a few Personal_access_tokens
     * const { count } = await prisma.personal_access_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends personal_access_tokensDeleteManyArgs>(args?: SelectSubset<T, personal_access_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends personal_access_tokensUpdateManyArgs>(args: SelectSubset<T, personal_access_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personal_access_tokens.
     * @param {personal_access_tokensUpsertArgs} args - Arguments to update or create a Personal_access_tokens.
     * @example
     * // Update or create a Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.upsert({
     *   create: {
     *     // ... data to create a Personal_access_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personal_access_tokens we want to update
     *   }
     * })
     */
    upsert<T extends personal_access_tokensUpsertArgs>(args: SelectSubset<T, personal_access_tokensUpsertArgs<ExtArgs>>): Prisma__personal_access_tokensClient<$Result.GetResult<Prisma.$personal_access_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensCountArgs} args - Arguments to filter Personal_access_tokens to count.
     * @example
     * // Count the number of Personal_access_tokens
     * const count = await prisma.personal_access_tokens.count({
     *   where: {
     *     // ... the filter for the Personal_access_tokens we want to count
     *   }
     * })
    **/
    count<T extends personal_access_tokensCountArgs>(
      args?: Subset<T, personal_access_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Personal_access_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personal_access_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Personal_access_tokensAggregateArgs>(args: Subset<T, Personal_access_tokensAggregateArgs>): Prisma.PrismaPromise<GetPersonal_access_tokensAggregateType<T>>

    /**
     * Group by Personal_access_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personal_access_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends personal_access_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: personal_access_tokensGroupByArgs['orderBy'] }
        : { orderBy?: personal_access_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, personal_access_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonal_access_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the personal_access_tokens model
   */
  readonly fields: personal_access_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for personal_access_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__personal_access_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the personal_access_tokens model
   */
  interface personal_access_tokensFieldRefs {
    readonly id: FieldRef<"personal_access_tokens", 'BigInt'>
    readonly tokenable_type: FieldRef<"personal_access_tokens", 'String'>
    readonly tokenable_id: FieldRef<"personal_access_tokens", 'BigInt'>
    readonly name: FieldRef<"personal_access_tokens", 'String'>
    readonly token: FieldRef<"personal_access_tokens", 'String'>
    readonly abilities: FieldRef<"personal_access_tokens", 'String'>
    readonly last_used_at: FieldRef<"personal_access_tokens", 'DateTime'>
    readonly expires_at: FieldRef<"personal_access_tokens", 'DateTime'>
    readonly created_at: FieldRef<"personal_access_tokens", 'DateTime'>
    readonly updated_at: FieldRef<"personal_access_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * personal_access_tokens findUnique
   */
  export type personal_access_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter, which personal_access_tokens to fetch.
     */
    where: personal_access_tokensWhereUniqueInput
  }

  /**
   * personal_access_tokens findUniqueOrThrow
   */
  export type personal_access_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter, which personal_access_tokens to fetch.
     */
    where: personal_access_tokensWhereUniqueInput
  }

  /**
   * personal_access_tokens findFirst
   */
  export type personal_access_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter, which personal_access_tokens to fetch.
     */
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     */
    orderBy?: personal_access_tokensOrderByWithRelationInput | personal_access_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personal_access_tokens.
     */
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personal_access_tokens.
     */
    distinct?: Personal_access_tokensScalarFieldEnum | Personal_access_tokensScalarFieldEnum[]
  }

  /**
   * personal_access_tokens findFirstOrThrow
   */
  export type personal_access_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter, which personal_access_tokens to fetch.
     */
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     */
    orderBy?: personal_access_tokensOrderByWithRelationInput | personal_access_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personal_access_tokens.
     */
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personal_access_tokens.
     */
    distinct?: Personal_access_tokensScalarFieldEnum | Personal_access_tokensScalarFieldEnum[]
  }

  /**
   * personal_access_tokens findMany
   */
  export type personal_access_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter, which personal_access_tokens to fetch.
     */
    where?: personal_access_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personal_access_tokens to fetch.
     */
    orderBy?: personal_access_tokensOrderByWithRelationInput | personal_access_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personal_access_tokens.
     */
    cursor?: personal_access_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personal_access_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personal_access_tokens.
     */
    skip?: number
    distinct?: Personal_access_tokensScalarFieldEnum | Personal_access_tokensScalarFieldEnum[]
  }

  /**
   * personal_access_tokens create
   */
  export type personal_access_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * The data needed to create a personal_access_tokens.
     */
    data: XOR<personal_access_tokensCreateInput, personal_access_tokensUncheckedCreateInput>
  }

  /**
   * personal_access_tokens createMany
   */
  export type personal_access_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many personal_access_tokens.
     */
    data: personal_access_tokensCreateManyInput | personal_access_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * personal_access_tokens update
   */
  export type personal_access_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * The data needed to update a personal_access_tokens.
     */
    data: XOR<personal_access_tokensUpdateInput, personal_access_tokensUncheckedUpdateInput>
    /**
     * Choose, which personal_access_tokens to update.
     */
    where: personal_access_tokensWhereUniqueInput
  }

  /**
   * personal_access_tokens updateMany
   */
  export type personal_access_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update personal_access_tokens.
     */
    data: XOR<personal_access_tokensUpdateManyMutationInput, personal_access_tokensUncheckedUpdateManyInput>
    /**
     * Filter which personal_access_tokens to update
     */
    where?: personal_access_tokensWhereInput
    /**
     * Limit how many personal_access_tokens to update.
     */
    limit?: number
  }

  /**
   * personal_access_tokens upsert
   */
  export type personal_access_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * The filter to search for the personal_access_tokens to update in case it exists.
     */
    where: personal_access_tokensWhereUniqueInput
    /**
     * In case the personal_access_tokens found by the `where` argument doesn't exist, create a new personal_access_tokens with this data.
     */
    create: XOR<personal_access_tokensCreateInput, personal_access_tokensUncheckedCreateInput>
    /**
     * In case the personal_access_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<personal_access_tokensUpdateInput, personal_access_tokensUncheckedUpdateInput>
  }

  /**
   * personal_access_tokens delete
   */
  export type personal_access_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
    /**
     * Filter which personal_access_tokens to delete.
     */
    where: personal_access_tokensWhereUniqueInput
  }

  /**
   * personal_access_tokens deleteMany
   */
  export type personal_access_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which personal_access_tokens to delete
     */
    where?: personal_access_tokensWhereInput
    /**
     * Limit how many personal_access_tokens to delete.
     */
    limit?: number
  }

  /**
   * personal_access_tokens without action
   */
  export type personal_access_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal_access_tokens
     */
    select?: personal_access_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personal_access_tokens
     */
    omit?: personal_access_tokensOmit<ExtArgs> | null
  }


  /**
   * Model poliza_asegurados
   */

  export type AggregatePoliza_asegurados = {
    _count: Poliza_aseguradosCountAggregateOutputType | null
    _avg: Poliza_aseguradosAvgAggregateOutputType | null
    _sum: Poliza_aseguradosSumAggregateOutputType | null
    _min: Poliza_aseguradosMinAggregateOutputType | null
    _max: Poliza_aseguradosMaxAggregateOutputType | null
  }

  export type Poliza_aseguradosAvgAggregateOutputType = {
    id: number | null
    poliza_id: number | null
    cliente_id: number | null
    estado_id: number | null
  }

  export type Poliza_aseguradosSumAggregateOutputType = {
    id: bigint | null
    poliza_id: bigint | null
    cliente_id: bigint | null
    estado_id: bigint | null
  }

  export type Poliza_aseguradosMinAggregateOutputType = {
    id: bigint | null
    poliza_id: bigint | null
    cliente_id: bigint | null
    rfc: string | null
    nombre: string | null
    fechaNacimiento: Date | null
    direccion: string | null
    colonia: string | null
    codigoPostal: string | null
    estado_id: bigint | null
    ciudad: string | null
    correo: string | null
    telefono: string | null
    celular: string | null
    oficina: string | null
    casa: string | null
    observaciones: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Poliza_aseguradosMaxAggregateOutputType = {
    id: bigint | null
    poliza_id: bigint | null
    cliente_id: bigint | null
    rfc: string | null
    nombre: string | null
    fechaNacimiento: Date | null
    direccion: string | null
    colonia: string | null
    codigoPostal: string | null
    estado_id: bigint | null
    ciudad: string | null
    correo: string | null
    telefono: string | null
    celular: string | null
    oficina: string | null
    casa: string | null
    observaciones: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Poliza_aseguradosCountAggregateOutputType = {
    id: number
    poliza_id: number
    cliente_id: number
    rfc: number
    nombre: number
    fechaNacimiento: number
    direccion: number
    colonia: number
    codigoPostal: number
    estado_id: number
    ciudad: number
    correo: number
    telefono: number
    celular: number
    oficina: number
    casa: number
    observaciones: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Poliza_aseguradosAvgAggregateInputType = {
    id?: true
    poliza_id?: true
    cliente_id?: true
    estado_id?: true
  }

  export type Poliza_aseguradosSumAggregateInputType = {
    id?: true
    poliza_id?: true
    cliente_id?: true
    estado_id?: true
  }

  export type Poliza_aseguradosMinAggregateInputType = {
    id?: true
    poliza_id?: true
    cliente_id?: true
    rfc?: true
    nombre?: true
    fechaNacimiento?: true
    direccion?: true
    colonia?: true
    codigoPostal?: true
    estado_id?: true
    ciudad?: true
    correo?: true
    telefono?: true
    celular?: true
    oficina?: true
    casa?: true
    observaciones?: true
    created_at?: true
    updated_at?: true
  }

  export type Poliza_aseguradosMaxAggregateInputType = {
    id?: true
    poliza_id?: true
    cliente_id?: true
    rfc?: true
    nombre?: true
    fechaNacimiento?: true
    direccion?: true
    colonia?: true
    codigoPostal?: true
    estado_id?: true
    ciudad?: true
    correo?: true
    telefono?: true
    celular?: true
    oficina?: true
    casa?: true
    observaciones?: true
    created_at?: true
    updated_at?: true
  }

  export type Poliza_aseguradosCountAggregateInputType = {
    id?: true
    poliza_id?: true
    cliente_id?: true
    rfc?: true
    nombre?: true
    fechaNacimiento?: true
    direccion?: true
    colonia?: true
    codigoPostal?: true
    estado_id?: true
    ciudad?: true
    correo?: true
    telefono?: true
    celular?: true
    oficina?: true
    casa?: true
    observaciones?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Poliza_aseguradosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poliza_asegurados to aggregate.
     */
    where?: poliza_aseguradosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_asegurados to fetch.
     */
    orderBy?: poliza_aseguradosOrderByWithRelationInput | poliza_aseguradosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: poliza_aseguradosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_asegurados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_asegurados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned poliza_asegurados
    **/
    _count?: true | Poliza_aseguradosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Poliza_aseguradosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Poliza_aseguradosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Poliza_aseguradosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Poliza_aseguradosMaxAggregateInputType
  }

  export type GetPoliza_aseguradosAggregateType<T extends Poliza_aseguradosAggregateArgs> = {
        [P in keyof T & keyof AggregatePoliza_asegurados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoliza_asegurados[P]>
      : GetScalarType<T[P], AggregatePoliza_asegurados[P]>
  }




  export type poliza_aseguradosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poliza_aseguradosWhereInput
    orderBy?: poliza_aseguradosOrderByWithAggregationInput | poliza_aseguradosOrderByWithAggregationInput[]
    by: Poliza_aseguradosScalarFieldEnum[] | Poliza_aseguradosScalarFieldEnum
    having?: poliza_aseguradosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Poliza_aseguradosCountAggregateInputType | true
    _avg?: Poliza_aseguradosAvgAggregateInputType
    _sum?: Poliza_aseguradosSumAggregateInputType
    _min?: Poliza_aseguradosMinAggregateInputType
    _max?: Poliza_aseguradosMaxAggregateInputType
  }

  export type Poliza_aseguradosGroupByOutputType = {
    id: bigint
    poliza_id: bigint
    cliente_id: bigint | null
    rfc: string
    nombre: string
    fechaNacimiento: Date
    direccion: string
    colonia: string
    codigoPostal: string
    estado_id: bigint
    ciudad: string
    correo: string | null
    telefono: string | null
    celular: string | null
    oficina: string | null
    casa: string | null
    observaciones: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Poliza_aseguradosCountAggregateOutputType | null
    _avg: Poliza_aseguradosAvgAggregateOutputType | null
    _sum: Poliza_aseguradosSumAggregateOutputType | null
    _min: Poliza_aseguradosMinAggregateOutputType | null
    _max: Poliza_aseguradosMaxAggregateOutputType | null
  }

  type GetPoliza_aseguradosGroupByPayload<T extends poliza_aseguradosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Poliza_aseguradosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Poliza_aseguradosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Poliza_aseguradosGroupByOutputType[P]>
            : GetScalarType<T[P], Poliza_aseguradosGroupByOutputType[P]>
        }
      >
    >


  export type poliza_aseguradosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poliza_id?: boolean
    cliente_id?: boolean
    rfc?: boolean
    nombre?: boolean
    fechaNacimiento?: boolean
    direccion?: boolean
    colonia?: boolean
    codigoPostal?: boolean
    estado_id?: boolean
    ciudad?: boolean
    correo?: boolean
    telefono?: boolean
    celular?: boolean
    oficina?: boolean
    casa?: boolean
    observaciones?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["poliza_asegurados"]>



  export type poliza_aseguradosSelectScalar = {
    id?: boolean
    poliza_id?: boolean
    cliente_id?: boolean
    rfc?: boolean
    nombre?: boolean
    fechaNacimiento?: boolean
    direccion?: boolean
    colonia?: boolean
    codigoPostal?: boolean
    estado_id?: boolean
    ciudad?: boolean
    correo?: boolean
    telefono?: boolean
    celular?: boolean
    oficina?: boolean
    casa?: boolean
    observaciones?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type poliza_aseguradosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poliza_id" | "cliente_id" | "rfc" | "nombre" | "fechaNacimiento" | "direccion" | "colonia" | "codigoPostal" | "estado_id" | "ciudad" | "correo" | "telefono" | "celular" | "oficina" | "casa" | "observaciones" | "created_at" | "updated_at", ExtArgs["result"]["poliza_asegurados"]>

  export type $poliza_aseguradosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "poliza_asegurados"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      poliza_id: bigint
      cliente_id: bigint | null
      rfc: string
      nombre: string
      fechaNacimiento: Date
      direccion: string
      colonia: string
      codigoPostal: string
      estado_id: bigint
      ciudad: string
      correo: string | null
      telefono: string | null
      celular: string | null
      oficina: string | null
      casa: string | null
      observaciones: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["poliza_asegurados"]>
    composites: {}
  }

  type poliza_aseguradosGetPayload<S extends boolean | null | undefined | poliza_aseguradosDefaultArgs> = $Result.GetResult<Prisma.$poliza_aseguradosPayload, S>

  type poliza_aseguradosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<poliza_aseguradosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Poliza_aseguradosCountAggregateInputType | true
    }

  export interface poliza_aseguradosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['poliza_asegurados'], meta: { name: 'poliza_asegurados' } }
    /**
     * Find zero or one Poliza_asegurados that matches the filter.
     * @param {poliza_aseguradosFindUniqueArgs} args - Arguments to find a Poliza_asegurados
     * @example
     * // Get one Poliza_asegurados
     * const poliza_asegurados = await prisma.poliza_asegurados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends poliza_aseguradosFindUniqueArgs>(args: SelectSubset<T, poliza_aseguradosFindUniqueArgs<ExtArgs>>): Prisma__poliza_aseguradosClient<$Result.GetResult<Prisma.$poliza_aseguradosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Poliza_asegurados that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {poliza_aseguradosFindUniqueOrThrowArgs} args - Arguments to find a Poliza_asegurados
     * @example
     * // Get one Poliza_asegurados
     * const poliza_asegurados = await prisma.poliza_asegurados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends poliza_aseguradosFindUniqueOrThrowArgs>(args: SelectSubset<T, poliza_aseguradosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__poliza_aseguradosClient<$Result.GetResult<Prisma.$poliza_aseguradosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poliza_asegurados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_aseguradosFindFirstArgs} args - Arguments to find a Poliza_asegurados
     * @example
     * // Get one Poliza_asegurados
     * const poliza_asegurados = await prisma.poliza_asegurados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends poliza_aseguradosFindFirstArgs>(args?: SelectSubset<T, poliza_aseguradosFindFirstArgs<ExtArgs>>): Prisma__poliza_aseguradosClient<$Result.GetResult<Prisma.$poliza_aseguradosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poliza_asegurados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_aseguradosFindFirstOrThrowArgs} args - Arguments to find a Poliza_asegurados
     * @example
     * // Get one Poliza_asegurados
     * const poliza_asegurados = await prisma.poliza_asegurados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends poliza_aseguradosFindFirstOrThrowArgs>(args?: SelectSubset<T, poliza_aseguradosFindFirstOrThrowArgs<ExtArgs>>): Prisma__poliza_aseguradosClient<$Result.GetResult<Prisma.$poliza_aseguradosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Poliza_asegurados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_aseguradosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Poliza_asegurados
     * const poliza_asegurados = await prisma.poliza_asegurados.findMany()
     * 
     * // Get first 10 Poliza_asegurados
     * const poliza_asegurados = await prisma.poliza_asegurados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poliza_aseguradosWithIdOnly = await prisma.poliza_asegurados.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends poliza_aseguradosFindManyArgs>(args?: SelectSubset<T, poliza_aseguradosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poliza_aseguradosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Poliza_asegurados.
     * @param {poliza_aseguradosCreateArgs} args - Arguments to create a Poliza_asegurados.
     * @example
     * // Create one Poliza_asegurados
     * const Poliza_asegurados = await prisma.poliza_asegurados.create({
     *   data: {
     *     // ... data to create a Poliza_asegurados
     *   }
     * })
     * 
     */
    create<T extends poliza_aseguradosCreateArgs>(args: SelectSubset<T, poliza_aseguradosCreateArgs<ExtArgs>>): Prisma__poliza_aseguradosClient<$Result.GetResult<Prisma.$poliza_aseguradosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Poliza_asegurados.
     * @param {poliza_aseguradosCreateManyArgs} args - Arguments to create many Poliza_asegurados.
     * @example
     * // Create many Poliza_asegurados
     * const poliza_asegurados = await prisma.poliza_asegurados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends poliza_aseguradosCreateManyArgs>(args?: SelectSubset<T, poliza_aseguradosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Poliza_asegurados.
     * @param {poliza_aseguradosDeleteArgs} args - Arguments to delete one Poliza_asegurados.
     * @example
     * // Delete one Poliza_asegurados
     * const Poliza_asegurados = await prisma.poliza_asegurados.delete({
     *   where: {
     *     // ... filter to delete one Poliza_asegurados
     *   }
     * })
     * 
     */
    delete<T extends poliza_aseguradosDeleteArgs>(args: SelectSubset<T, poliza_aseguradosDeleteArgs<ExtArgs>>): Prisma__poliza_aseguradosClient<$Result.GetResult<Prisma.$poliza_aseguradosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Poliza_asegurados.
     * @param {poliza_aseguradosUpdateArgs} args - Arguments to update one Poliza_asegurados.
     * @example
     * // Update one Poliza_asegurados
     * const poliza_asegurados = await prisma.poliza_asegurados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends poliza_aseguradosUpdateArgs>(args: SelectSubset<T, poliza_aseguradosUpdateArgs<ExtArgs>>): Prisma__poliza_aseguradosClient<$Result.GetResult<Prisma.$poliza_aseguradosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Poliza_asegurados.
     * @param {poliza_aseguradosDeleteManyArgs} args - Arguments to filter Poliza_asegurados to delete.
     * @example
     * // Delete a few Poliza_asegurados
     * const { count } = await prisma.poliza_asegurados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends poliza_aseguradosDeleteManyArgs>(args?: SelectSubset<T, poliza_aseguradosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Poliza_asegurados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_aseguradosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Poliza_asegurados
     * const poliza_asegurados = await prisma.poliza_asegurados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends poliza_aseguradosUpdateManyArgs>(args: SelectSubset<T, poliza_aseguradosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Poliza_asegurados.
     * @param {poliza_aseguradosUpsertArgs} args - Arguments to update or create a Poliza_asegurados.
     * @example
     * // Update or create a Poliza_asegurados
     * const poliza_asegurados = await prisma.poliza_asegurados.upsert({
     *   create: {
     *     // ... data to create a Poliza_asegurados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Poliza_asegurados we want to update
     *   }
     * })
     */
    upsert<T extends poliza_aseguradosUpsertArgs>(args: SelectSubset<T, poliza_aseguradosUpsertArgs<ExtArgs>>): Prisma__poliza_aseguradosClient<$Result.GetResult<Prisma.$poliza_aseguradosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Poliza_asegurados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_aseguradosCountArgs} args - Arguments to filter Poliza_asegurados to count.
     * @example
     * // Count the number of Poliza_asegurados
     * const count = await prisma.poliza_asegurados.count({
     *   where: {
     *     // ... the filter for the Poliza_asegurados we want to count
     *   }
     * })
    **/
    count<T extends poliza_aseguradosCountArgs>(
      args?: Subset<T, poliza_aseguradosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Poliza_aseguradosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Poliza_asegurados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Poliza_aseguradosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Poliza_aseguradosAggregateArgs>(args: Subset<T, Poliza_aseguradosAggregateArgs>): Prisma.PrismaPromise<GetPoliza_aseguradosAggregateType<T>>

    /**
     * Group by Poliza_asegurados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_aseguradosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends poliza_aseguradosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: poliza_aseguradosGroupByArgs['orderBy'] }
        : { orderBy?: poliza_aseguradosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, poliza_aseguradosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoliza_aseguradosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the poliza_asegurados model
   */
  readonly fields: poliza_aseguradosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for poliza_asegurados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__poliza_aseguradosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the poliza_asegurados model
   */
  interface poliza_aseguradosFieldRefs {
    readonly id: FieldRef<"poliza_asegurados", 'BigInt'>
    readonly poliza_id: FieldRef<"poliza_asegurados", 'BigInt'>
    readonly cliente_id: FieldRef<"poliza_asegurados", 'BigInt'>
    readonly rfc: FieldRef<"poliza_asegurados", 'String'>
    readonly nombre: FieldRef<"poliza_asegurados", 'String'>
    readonly fechaNacimiento: FieldRef<"poliza_asegurados", 'DateTime'>
    readonly direccion: FieldRef<"poliza_asegurados", 'String'>
    readonly colonia: FieldRef<"poliza_asegurados", 'String'>
    readonly codigoPostal: FieldRef<"poliza_asegurados", 'String'>
    readonly estado_id: FieldRef<"poliza_asegurados", 'BigInt'>
    readonly ciudad: FieldRef<"poliza_asegurados", 'String'>
    readonly correo: FieldRef<"poliza_asegurados", 'String'>
    readonly telefono: FieldRef<"poliza_asegurados", 'String'>
    readonly celular: FieldRef<"poliza_asegurados", 'String'>
    readonly oficina: FieldRef<"poliza_asegurados", 'String'>
    readonly casa: FieldRef<"poliza_asegurados", 'String'>
    readonly observaciones: FieldRef<"poliza_asegurados", 'String'>
    readonly created_at: FieldRef<"poliza_asegurados", 'DateTime'>
    readonly updated_at: FieldRef<"poliza_asegurados", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * poliza_asegurados findUnique
   */
  export type poliza_aseguradosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_asegurados
     */
    select?: poliza_aseguradosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_asegurados
     */
    omit?: poliza_aseguradosOmit<ExtArgs> | null
    /**
     * Filter, which poliza_asegurados to fetch.
     */
    where: poliza_aseguradosWhereUniqueInput
  }

  /**
   * poliza_asegurados findUniqueOrThrow
   */
  export type poliza_aseguradosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_asegurados
     */
    select?: poliza_aseguradosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_asegurados
     */
    omit?: poliza_aseguradosOmit<ExtArgs> | null
    /**
     * Filter, which poliza_asegurados to fetch.
     */
    where: poliza_aseguradosWhereUniqueInput
  }

  /**
   * poliza_asegurados findFirst
   */
  export type poliza_aseguradosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_asegurados
     */
    select?: poliza_aseguradosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_asegurados
     */
    omit?: poliza_aseguradosOmit<ExtArgs> | null
    /**
     * Filter, which poliza_asegurados to fetch.
     */
    where?: poliza_aseguradosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_asegurados to fetch.
     */
    orderBy?: poliza_aseguradosOrderByWithRelationInput | poliza_aseguradosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for poliza_asegurados.
     */
    cursor?: poliza_aseguradosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_asegurados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_asegurados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of poliza_asegurados.
     */
    distinct?: Poliza_aseguradosScalarFieldEnum | Poliza_aseguradosScalarFieldEnum[]
  }

  /**
   * poliza_asegurados findFirstOrThrow
   */
  export type poliza_aseguradosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_asegurados
     */
    select?: poliza_aseguradosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_asegurados
     */
    omit?: poliza_aseguradosOmit<ExtArgs> | null
    /**
     * Filter, which poliza_asegurados to fetch.
     */
    where?: poliza_aseguradosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_asegurados to fetch.
     */
    orderBy?: poliza_aseguradosOrderByWithRelationInput | poliza_aseguradosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for poliza_asegurados.
     */
    cursor?: poliza_aseguradosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_asegurados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_asegurados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of poliza_asegurados.
     */
    distinct?: Poliza_aseguradosScalarFieldEnum | Poliza_aseguradosScalarFieldEnum[]
  }

  /**
   * poliza_asegurados findMany
   */
  export type poliza_aseguradosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_asegurados
     */
    select?: poliza_aseguradosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_asegurados
     */
    omit?: poliza_aseguradosOmit<ExtArgs> | null
    /**
     * Filter, which poliza_asegurados to fetch.
     */
    where?: poliza_aseguradosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_asegurados to fetch.
     */
    orderBy?: poliza_aseguradosOrderByWithRelationInput | poliza_aseguradosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing poliza_asegurados.
     */
    cursor?: poliza_aseguradosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_asegurados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_asegurados.
     */
    skip?: number
    distinct?: Poliza_aseguradosScalarFieldEnum | Poliza_aseguradosScalarFieldEnum[]
  }

  /**
   * poliza_asegurados create
   */
  export type poliza_aseguradosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_asegurados
     */
    select?: poliza_aseguradosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_asegurados
     */
    omit?: poliza_aseguradosOmit<ExtArgs> | null
    /**
     * The data needed to create a poliza_asegurados.
     */
    data: XOR<poliza_aseguradosCreateInput, poliza_aseguradosUncheckedCreateInput>
  }

  /**
   * poliza_asegurados createMany
   */
  export type poliza_aseguradosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many poliza_asegurados.
     */
    data: poliza_aseguradosCreateManyInput | poliza_aseguradosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * poliza_asegurados update
   */
  export type poliza_aseguradosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_asegurados
     */
    select?: poliza_aseguradosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_asegurados
     */
    omit?: poliza_aseguradosOmit<ExtArgs> | null
    /**
     * The data needed to update a poliza_asegurados.
     */
    data: XOR<poliza_aseguradosUpdateInput, poliza_aseguradosUncheckedUpdateInput>
    /**
     * Choose, which poliza_asegurados to update.
     */
    where: poliza_aseguradosWhereUniqueInput
  }

  /**
   * poliza_asegurados updateMany
   */
  export type poliza_aseguradosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update poliza_asegurados.
     */
    data: XOR<poliza_aseguradosUpdateManyMutationInput, poliza_aseguradosUncheckedUpdateManyInput>
    /**
     * Filter which poliza_asegurados to update
     */
    where?: poliza_aseguradosWhereInput
    /**
     * Limit how many poliza_asegurados to update.
     */
    limit?: number
  }

  /**
   * poliza_asegurados upsert
   */
  export type poliza_aseguradosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_asegurados
     */
    select?: poliza_aseguradosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_asegurados
     */
    omit?: poliza_aseguradosOmit<ExtArgs> | null
    /**
     * The filter to search for the poliza_asegurados to update in case it exists.
     */
    where: poliza_aseguradosWhereUniqueInput
    /**
     * In case the poliza_asegurados found by the `where` argument doesn't exist, create a new poliza_asegurados with this data.
     */
    create: XOR<poliza_aseguradosCreateInput, poliza_aseguradosUncheckedCreateInput>
    /**
     * In case the poliza_asegurados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<poliza_aseguradosUpdateInput, poliza_aseguradosUncheckedUpdateInput>
  }

  /**
   * poliza_asegurados delete
   */
  export type poliza_aseguradosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_asegurados
     */
    select?: poliza_aseguradosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_asegurados
     */
    omit?: poliza_aseguradosOmit<ExtArgs> | null
    /**
     * Filter which poliza_asegurados to delete.
     */
    where: poliza_aseguradosWhereUniqueInput
  }

  /**
   * poliza_asegurados deleteMany
   */
  export type poliza_aseguradosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poliza_asegurados to delete
     */
    where?: poliza_aseguradosWhereInput
    /**
     * Limit how many poliza_asegurados to delete.
     */
    limit?: number
  }

  /**
   * poliza_asegurados without action
   */
  export type poliza_aseguradosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_asegurados
     */
    select?: poliza_aseguradosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_asegurados
     */
    omit?: poliza_aseguradosOmit<ExtArgs> | null
  }


  /**
   * Model poliza_historial
   */

  export type AggregatePoliza_historial = {
    _count: Poliza_historialCountAggregateOutputType | null
    _avg: Poliza_historialAvgAggregateOutputType | null
    _sum: Poliza_historialSumAggregateOutputType | null
    _min: Poliza_historialMinAggregateOutputType | null
    _max: Poliza_historialMaxAggregateOutputType | null
  }

  export type Poliza_historialAvgAggregateOutputType = {
    id: number | null
    poliza_id: number | null
  }

  export type Poliza_historialSumAggregateOutputType = {
    id: bigint | null
    poliza_id: bigint | null
  }

  export type Poliza_historialMinAggregateOutputType = {
    id: bigint | null
    poliza_id: bigint | null
    accion: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Poliza_historialMaxAggregateOutputType = {
    id: bigint | null
    poliza_id: bigint | null
    accion: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Poliza_historialCountAggregateOutputType = {
    id: number
    poliza_id: number
    accion: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Poliza_historialAvgAggregateInputType = {
    id?: true
    poliza_id?: true
  }

  export type Poliza_historialSumAggregateInputType = {
    id?: true
    poliza_id?: true
  }

  export type Poliza_historialMinAggregateInputType = {
    id?: true
    poliza_id?: true
    accion?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Poliza_historialMaxAggregateInputType = {
    id?: true
    poliza_id?: true
    accion?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Poliza_historialCountAggregateInputType = {
    id?: true
    poliza_id?: true
    accion?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Poliza_historialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poliza_historial to aggregate.
     */
    where?: poliza_historialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_historials to fetch.
     */
    orderBy?: poliza_historialOrderByWithRelationInput | poliza_historialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: poliza_historialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_historials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned poliza_historials
    **/
    _count?: true | Poliza_historialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Poliza_historialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Poliza_historialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Poliza_historialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Poliza_historialMaxAggregateInputType
  }

  export type GetPoliza_historialAggregateType<T extends Poliza_historialAggregateArgs> = {
        [P in keyof T & keyof AggregatePoliza_historial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoliza_historial[P]>
      : GetScalarType<T[P], AggregatePoliza_historial[P]>
  }




  export type poliza_historialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poliza_historialWhereInput
    orderBy?: poliza_historialOrderByWithAggregationInput | poliza_historialOrderByWithAggregationInput[]
    by: Poliza_historialScalarFieldEnum[] | Poliza_historialScalarFieldEnum
    having?: poliza_historialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Poliza_historialCountAggregateInputType | true
    _avg?: Poliza_historialAvgAggregateInputType
    _sum?: Poliza_historialSumAggregateInputType
    _min?: Poliza_historialMinAggregateInputType
    _max?: Poliza_historialMaxAggregateInputType
  }

  export type Poliza_historialGroupByOutputType = {
    id: bigint
    poliza_id: bigint | null
    accion: string
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: Poliza_historialCountAggregateOutputType | null
    _avg: Poliza_historialAvgAggregateOutputType | null
    _sum: Poliza_historialSumAggregateOutputType | null
    _min: Poliza_historialMinAggregateOutputType | null
    _max: Poliza_historialMaxAggregateOutputType | null
  }

  type GetPoliza_historialGroupByPayload<T extends poliza_historialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Poliza_historialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Poliza_historialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Poliza_historialGroupByOutputType[P]>
            : GetScalarType<T[P], Poliza_historialGroupByOutputType[P]>
        }
      >
    >


  export type poliza_historialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poliza_id?: boolean
    accion?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["poliza_historial"]>



  export type poliza_historialSelectScalar = {
    id?: boolean
    poliza_id?: boolean
    accion?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type poliza_historialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poliza_id" | "accion" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["poliza_historial"]>

  export type $poliza_historialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "poliza_historial"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      poliza_id: bigint | null
      accion: string
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["poliza_historial"]>
    composites: {}
  }

  type poliza_historialGetPayload<S extends boolean | null | undefined | poliza_historialDefaultArgs> = $Result.GetResult<Prisma.$poliza_historialPayload, S>

  type poliza_historialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<poliza_historialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Poliza_historialCountAggregateInputType | true
    }

  export interface poliza_historialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['poliza_historial'], meta: { name: 'poliza_historial' } }
    /**
     * Find zero or one Poliza_historial that matches the filter.
     * @param {poliza_historialFindUniqueArgs} args - Arguments to find a Poliza_historial
     * @example
     * // Get one Poliza_historial
     * const poliza_historial = await prisma.poliza_historial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends poliza_historialFindUniqueArgs>(args: SelectSubset<T, poliza_historialFindUniqueArgs<ExtArgs>>): Prisma__poliza_historialClient<$Result.GetResult<Prisma.$poliza_historialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Poliza_historial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {poliza_historialFindUniqueOrThrowArgs} args - Arguments to find a Poliza_historial
     * @example
     * // Get one Poliza_historial
     * const poliza_historial = await prisma.poliza_historial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends poliza_historialFindUniqueOrThrowArgs>(args: SelectSubset<T, poliza_historialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__poliza_historialClient<$Result.GetResult<Prisma.$poliza_historialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poliza_historial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_historialFindFirstArgs} args - Arguments to find a Poliza_historial
     * @example
     * // Get one Poliza_historial
     * const poliza_historial = await prisma.poliza_historial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends poliza_historialFindFirstArgs>(args?: SelectSubset<T, poliza_historialFindFirstArgs<ExtArgs>>): Prisma__poliza_historialClient<$Result.GetResult<Prisma.$poliza_historialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poliza_historial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_historialFindFirstOrThrowArgs} args - Arguments to find a Poliza_historial
     * @example
     * // Get one Poliza_historial
     * const poliza_historial = await prisma.poliza_historial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends poliza_historialFindFirstOrThrowArgs>(args?: SelectSubset<T, poliza_historialFindFirstOrThrowArgs<ExtArgs>>): Prisma__poliza_historialClient<$Result.GetResult<Prisma.$poliza_historialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Poliza_historials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_historialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Poliza_historials
     * const poliza_historials = await prisma.poliza_historial.findMany()
     * 
     * // Get first 10 Poliza_historials
     * const poliza_historials = await prisma.poliza_historial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poliza_historialWithIdOnly = await prisma.poliza_historial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends poliza_historialFindManyArgs>(args?: SelectSubset<T, poliza_historialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poliza_historialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Poliza_historial.
     * @param {poliza_historialCreateArgs} args - Arguments to create a Poliza_historial.
     * @example
     * // Create one Poliza_historial
     * const Poliza_historial = await prisma.poliza_historial.create({
     *   data: {
     *     // ... data to create a Poliza_historial
     *   }
     * })
     * 
     */
    create<T extends poliza_historialCreateArgs>(args: SelectSubset<T, poliza_historialCreateArgs<ExtArgs>>): Prisma__poliza_historialClient<$Result.GetResult<Prisma.$poliza_historialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Poliza_historials.
     * @param {poliza_historialCreateManyArgs} args - Arguments to create many Poliza_historials.
     * @example
     * // Create many Poliza_historials
     * const poliza_historial = await prisma.poliza_historial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends poliza_historialCreateManyArgs>(args?: SelectSubset<T, poliza_historialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Poliza_historial.
     * @param {poliza_historialDeleteArgs} args - Arguments to delete one Poliza_historial.
     * @example
     * // Delete one Poliza_historial
     * const Poliza_historial = await prisma.poliza_historial.delete({
     *   where: {
     *     // ... filter to delete one Poliza_historial
     *   }
     * })
     * 
     */
    delete<T extends poliza_historialDeleteArgs>(args: SelectSubset<T, poliza_historialDeleteArgs<ExtArgs>>): Prisma__poliza_historialClient<$Result.GetResult<Prisma.$poliza_historialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Poliza_historial.
     * @param {poliza_historialUpdateArgs} args - Arguments to update one Poliza_historial.
     * @example
     * // Update one Poliza_historial
     * const poliza_historial = await prisma.poliza_historial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends poliza_historialUpdateArgs>(args: SelectSubset<T, poliza_historialUpdateArgs<ExtArgs>>): Prisma__poliza_historialClient<$Result.GetResult<Prisma.$poliza_historialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Poliza_historials.
     * @param {poliza_historialDeleteManyArgs} args - Arguments to filter Poliza_historials to delete.
     * @example
     * // Delete a few Poliza_historials
     * const { count } = await prisma.poliza_historial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends poliza_historialDeleteManyArgs>(args?: SelectSubset<T, poliza_historialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Poliza_historials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_historialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Poliza_historials
     * const poliza_historial = await prisma.poliza_historial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends poliza_historialUpdateManyArgs>(args: SelectSubset<T, poliza_historialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Poliza_historial.
     * @param {poliza_historialUpsertArgs} args - Arguments to update or create a Poliza_historial.
     * @example
     * // Update or create a Poliza_historial
     * const poliza_historial = await prisma.poliza_historial.upsert({
     *   create: {
     *     // ... data to create a Poliza_historial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Poliza_historial we want to update
     *   }
     * })
     */
    upsert<T extends poliza_historialUpsertArgs>(args: SelectSubset<T, poliza_historialUpsertArgs<ExtArgs>>): Prisma__poliza_historialClient<$Result.GetResult<Prisma.$poliza_historialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Poliza_historials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_historialCountArgs} args - Arguments to filter Poliza_historials to count.
     * @example
     * // Count the number of Poliza_historials
     * const count = await prisma.poliza_historial.count({
     *   where: {
     *     // ... the filter for the Poliza_historials we want to count
     *   }
     * })
    **/
    count<T extends poliza_historialCountArgs>(
      args?: Subset<T, poliza_historialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Poliza_historialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Poliza_historial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Poliza_historialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Poliza_historialAggregateArgs>(args: Subset<T, Poliza_historialAggregateArgs>): Prisma.PrismaPromise<GetPoliza_historialAggregateType<T>>

    /**
     * Group by Poliza_historial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_historialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends poliza_historialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: poliza_historialGroupByArgs['orderBy'] }
        : { orderBy?: poliza_historialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, poliza_historialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoliza_historialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the poliza_historial model
   */
  readonly fields: poliza_historialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for poliza_historial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__poliza_historialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the poliza_historial model
   */
  interface poliza_historialFieldRefs {
    readonly id: FieldRef<"poliza_historial", 'BigInt'>
    readonly poliza_id: FieldRef<"poliza_historial", 'BigInt'>
    readonly accion: FieldRef<"poliza_historial", 'String'>
    readonly created_at: FieldRef<"poliza_historial", 'DateTime'>
    readonly updated_at: FieldRef<"poliza_historial", 'DateTime'>
    readonly deleted_at: FieldRef<"poliza_historial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * poliza_historial findUnique
   */
  export type poliza_historialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_historial
     */
    select?: poliza_historialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_historial
     */
    omit?: poliza_historialOmit<ExtArgs> | null
    /**
     * Filter, which poliza_historial to fetch.
     */
    where: poliza_historialWhereUniqueInput
  }

  /**
   * poliza_historial findUniqueOrThrow
   */
  export type poliza_historialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_historial
     */
    select?: poliza_historialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_historial
     */
    omit?: poliza_historialOmit<ExtArgs> | null
    /**
     * Filter, which poliza_historial to fetch.
     */
    where: poliza_historialWhereUniqueInput
  }

  /**
   * poliza_historial findFirst
   */
  export type poliza_historialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_historial
     */
    select?: poliza_historialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_historial
     */
    omit?: poliza_historialOmit<ExtArgs> | null
    /**
     * Filter, which poliza_historial to fetch.
     */
    where?: poliza_historialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_historials to fetch.
     */
    orderBy?: poliza_historialOrderByWithRelationInput | poliza_historialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for poliza_historials.
     */
    cursor?: poliza_historialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_historials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of poliza_historials.
     */
    distinct?: Poliza_historialScalarFieldEnum | Poliza_historialScalarFieldEnum[]
  }

  /**
   * poliza_historial findFirstOrThrow
   */
  export type poliza_historialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_historial
     */
    select?: poliza_historialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_historial
     */
    omit?: poliza_historialOmit<ExtArgs> | null
    /**
     * Filter, which poliza_historial to fetch.
     */
    where?: poliza_historialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_historials to fetch.
     */
    orderBy?: poliza_historialOrderByWithRelationInput | poliza_historialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for poliza_historials.
     */
    cursor?: poliza_historialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_historials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of poliza_historials.
     */
    distinct?: Poliza_historialScalarFieldEnum | Poliza_historialScalarFieldEnum[]
  }

  /**
   * poliza_historial findMany
   */
  export type poliza_historialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_historial
     */
    select?: poliza_historialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_historial
     */
    omit?: poliza_historialOmit<ExtArgs> | null
    /**
     * Filter, which poliza_historials to fetch.
     */
    where?: poliza_historialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_historials to fetch.
     */
    orderBy?: poliza_historialOrderByWithRelationInput | poliza_historialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing poliza_historials.
     */
    cursor?: poliza_historialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_historials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_historials.
     */
    skip?: number
    distinct?: Poliza_historialScalarFieldEnum | Poliza_historialScalarFieldEnum[]
  }

  /**
   * poliza_historial create
   */
  export type poliza_historialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_historial
     */
    select?: poliza_historialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_historial
     */
    omit?: poliza_historialOmit<ExtArgs> | null
    /**
     * The data needed to create a poliza_historial.
     */
    data: XOR<poliza_historialCreateInput, poliza_historialUncheckedCreateInput>
  }

  /**
   * poliza_historial createMany
   */
  export type poliza_historialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many poliza_historials.
     */
    data: poliza_historialCreateManyInput | poliza_historialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * poliza_historial update
   */
  export type poliza_historialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_historial
     */
    select?: poliza_historialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_historial
     */
    omit?: poliza_historialOmit<ExtArgs> | null
    /**
     * The data needed to update a poliza_historial.
     */
    data: XOR<poliza_historialUpdateInput, poliza_historialUncheckedUpdateInput>
    /**
     * Choose, which poliza_historial to update.
     */
    where: poliza_historialWhereUniqueInput
  }

  /**
   * poliza_historial updateMany
   */
  export type poliza_historialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update poliza_historials.
     */
    data: XOR<poliza_historialUpdateManyMutationInput, poliza_historialUncheckedUpdateManyInput>
    /**
     * Filter which poliza_historials to update
     */
    where?: poliza_historialWhereInput
    /**
     * Limit how many poliza_historials to update.
     */
    limit?: number
  }

  /**
   * poliza_historial upsert
   */
  export type poliza_historialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_historial
     */
    select?: poliza_historialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_historial
     */
    omit?: poliza_historialOmit<ExtArgs> | null
    /**
     * The filter to search for the poliza_historial to update in case it exists.
     */
    where: poliza_historialWhereUniqueInput
    /**
     * In case the poliza_historial found by the `where` argument doesn't exist, create a new poliza_historial with this data.
     */
    create: XOR<poliza_historialCreateInput, poliza_historialUncheckedCreateInput>
    /**
     * In case the poliza_historial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<poliza_historialUpdateInput, poliza_historialUncheckedUpdateInput>
  }

  /**
   * poliza_historial delete
   */
  export type poliza_historialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_historial
     */
    select?: poliza_historialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_historial
     */
    omit?: poliza_historialOmit<ExtArgs> | null
    /**
     * Filter which poliza_historial to delete.
     */
    where: poliza_historialWhereUniqueInput
  }

  /**
   * poliza_historial deleteMany
   */
  export type poliza_historialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poliza_historials to delete
     */
    where?: poliza_historialWhereInput
    /**
     * Limit how many poliza_historials to delete.
     */
    limit?: number
  }

  /**
   * poliza_historial without action
   */
  export type poliza_historialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_historial
     */
    select?: poliza_historialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_historial
     */
    omit?: poliza_historialOmit<ExtArgs> | null
  }


  /**
   * Model poliza_recibos
   */

  export type AggregatePoliza_recibos = {
    _count: Poliza_recibosCountAggregateOutputType | null
    _avg: Poliza_recibosAvgAggregateOutputType | null
    _sum: Poliza_recibosSumAggregateOutputType | null
    _min: Poliza_recibosMinAggregateOutputType | null
    _max: Poliza_recibosMaxAggregateOutputType | null
  }

  export type Poliza_recibosAvgAggregateOutputType = {
    id: number | null
    poliza_id: number | null
    importe: Decimal | null
  }

  export type Poliza_recibosSumAggregateOutputType = {
    id: bigint | null
    poliza_id: bigint | null
    importe: Decimal | null
  }

  export type Poliza_recibosMinAggregateOutputType = {
    id: bigint | null
    poliza_id: bigint | null
    numeroRecibo: string | null
    vencimiento: Date | null
    importe: Decimal | null
    estatus: $Enums.poliza_recibos_estatus | null
    fechaPago: Date | null
    fechaCancelado: Date | null
    evidencia: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Poliza_recibosMaxAggregateOutputType = {
    id: bigint | null
    poliza_id: bigint | null
    numeroRecibo: string | null
    vencimiento: Date | null
    importe: Decimal | null
    estatus: $Enums.poliza_recibos_estatus | null
    fechaPago: Date | null
    fechaCancelado: Date | null
    evidencia: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Poliza_recibosCountAggregateOutputType = {
    id: number
    poliza_id: number
    numeroRecibo: number
    vencimiento: number
    importe: number
    estatus: number
    fechaPago: number
    fechaCancelado: number
    evidencia: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Poliza_recibosAvgAggregateInputType = {
    id?: true
    poliza_id?: true
    importe?: true
  }

  export type Poliza_recibosSumAggregateInputType = {
    id?: true
    poliza_id?: true
    importe?: true
  }

  export type Poliza_recibosMinAggregateInputType = {
    id?: true
    poliza_id?: true
    numeroRecibo?: true
    vencimiento?: true
    importe?: true
    estatus?: true
    fechaPago?: true
    fechaCancelado?: true
    evidencia?: true
    created_at?: true
    updated_at?: true
  }

  export type Poliza_recibosMaxAggregateInputType = {
    id?: true
    poliza_id?: true
    numeroRecibo?: true
    vencimiento?: true
    importe?: true
    estatus?: true
    fechaPago?: true
    fechaCancelado?: true
    evidencia?: true
    created_at?: true
    updated_at?: true
  }

  export type Poliza_recibosCountAggregateInputType = {
    id?: true
    poliza_id?: true
    numeroRecibo?: true
    vencimiento?: true
    importe?: true
    estatus?: true
    fechaPago?: true
    fechaCancelado?: true
    evidencia?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Poliza_recibosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poliza_recibos to aggregate.
     */
    where?: poliza_recibosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_recibos to fetch.
     */
    orderBy?: poliza_recibosOrderByWithRelationInput | poliza_recibosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: poliza_recibosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_recibos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_recibos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned poliza_recibos
    **/
    _count?: true | Poliza_recibosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Poliza_recibosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Poliza_recibosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Poliza_recibosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Poliza_recibosMaxAggregateInputType
  }

  export type GetPoliza_recibosAggregateType<T extends Poliza_recibosAggregateArgs> = {
        [P in keyof T & keyof AggregatePoliza_recibos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoliza_recibos[P]>
      : GetScalarType<T[P], AggregatePoliza_recibos[P]>
  }




  export type poliza_recibosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poliza_recibosWhereInput
    orderBy?: poliza_recibosOrderByWithAggregationInput | poliza_recibosOrderByWithAggregationInput[]
    by: Poliza_recibosScalarFieldEnum[] | Poliza_recibosScalarFieldEnum
    having?: poliza_recibosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Poliza_recibosCountAggregateInputType | true
    _avg?: Poliza_recibosAvgAggregateInputType
    _sum?: Poliza_recibosSumAggregateInputType
    _min?: Poliza_recibosMinAggregateInputType
    _max?: Poliza_recibosMaxAggregateInputType
  }

  export type Poliza_recibosGroupByOutputType = {
    id: bigint
    poliza_id: bigint
    numeroRecibo: string
    vencimiento: Date
    importe: Decimal
    estatus: $Enums.poliza_recibos_estatus
    fechaPago: Date | null
    fechaCancelado: Date | null
    evidencia: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Poliza_recibosCountAggregateOutputType | null
    _avg: Poliza_recibosAvgAggregateOutputType | null
    _sum: Poliza_recibosSumAggregateOutputType | null
    _min: Poliza_recibosMinAggregateOutputType | null
    _max: Poliza_recibosMaxAggregateOutputType | null
  }

  type GetPoliza_recibosGroupByPayload<T extends poliza_recibosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Poliza_recibosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Poliza_recibosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Poliza_recibosGroupByOutputType[P]>
            : GetScalarType<T[P], Poliza_recibosGroupByOutputType[P]>
        }
      >
    >


  export type poliza_recibosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poliza_id?: boolean
    numeroRecibo?: boolean
    vencimiento?: boolean
    importe?: boolean
    estatus?: boolean
    fechaPago?: boolean
    fechaCancelado?: boolean
    evidencia?: boolean
    created_at?: boolean
    updated_at?: boolean
    polizas?: boolean | polizasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poliza_recibos"]>



  export type poliza_recibosSelectScalar = {
    id?: boolean
    poliza_id?: boolean
    numeroRecibo?: boolean
    vencimiento?: boolean
    importe?: boolean
    estatus?: boolean
    fechaPago?: boolean
    fechaCancelado?: boolean
    evidencia?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type poliza_recibosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poliza_id" | "numeroRecibo" | "vencimiento" | "importe" | "estatus" | "fechaPago" | "fechaCancelado" | "evidencia" | "created_at" | "updated_at", ExtArgs["result"]["poliza_recibos"]>
  export type poliza_recibosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | polizasDefaultArgs<ExtArgs>
  }

  export type $poliza_recibosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "poliza_recibos"
    objects: {
      polizas: Prisma.$polizasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      poliza_id: bigint
      numeroRecibo: string
      vencimiento: Date
      importe: Prisma.Decimal
      estatus: $Enums.poliza_recibos_estatus
      fechaPago: Date | null
      fechaCancelado: Date | null
      evidencia: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["poliza_recibos"]>
    composites: {}
  }

  type poliza_recibosGetPayload<S extends boolean | null | undefined | poliza_recibosDefaultArgs> = $Result.GetResult<Prisma.$poliza_recibosPayload, S>

  type poliza_recibosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<poliza_recibosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Poliza_recibosCountAggregateInputType | true
    }

  export interface poliza_recibosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['poliza_recibos'], meta: { name: 'poliza_recibos' } }
    /**
     * Find zero or one Poliza_recibos that matches the filter.
     * @param {poliza_recibosFindUniqueArgs} args - Arguments to find a Poliza_recibos
     * @example
     * // Get one Poliza_recibos
     * const poliza_recibos = await prisma.poliza_recibos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends poliza_recibosFindUniqueArgs>(args: SelectSubset<T, poliza_recibosFindUniqueArgs<ExtArgs>>): Prisma__poliza_recibosClient<$Result.GetResult<Prisma.$poliza_recibosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Poliza_recibos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {poliza_recibosFindUniqueOrThrowArgs} args - Arguments to find a Poliza_recibos
     * @example
     * // Get one Poliza_recibos
     * const poliza_recibos = await prisma.poliza_recibos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends poliza_recibosFindUniqueOrThrowArgs>(args: SelectSubset<T, poliza_recibosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__poliza_recibosClient<$Result.GetResult<Prisma.$poliza_recibosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poliza_recibos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_recibosFindFirstArgs} args - Arguments to find a Poliza_recibos
     * @example
     * // Get one Poliza_recibos
     * const poliza_recibos = await prisma.poliza_recibos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends poliza_recibosFindFirstArgs>(args?: SelectSubset<T, poliza_recibosFindFirstArgs<ExtArgs>>): Prisma__poliza_recibosClient<$Result.GetResult<Prisma.$poliza_recibosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poliza_recibos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_recibosFindFirstOrThrowArgs} args - Arguments to find a Poliza_recibos
     * @example
     * // Get one Poliza_recibos
     * const poliza_recibos = await prisma.poliza_recibos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends poliza_recibosFindFirstOrThrowArgs>(args?: SelectSubset<T, poliza_recibosFindFirstOrThrowArgs<ExtArgs>>): Prisma__poliza_recibosClient<$Result.GetResult<Prisma.$poliza_recibosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Poliza_recibos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_recibosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Poliza_recibos
     * const poliza_recibos = await prisma.poliza_recibos.findMany()
     * 
     * // Get first 10 Poliza_recibos
     * const poliza_recibos = await prisma.poliza_recibos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poliza_recibosWithIdOnly = await prisma.poliza_recibos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends poliza_recibosFindManyArgs>(args?: SelectSubset<T, poliza_recibosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poliza_recibosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Poliza_recibos.
     * @param {poliza_recibosCreateArgs} args - Arguments to create a Poliza_recibos.
     * @example
     * // Create one Poliza_recibos
     * const Poliza_recibos = await prisma.poliza_recibos.create({
     *   data: {
     *     // ... data to create a Poliza_recibos
     *   }
     * })
     * 
     */
    create<T extends poliza_recibosCreateArgs>(args: SelectSubset<T, poliza_recibosCreateArgs<ExtArgs>>): Prisma__poliza_recibosClient<$Result.GetResult<Prisma.$poliza_recibosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Poliza_recibos.
     * @param {poliza_recibosCreateManyArgs} args - Arguments to create many Poliza_recibos.
     * @example
     * // Create many Poliza_recibos
     * const poliza_recibos = await prisma.poliza_recibos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends poliza_recibosCreateManyArgs>(args?: SelectSubset<T, poliza_recibosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Poliza_recibos.
     * @param {poliza_recibosDeleteArgs} args - Arguments to delete one Poliza_recibos.
     * @example
     * // Delete one Poliza_recibos
     * const Poliza_recibos = await prisma.poliza_recibos.delete({
     *   where: {
     *     // ... filter to delete one Poliza_recibos
     *   }
     * })
     * 
     */
    delete<T extends poliza_recibosDeleteArgs>(args: SelectSubset<T, poliza_recibosDeleteArgs<ExtArgs>>): Prisma__poliza_recibosClient<$Result.GetResult<Prisma.$poliza_recibosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Poliza_recibos.
     * @param {poliza_recibosUpdateArgs} args - Arguments to update one Poliza_recibos.
     * @example
     * // Update one Poliza_recibos
     * const poliza_recibos = await prisma.poliza_recibos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends poliza_recibosUpdateArgs>(args: SelectSubset<T, poliza_recibosUpdateArgs<ExtArgs>>): Prisma__poliza_recibosClient<$Result.GetResult<Prisma.$poliza_recibosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Poliza_recibos.
     * @param {poliza_recibosDeleteManyArgs} args - Arguments to filter Poliza_recibos to delete.
     * @example
     * // Delete a few Poliza_recibos
     * const { count } = await prisma.poliza_recibos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends poliza_recibosDeleteManyArgs>(args?: SelectSubset<T, poliza_recibosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Poliza_recibos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_recibosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Poliza_recibos
     * const poliza_recibos = await prisma.poliza_recibos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends poliza_recibosUpdateManyArgs>(args: SelectSubset<T, poliza_recibosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Poliza_recibos.
     * @param {poliza_recibosUpsertArgs} args - Arguments to update or create a Poliza_recibos.
     * @example
     * // Update or create a Poliza_recibos
     * const poliza_recibos = await prisma.poliza_recibos.upsert({
     *   create: {
     *     // ... data to create a Poliza_recibos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Poliza_recibos we want to update
     *   }
     * })
     */
    upsert<T extends poliza_recibosUpsertArgs>(args: SelectSubset<T, poliza_recibosUpsertArgs<ExtArgs>>): Prisma__poliza_recibosClient<$Result.GetResult<Prisma.$poliza_recibosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Poliza_recibos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_recibosCountArgs} args - Arguments to filter Poliza_recibos to count.
     * @example
     * // Count the number of Poliza_recibos
     * const count = await prisma.poliza_recibos.count({
     *   where: {
     *     // ... the filter for the Poliza_recibos we want to count
     *   }
     * })
    **/
    count<T extends poliza_recibosCountArgs>(
      args?: Subset<T, poliza_recibosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Poliza_recibosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Poliza_recibos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Poliza_recibosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Poliza_recibosAggregateArgs>(args: Subset<T, Poliza_recibosAggregateArgs>): Prisma.PrismaPromise<GetPoliza_recibosAggregateType<T>>

    /**
     * Group by Poliza_recibos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poliza_recibosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends poliza_recibosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: poliza_recibosGroupByArgs['orderBy'] }
        : { orderBy?: poliza_recibosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, poliza_recibosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoliza_recibosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the poliza_recibos model
   */
  readonly fields: poliza_recibosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for poliza_recibos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__poliza_recibosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    polizas<T extends polizasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, polizasDefaultArgs<ExtArgs>>): Prisma__polizasClient<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the poliza_recibos model
   */
  interface poliza_recibosFieldRefs {
    readonly id: FieldRef<"poliza_recibos", 'BigInt'>
    readonly poliza_id: FieldRef<"poliza_recibos", 'BigInt'>
    readonly numeroRecibo: FieldRef<"poliza_recibos", 'String'>
    readonly vencimiento: FieldRef<"poliza_recibos", 'DateTime'>
    readonly importe: FieldRef<"poliza_recibos", 'Decimal'>
    readonly estatus: FieldRef<"poliza_recibos", 'poliza_recibos_estatus'>
    readonly fechaPago: FieldRef<"poliza_recibos", 'DateTime'>
    readonly fechaCancelado: FieldRef<"poliza_recibos", 'DateTime'>
    readonly evidencia: FieldRef<"poliza_recibos", 'String'>
    readonly created_at: FieldRef<"poliza_recibos", 'DateTime'>
    readonly updated_at: FieldRef<"poliza_recibos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * poliza_recibos findUnique
   */
  export type poliza_recibosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
    /**
     * Filter, which poliza_recibos to fetch.
     */
    where: poliza_recibosWhereUniqueInput
  }

  /**
   * poliza_recibos findUniqueOrThrow
   */
  export type poliza_recibosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
    /**
     * Filter, which poliza_recibos to fetch.
     */
    where: poliza_recibosWhereUniqueInput
  }

  /**
   * poliza_recibos findFirst
   */
  export type poliza_recibosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
    /**
     * Filter, which poliza_recibos to fetch.
     */
    where?: poliza_recibosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_recibos to fetch.
     */
    orderBy?: poliza_recibosOrderByWithRelationInput | poliza_recibosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for poliza_recibos.
     */
    cursor?: poliza_recibosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_recibos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_recibos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of poliza_recibos.
     */
    distinct?: Poliza_recibosScalarFieldEnum | Poliza_recibosScalarFieldEnum[]
  }

  /**
   * poliza_recibos findFirstOrThrow
   */
  export type poliza_recibosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
    /**
     * Filter, which poliza_recibos to fetch.
     */
    where?: poliza_recibosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_recibos to fetch.
     */
    orderBy?: poliza_recibosOrderByWithRelationInput | poliza_recibosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for poliza_recibos.
     */
    cursor?: poliza_recibosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_recibos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_recibos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of poliza_recibos.
     */
    distinct?: Poliza_recibosScalarFieldEnum | Poliza_recibosScalarFieldEnum[]
  }

  /**
   * poliza_recibos findMany
   */
  export type poliza_recibosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
    /**
     * Filter, which poliza_recibos to fetch.
     */
    where?: poliza_recibosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poliza_recibos to fetch.
     */
    orderBy?: poliza_recibosOrderByWithRelationInput | poliza_recibosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing poliza_recibos.
     */
    cursor?: poliza_recibosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poliza_recibos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poliza_recibos.
     */
    skip?: number
    distinct?: Poliza_recibosScalarFieldEnum | Poliza_recibosScalarFieldEnum[]
  }

  /**
   * poliza_recibos create
   */
  export type poliza_recibosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
    /**
     * The data needed to create a poliza_recibos.
     */
    data: XOR<poliza_recibosCreateInput, poliza_recibosUncheckedCreateInput>
  }

  /**
   * poliza_recibos createMany
   */
  export type poliza_recibosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many poliza_recibos.
     */
    data: poliza_recibosCreateManyInput | poliza_recibosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * poliza_recibos update
   */
  export type poliza_recibosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
    /**
     * The data needed to update a poliza_recibos.
     */
    data: XOR<poliza_recibosUpdateInput, poliza_recibosUncheckedUpdateInput>
    /**
     * Choose, which poliza_recibos to update.
     */
    where: poliza_recibosWhereUniqueInput
  }

  /**
   * poliza_recibos updateMany
   */
  export type poliza_recibosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update poliza_recibos.
     */
    data: XOR<poliza_recibosUpdateManyMutationInput, poliza_recibosUncheckedUpdateManyInput>
    /**
     * Filter which poliza_recibos to update
     */
    where?: poliza_recibosWhereInput
    /**
     * Limit how many poliza_recibos to update.
     */
    limit?: number
  }

  /**
   * poliza_recibos upsert
   */
  export type poliza_recibosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
    /**
     * The filter to search for the poliza_recibos to update in case it exists.
     */
    where: poliza_recibosWhereUniqueInput
    /**
     * In case the poliza_recibos found by the `where` argument doesn't exist, create a new poliza_recibos with this data.
     */
    create: XOR<poliza_recibosCreateInput, poliza_recibosUncheckedCreateInput>
    /**
     * In case the poliza_recibos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<poliza_recibosUpdateInput, poliza_recibosUncheckedUpdateInput>
  }

  /**
   * poliza_recibos delete
   */
  export type poliza_recibosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
    /**
     * Filter which poliza_recibos to delete.
     */
    where: poliza_recibosWhereUniqueInput
  }

  /**
   * poliza_recibos deleteMany
   */
  export type poliza_recibosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poliza_recibos to delete
     */
    where?: poliza_recibosWhereInput
    /**
     * Limit how many poliza_recibos to delete.
     */
    limit?: number
  }

  /**
   * poliza_recibos without action
   */
  export type poliza_recibosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
  }


  /**
   * Model polizas
   */

  export type AggregatePolizas = {
    _count: PolizasCountAggregateOutputType | null
    _avg: PolizasAvgAggregateOutputType | null
    _sum: PolizasSumAggregateOutputType | null
    _min: PolizasMinAggregateOutputType | null
    _max: PolizasMaxAggregateOutputType | null
  }

  export type PolizasAvgAggregateOutputType = {
    id: number | null
    antiguedad: number | null
    primaNeta: Decimal | null
    financiamiento: Decimal | null
    primaTotal: Decimal | null
    estatus_id: number | null
    comisionAgente: Decimal | null
    pagoInicial: Decimal | null
    pagoSubsecuente: Decimal | null
    cliente_id: number | null
    formaPago_id: number | null
    tipoVencimiento_id: number | null
    compania_id: number | null
    subAgente_id: number | null
    ramo_id: number | null
    metodoPago_id: number | null
    moneda_id: number | null
    producto_id: number | null
  }

  export type PolizasSumAggregateOutputType = {
    id: bigint | null
    antiguedad: number | null
    primaNeta: Decimal | null
    financiamiento: Decimal | null
    primaTotal: Decimal | null
    estatus_id: bigint | null
    comisionAgente: Decimal | null
    pagoInicial: Decimal | null
    pagoSubsecuente: Decimal | null
    cliente_id: bigint | null
    formaPago_id: bigint | null
    tipoVencimiento_id: bigint | null
    compania_id: bigint | null
    subAgente_id: bigint | null
    ramo_id: bigint | null
    metodoPago_id: bigint | null
    moneda_id: bigint | null
    producto_id: bigint | null
  }

  export type PolizasMinAggregateOutputType = {
    id: bigint | null
    numeroPoliza: string | null
    numeroCliente: string | null
    inicioVigencia: Date | null
    finVigencia: Date | null
    antiguedad: number | null
    primaNeta: Decimal | null
    financiamiento: Decimal | null
    primaTotal: Decimal | null
    estatus_id: bigint | null
    comisionAgente: Decimal | null
    pagoInicial: Decimal | null
    pagoSubsecuente: Decimal | null
    cliente_id: bigint | null
    formaPago_id: bigint | null
    tipoVencimiento_id: bigint | null
    compania_id: bigint | null
    subAgente_id: bigint | null
    ramo_id: bigint | null
    metodoPago_id: bigint | null
    moneda_id: bigint | null
    producto_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PolizasMaxAggregateOutputType = {
    id: bigint | null
    numeroPoliza: string | null
    numeroCliente: string | null
    inicioVigencia: Date | null
    finVigencia: Date | null
    antiguedad: number | null
    primaNeta: Decimal | null
    financiamiento: Decimal | null
    primaTotal: Decimal | null
    estatus_id: bigint | null
    comisionAgente: Decimal | null
    pagoInicial: Decimal | null
    pagoSubsecuente: Decimal | null
    cliente_id: bigint | null
    formaPago_id: bigint | null
    tipoVencimiento_id: bigint | null
    compania_id: bigint | null
    subAgente_id: bigint | null
    ramo_id: bigint | null
    metodoPago_id: bigint | null
    moneda_id: bigint | null
    producto_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PolizasCountAggregateOutputType = {
    id: number
    numeroPoliza: number
    numeroCliente: number
    inicioVigencia: number
    finVigencia: number
    antiguedad: number
    primaNeta: number
    financiamiento: number
    primaTotal: number
    estatus_id: number
    comisionAgente: number
    pagoInicial: number
    pagoSubsecuente: number
    cliente_id: number
    formaPago_id: number
    tipoVencimiento_id: number
    compania_id: number
    subAgente_id: number
    ramo_id: number
    metodoPago_id: number
    moneda_id: number
    producto_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PolizasAvgAggregateInputType = {
    id?: true
    antiguedad?: true
    primaNeta?: true
    financiamiento?: true
    primaTotal?: true
    estatus_id?: true
    comisionAgente?: true
    pagoInicial?: true
    pagoSubsecuente?: true
    cliente_id?: true
    formaPago_id?: true
    tipoVencimiento_id?: true
    compania_id?: true
    subAgente_id?: true
    ramo_id?: true
    metodoPago_id?: true
    moneda_id?: true
    producto_id?: true
  }

  export type PolizasSumAggregateInputType = {
    id?: true
    antiguedad?: true
    primaNeta?: true
    financiamiento?: true
    primaTotal?: true
    estatus_id?: true
    comisionAgente?: true
    pagoInicial?: true
    pagoSubsecuente?: true
    cliente_id?: true
    formaPago_id?: true
    tipoVencimiento_id?: true
    compania_id?: true
    subAgente_id?: true
    ramo_id?: true
    metodoPago_id?: true
    moneda_id?: true
    producto_id?: true
  }

  export type PolizasMinAggregateInputType = {
    id?: true
    numeroPoliza?: true
    numeroCliente?: true
    inicioVigencia?: true
    finVigencia?: true
    antiguedad?: true
    primaNeta?: true
    financiamiento?: true
    primaTotal?: true
    estatus_id?: true
    comisionAgente?: true
    pagoInicial?: true
    pagoSubsecuente?: true
    cliente_id?: true
    formaPago_id?: true
    tipoVencimiento_id?: true
    compania_id?: true
    subAgente_id?: true
    ramo_id?: true
    metodoPago_id?: true
    moneda_id?: true
    producto_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PolizasMaxAggregateInputType = {
    id?: true
    numeroPoliza?: true
    numeroCliente?: true
    inicioVigencia?: true
    finVigencia?: true
    antiguedad?: true
    primaNeta?: true
    financiamiento?: true
    primaTotal?: true
    estatus_id?: true
    comisionAgente?: true
    pagoInicial?: true
    pagoSubsecuente?: true
    cliente_id?: true
    formaPago_id?: true
    tipoVencimiento_id?: true
    compania_id?: true
    subAgente_id?: true
    ramo_id?: true
    metodoPago_id?: true
    moneda_id?: true
    producto_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PolizasCountAggregateInputType = {
    id?: true
    numeroPoliza?: true
    numeroCliente?: true
    inicioVigencia?: true
    finVigencia?: true
    antiguedad?: true
    primaNeta?: true
    financiamiento?: true
    primaTotal?: true
    estatus_id?: true
    comisionAgente?: true
    pagoInicial?: true
    pagoSubsecuente?: true
    cliente_id?: true
    formaPago_id?: true
    tipoVencimiento_id?: true
    compania_id?: true
    subAgente_id?: true
    ramo_id?: true
    metodoPago_id?: true
    moneda_id?: true
    producto_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PolizasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which polizas to aggregate.
     */
    where?: polizasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of polizas to fetch.
     */
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: polizasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` polizas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` polizas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned polizas
    **/
    _count?: true | PolizasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolizasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolizasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolizasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolizasMaxAggregateInputType
  }

  export type GetPolizasAggregateType<T extends PolizasAggregateArgs> = {
        [P in keyof T & keyof AggregatePolizas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolizas[P]>
      : GetScalarType<T[P], AggregatePolizas[P]>
  }




  export type polizasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: polizasWhereInput
    orderBy?: polizasOrderByWithAggregationInput | polizasOrderByWithAggregationInput[]
    by: PolizasScalarFieldEnum[] | PolizasScalarFieldEnum
    having?: polizasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolizasCountAggregateInputType | true
    _avg?: PolizasAvgAggregateInputType
    _sum?: PolizasSumAggregateInputType
    _min?: PolizasMinAggregateInputType
    _max?: PolizasMaxAggregateInputType
  }

  export type PolizasGroupByOutputType = {
    id: bigint
    numeroPoliza: string | null
    numeroCliente: string | null
    inicioVigencia: Date
    finVigencia: Date
    antiguedad: number
    primaNeta: Decimal
    financiamiento: Decimal | null
    primaTotal: Decimal
    estatus_id: bigint
    comisionAgente: Decimal | null
    pagoInicial: Decimal
    pagoSubsecuente: Decimal
    cliente_id: bigint
    formaPago_id: bigint
    tipoVencimiento_id: bigint
    compania_id: bigint
    subAgente_id: bigint | null
    ramo_id: bigint
    metodoPago_id: bigint
    moneda_id: bigint
    producto_id: bigint
    created_at: Date | null
    updated_at: Date | null
    _count: PolizasCountAggregateOutputType | null
    _avg: PolizasAvgAggregateOutputType | null
    _sum: PolizasSumAggregateOutputType | null
    _min: PolizasMinAggregateOutputType | null
    _max: PolizasMaxAggregateOutputType | null
  }

  type GetPolizasGroupByPayload<T extends polizasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolizasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolizasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolizasGroupByOutputType[P]>
            : GetScalarType<T[P], PolizasGroupByOutputType[P]>
        }
      >
    >


  export type polizasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroPoliza?: boolean
    numeroCliente?: boolean
    inicioVigencia?: boolean
    finVigencia?: boolean
    antiguedad?: boolean
    primaNeta?: boolean
    financiamiento?: boolean
    primaTotal?: boolean
    estatus_id?: boolean
    comisionAgente?: boolean
    pagoInicial?: boolean
    pagoSubsecuente?: boolean
    cliente_id?: boolean
    formaPago_id?: boolean
    tipoVencimiento_id?: boolean
    compania_id?: boolean
    subAgente_id?: boolean
    ramo_id?: boolean
    metodoPago_id?: boolean
    moneda_id?: boolean
    producto_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    poliza_recibos?: boolean | polizas$poliza_recibosArgs<ExtArgs>
    clientes?: boolean | clientesDefaultArgs<ExtArgs>
    compania?: boolean | companiaDefaultArgs<ExtArgs>
    formas_de_pago?: boolean | formas_de_pagoDefaultArgs<ExtArgs>
    metodos_de_pago?: boolean | metodos_de_pagoDefaultArgs<ExtArgs>
    monedas?: boolean | monedasDefaultArgs<ExtArgs>
    companias_productos?: boolean | companias_productosDefaultArgs<ExtArgs>
    ramos?: boolean | ramosDefaultArgs<ExtArgs>
    usuarios?: boolean | polizas$usuariosArgs<ExtArgs>
    tipos_de_vencimiento?: boolean | tipos_de_vencimientoDefaultArgs<ExtArgs>
    _count?: boolean | PolizasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["polizas"]>



  export type polizasSelectScalar = {
    id?: boolean
    numeroPoliza?: boolean
    numeroCliente?: boolean
    inicioVigencia?: boolean
    finVigencia?: boolean
    antiguedad?: boolean
    primaNeta?: boolean
    financiamiento?: boolean
    primaTotal?: boolean
    estatus_id?: boolean
    comisionAgente?: boolean
    pagoInicial?: boolean
    pagoSubsecuente?: boolean
    cliente_id?: boolean
    formaPago_id?: boolean
    tipoVencimiento_id?: boolean
    compania_id?: boolean
    subAgente_id?: boolean
    ramo_id?: boolean
    metodoPago_id?: boolean
    moneda_id?: boolean
    producto_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type polizasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numeroPoliza" | "numeroCliente" | "inicioVigencia" | "finVigencia" | "antiguedad" | "primaNeta" | "financiamiento" | "primaTotal" | "estatus_id" | "comisionAgente" | "pagoInicial" | "pagoSubsecuente" | "cliente_id" | "formaPago_id" | "tipoVencimiento_id" | "compania_id" | "subAgente_id" | "ramo_id" | "metodoPago_id" | "moneda_id" | "producto_id" | "created_at" | "updated_at", ExtArgs["result"]["polizas"]>
  export type polizasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poliza_recibos?: boolean | polizas$poliza_recibosArgs<ExtArgs>
    clientes?: boolean | clientesDefaultArgs<ExtArgs>
    compania?: boolean | companiaDefaultArgs<ExtArgs>
    formas_de_pago?: boolean | formas_de_pagoDefaultArgs<ExtArgs>
    metodos_de_pago?: boolean | metodos_de_pagoDefaultArgs<ExtArgs>
    monedas?: boolean | monedasDefaultArgs<ExtArgs>
    companias_productos?: boolean | companias_productosDefaultArgs<ExtArgs>
    ramos?: boolean | ramosDefaultArgs<ExtArgs>
    usuarios?: boolean | polizas$usuariosArgs<ExtArgs>
    tipos_de_vencimiento?: boolean | tipos_de_vencimientoDefaultArgs<ExtArgs>
    _count?: boolean | PolizasCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $polizasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "polizas"
    objects: {
      poliza_recibos: Prisma.$poliza_recibosPayload<ExtArgs>[]
      clientes: Prisma.$clientesPayload<ExtArgs>
      compania: Prisma.$companiaPayload<ExtArgs>
      formas_de_pago: Prisma.$formas_de_pagoPayload<ExtArgs>
      metodos_de_pago: Prisma.$metodos_de_pagoPayload<ExtArgs>
      monedas: Prisma.$monedasPayload<ExtArgs>
      companias_productos: Prisma.$companias_productosPayload<ExtArgs>
      ramos: Prisma.$ramosPayload<ExtArgs>
      usuarios: Prisma.$usuariosPayload<ExtArgs> | null
      tipos_de_vencimiento: Prisma.$tipos_de_vencimientoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      numeroPoliza: string | null
      numeroCliente: string | null
      inicioVigencia: Date
      finVigencia: Date
      antiguedad: number
      primaNeta: Prisma.Decimal
      financiamiento: Prisma.Decimal | null
      primaTotal: Prisma.Decimal
      estatus_id: bigint
      comisionAgente: Prisma.Decimal | null
      pagoInicial: Prisma.Decimal
      pagoSubsecuente: Prisma.Decimal
      cliente_id: bigint
      formaPago_id: bigint
      tipoVencimiento_id: bigint
      compania_id: bigint
      subAgente_id: bigint | null
      ramo_id: bigint
      metodoPago_id: bigint
      moneda_id: bigint
      producto_id: bigint
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["polizas"]>
    composites: {}
  }

  type polizasGetPayload<S extends boolean | null | undefined | polizasDefaultArgs> = $Result.GetResult<Prisma.$polizasPayload, S>

  type polizasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<polizasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PolizasCountAggregateInputType | true
    }

  export interface polizasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['polizas'], meta: { name: 'polizas' } }
    /**
     * Find zero or one Polizas that matches the filter.
     * @param {polizasFindUniqueArgs} args - Arguments to find a Polizas
     * @example
     * // Get one Polizas
     * const polizas = await prisma.polizas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends polizasFindUniqueArgs>(args: SelectSubset<T, polizasFindUniqueArgs<ExtArgs>>): Prisma__polizasClient<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Polizas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {polizasFindUniqueOrThrowArgs} args - Arguments to find a Polizas
     * @example
     * // Get one Polizas
     * const polizas = await prisma.polizas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends polizasFindUniqueOrThrowArgs>(args: SelectSubset<T, polizasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__polizasClient<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Polizas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {polizasFindFirstArgs} args - Arguments to find a Polizas
     * @example
     * // Get one Polizas
     * const polizas = await prisma.polizas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends polizasFindFirstArgs>(args?: SelectSubset<T, polizasFindFirstArgs<ExtArgs>>): Prisma__polizasClient<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Polizas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {polizasFindFirstOrThrowArgs} args - Arguments to find a Polizas
     * @example
     * // Get one Polizas
     * const polizas = await prisma.polizas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends polizasFindFirstOrThrowArgs>(args?: SelectSubset<T, polizasFindFirstOrThrowArgs<ExtArgs>>): Prisma__polizasClient<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Polizas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {polizasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Polizas
     * const polizas = await prisma.polizas.findMany()
     * 
     * // Get first 10 Polizas
     * const polizas = await prisma.polizas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const polizasWithIdOnly = await prisma.polizas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends polizasFindManyArgs>(args?: SelectSubset<T, polizasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Polizas.
     * @param {polizasCreateArgs} args - Arguments to create a Polizas.
     * @example
     * // Create one Polizas
     * const Polizas = await prisma.polizas.create({
     *   data: {
     *     // ... data to create a Polizas
     *   }
     * })
     * 
     */
    create<T extends polizasCreateArgs>(args: SelectSubset<T, polizasCreateArgs<ExtArgs>>): Prisma__polizasClient<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Polizas.
     * @param {polizasCreateManyArgs} args - Arguments to create many Polizas.
     * @example
     * // Create many Polizas
     * const polizas = await prisma.polizas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends polizasCreateManyArgs>(args?: SelectSubset<T, polizasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Polizas.
     * @param {polizasDeleteArgs} args - Arguments to delete one Polizas.
     * @example
     * // Delete one Polizas
     * const Polizas = await prisma.polizas.delete({
     *   where: {
     *     // ... filter to delete one Polizas
     *   }
     * })
     * 
     */
    delete<T extends polizasDeleteArgs>(args: SelectSubset<T, polizasDeleteArgs<ExtArgs>>): Prisma__polizasClient<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Polizas.
     * @param {polizasUpdateArgs} args - Arguments to update one Polizas.
     * @example
     * // Update one Polizas
     * const polizas = await prisma.polizas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends polizasUpdateArgs>(args: SelectSubset<T, polizasUpdateArgs<ExtArgs>>): Prisma__polizasClient<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Polizas.
     * @param {polizasDeleteManyArgs} args - Arguments to filter Polizas to delete.
     * @example
     * // Delete a few Polizas
     * const { count } = await prisma.polizas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends polizasDeleteManyArgs>(args?: SelectSubset<T, polizasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Polizas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {polizasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Polizas
     * const polizas = await prisma.polizas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends polizasUpdateManyArgs>(args: SelectSubset<T, polizasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Polizas.
     * @param {polizasUpsertArgs} args - Arguments to update or create a Polizas.
     * @example
     * // Update or create a Polizas
     * const polizas = await prisma.polizas.upsert({
     *   create: {
     *     // ... data to create a Polizas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Polizas we want to update
     *   }
     * })
     */
    upsert<T extends polizasUpsertArgs>(args: SelectSubset<T, polizasUpsertArgs<ExtArgs>>): Prisma__polizasClient<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Polizas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {polizasCountArgs} args - Arguments to filter Polizas to count.
     * @example
     * // Count the number of Polizas
     * const count = await prisma.polizas.count({
     *   where: {
     *     // ... the filter for the Polizas we want to count
     *   }
     * })
    **/
    count<T extends polizasCountArgs>(
      args?: Subset<T, polizasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolizasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Polizas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolizasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolizasAggregateArgs>(args: Subset<T, PolizasAggregateArgs>): Prisma.PrismaPromise<GetPolizasAggregateType<T>>

    /**
     * Group by Polizas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {polizasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends polizasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: polizasGroupByArgs['orderBy'] }
        : { orderBy?: polizasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, polizasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolizasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the polizas model
   */
  readonly fields: polizasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for polizas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__polizasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    poliza_recibos<T extends polizas$poliza_recibosArgs<ExtArgs> = {}>(args?: Subset<T, polizas$poliza_recibosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poliza_recibosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientes<T extends clientesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clientesDefaultArgs<ExtArgs>>): Prisma__clientesClient<$Result.GetResult<Prisma.$clientesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    compania<T extends companiaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiaDefaultArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    formas_de_pago<T extends formas_de_pagoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, formas_de_pagoDefaultArgs<ExtArgs>>): Prisma__formas_de_pagoClient<$Result.GetResult<Prisma.$formas_de_pagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    metodos_de_pago<T extends metodos_de_pagoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, metodos_de_pagoDefaultArgs<ExtArgs>>): Prisma__metodos_de_pagoClient<$Result.GetResult<Prisma.$metodos_de_pagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    monedas<T extends monedasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, monedasDefaultArgs<ExtArgs>>): Prisma__monedasClient<$Result.GetResult<Prisma.$monedasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    companias_productos<T extends companias_productosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companias_productosDefaultArgs<ExtArgs>>): Prisma__companias_productosClient<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ramos<T extends ramosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ramosDefaultArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuarios<T extends polizas$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, polizas$usuariosArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tipos_de_vencimiento<T extends tipos_de_vencimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipos_de_vencimientoDefaultArgs<ExtArgs>>): Prisma__tipos_de_vencimientoClient<$Result.GetResult<Prisma.$tipos_de_vencimientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the polizas model
   */
  interface polizasFieldRefs {
    readonly id: FieldRef<"polizas", 'BigInt'>
    readonly numeroPoliza: FieldRef<"polizas", 'String'>
    readonly numeroCliente: FieldRef<"polizas", 'String'>
    readonly inicioVigencia: FieldRef<"polizas", 'DateTime'>
    readonly finVigencia: FieldRef<"polizas", 'DateTime'>
    readonly antiguedad: FieldRef<"polizas", 'Int'>
    readonly primaNeta: FieldRef<"polizas", 'Decimal'>
    readonly financiamiento: FieldRef<"polizas", 'Decimal'>
    readonly primaTotal: FieldRef<"polizas", 'Decimal'>
    readonly estatus_id: FieldRef<"polizas", 'BigInt'>
    readonly comisionAgente: FieldRef<"polizas", 'Decimal'>
    readonly pagoInicial: FieldRef<"polizas", 'Decimal'>
    readonly pagoSubsecuente: FieldRef<"polizas", 'Decimal'>
    readonly cliente_id: FieldRef<"polizas", 'BigInt'>
    readonly formaPago_id: FieldRef<"polizas", 'BigInt'>
    readonly tipoVencimiento_id: FieldRef<"polizas", 'BigInt'>
    readonly compania_id: FieldRef<"polizas", 'BigInt'>
    readonly subAgente_id: FieldRef<"polizas", 'BigInt'>
    readonly ramo_id: FieldRef<"polizas", 'BigInt'>
    readonly metodoPago_id: FieldRef<"polizas", 'BigInt'>
    readonly moneda_id: FieldRef<"polizas", 'BigInt'>
    readonly producto_id: FieldRef<"polizas", 'BigInt'>
    readonly created_at: FieldRef<"polizas", 'DateTime'>
    readonly updated_at: FieldRef<"polizas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * polizas findUnique
   */
  export type polizasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    /**
     * Filter, which polizas to fetch.
     */
    where: polizasWhereUniqueInput
  }

  /**
   * polizas findUniqueOrThrow
   */
  export type polizasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    /**
     * Filter, which polizas to fetch.
     */
    where: polizasWhereUniqueInput
  }

  /**
   * polizas findFirst
   */
  export type polizasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    /**
     * Filter, which polizas to fetch.
     */
    where?: polizasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of polizas to fetch.
     */
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for polizas.
     */
    cursor?: polizasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` polizas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` polizas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of polizas.
     */
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * polizas findFirstOrThrow
   */
  export type polizasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    /**
     * Filter, which polizas to fetch.
     */
    where?: polizasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of polizas to fetch.
     */
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for polizas.
     */
    cursor?: polizasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` polizas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` polizas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of polizas.
     */
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * polizas findMany
   */
  export type polizasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    /**
     * Filter, which polizas to fetch.
     */
    where?: polizasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of polizas to fetch.
     */
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing polizas.
     */
    cursor?: polizasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` polizas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` polizas.
     */
    skip?: number
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * polizas create
   */
  export type polizasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    /**
     * The data needed to create a polizas.
     */
    data: XOR<polizasCreateInput, polizasUncheckedCreateInput>
  }

  /**
   * polizas createMany
   */
  export type polizasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many polizas.
     */
    data: polizasCreateManyInput | polizasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * polizas update
   */
  export type polizasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    /**
     * The data needed to update a polizas.
     */
    data: XOR<polizasUpdateInput, polizasUncheckedUpdateInput>
    /**
     * Choose, which polizas to update.
     */
    where: polizasWhereUniqueInput
  }

  /**
   * polizas updateMany
   */
  export type polizasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update polizas.
     */
    data: XOR<polizasUpdateManyMutationInput, polizasUncheckedUpdateManyInput>
    /**
     * Filter which polizas to update
     */
    where?: polizasWhereInput
    /**
     * Limit how many polizas to update.
     */
    limit?: number
  }

  /**
   * polizas upsert
   */
  export type polizasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    /**
     * The filter to search for the polizas to update in case it exists.
     */
    where: polizasWhereUniqueInput
    /**
     * In case the polizas found by the `where` argument doesn't exist, create a new polizas with this data.
     */
    create: XOR<polizasCreateInput, polizasUncheckedCreateInput>
    /**
     * In case the polizas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<polizasUpdateInput, polizasUncheckedUpdateInput>
  }

  /**
   * polizas delete
   */
  export type polizasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    /**
     * Filter which polizas to delete.
     */
    where: polizasWhereUniqueInput
  }

  /**
   * polizas deleteMany
   */
  export type polizasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which polizas to delete
     */
    where?: polizasWhereInput
    /**
     * Limit how many polizas to delete.
     */
    limit?: number
  }

  /**
   * polizas.poliza_recibos
   */
  export type polizas$poliza_recibosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poliza_recibos
     */
    select?: poliza_recibosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poliza_recibos
     */
    omit?: poliza_recibosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poliza_recibosInclude<ExtArgs> | null
    where?: poliza_recibosWhereInput
    orderBy?: poliza_recibosOrderByWithRelationInput | poliza_recibosOrderByWithRelationInput[]
    cursor?: poliza_recibosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Poliza_recibosScalarFieldEnum | Poliza_recibosScalarFieldEnum[]
  }

  /**
   * polizas.usuarios
   */
  export type polizas$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    where?: usuariosWhereInput
  }

  /**
   * polizas without action
   */
  export type polizasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
  }


  /**
   * Model ramos
   */

  export type AggregateRamos = {
    _count: RamosCountAggregateOutputType | null
    _avg: RamosAvgAggregateOutputType | null
    _sum: RamosSumAggregateOutputType | null
    _min: RamosMinAggregateOutputType | null
    _max: RamosMaxAggregateOutputType | null
  }

  export type RamosAvgAggregateOutputType = {
    id: number | null
  }

  export type RamosSumAggregateOutputType = {
    id: bigint | null
  }

  export type RamosMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type RamosMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type RamosCountAggregateOutputType = {
    id: number
    label: number
    estatus: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type RamosAvgAggregateInputType = {
    id?: true
  }

  export type RamosSumAggregateInputType = {
    id?: true
  }

  export type RamosMinAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type RamosMaxAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type RamosCountAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type RamosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramos to aggregate.
     */
    where?: ramosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramos to fetch.
     */
    orderBy?: ramosOrderByWithRelationInput | ramosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ramosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ramos
    **/
    _count?: true | RamosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RamosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RamosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RamosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RamosMaxAggregateInputType
  }

  export type GetRamosAggregateType<T extends RamosAggregateArgs> = {
        [P in keyof T & keyof AggregateRamos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRamos[P]>
      : GetScalarType<T[P], AggregateRamos[P]>
  }




  export type ramosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ramosWhereInput
    orderBy?: ramosOrderByWithAggregationInput | ramosOrderByWithAggregationInput[]
    by: RamosScalarFieldEnum[] | RamosScalarFieldEnum
    having?: ramosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RamosCountAggregateInputType | true
    _avg?: RamosAvgAggregateInputType
    _sum?: RamosSumAggregateInputType
    _min?: RamosMinAggregateInputType
    _max?: RamosMaxAggregateInputType
  }

  export type RamosGroupByOutputType = {
    id: bigint
    label: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: RamosCountAggregateOutputType | null
    _avg: RamosAvgAggregateOutputType | null
    _sum: RamosSumAggregateOutputType | null
    _min: RamosMinAggregateOutputType | null
    _max: RamosMaxAggregateOutputType | null
  }

  type GetRamosGroupByPayload<T extends ramosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RamosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RamosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RamosGroupByOutputType[P]>
            : GetScalarType<T[P], RamosGroupByOutputType[P]>
        }
      >
    >


  export type ramosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    companias_productos?: boolean | ramos$companias_productosArgs<ExtArgs>
    companias_ramos?: boolean | ramos$companias_ramosArgs<ExtArgs>
    polizas?: boolean | ramos$polizasArgs<ExtArgs>
    _count?: boolean | RamosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ramos"]>



  export type ramosSelectScalar = {
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type ramosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "estatus" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["ramos"]>
  export type ramosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companias_productos?: boolean | ramos$companias_productosArgs<ExtArgs>
    companias_ramos?: boolean | ramos$companias_ramosArgs<ExtArgs>
    polizas?: boolean | ramos$polizasArgs<ExtArgs>
    _count?: boolean | RamosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ramosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ramos"
    objects: {
      companias_productos: Prisma.$companias_productosPayload<ExtArgs>[]
      companias_ramos: Prisma.$companias_ramosPayload<ExtArgs>[]
      polizas: Prisma.$polizasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["ramos"]>
    composites: {}
  }

  type ramosGetPayload<S extends boolean | null | undefined | ramosDefaultArgs> = $Result.GetResult<Prisma.$ramosPayload, S>

  type ramosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ramosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RamosCountAggregateInputType | true
    }

  export interface ramosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ramos'], meta: { name: 'ramos' } }
    /**
     * Find zero or one Ramos that matches the filter.
     * @param {ramosFindUniqueArgs} args - Arguments to find a Ramos
     * @example
     * // Get one Ramos
     * const ramos = await prisma.ramos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ramosFindUniqueArgs>(args: SelectSubset<T, ramosFindUniqueArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ramos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ramosFindUniqueOrThrowArgs} args - Arguments to find a Ramos
     * @example
     * // Get one Ramos
     * const ramos = await prisma.ramos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ramosFindUniqueOrThrowArgs>(args: SelectSubset<T, ramosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ramos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramosFindFirstArgs} args - Arguments to find a Ramos
     * @example
     * // Get one Ramos
     * const ramos = await prisma.ramos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ramosFindFirstArgs>(args?: SelectSubset<T, ramosFindFirstArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ramos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramosFindFirstOrThrowArgs} args - Arguments to find a Ramos
     * @example
     * // Get one Ramos
     * const ramos = await prisma.ramos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ramosFindFirstOrThrowArgs>(args?: SelectSubset<T, ramosFindFirstOrThrowArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ramos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ramos
     * const ramos = await prisma.ramos.findMany()
     * 
     * // Get first 10 Ramos
     * const ramos = await prisma.ramos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ramosWithIdOnly = await prisma.ramos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ramosFindManyArgs>(args?: SelectSubset<T, ramosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ramos.
     * @param {ramosCreateArgs} args - Arguments to create a Ramos.
     * @example
     * // Create one Ramos
     * const Ramos = await prisma.ramos.create({
     *   data: {
     *     // ... data to create a Ramos
     *   }
     * })
     * 
     */
    create<T extends ramosCreateArgs>(args: SelectSubset<T, ramosCreateArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ramos.
     * @param {ramosCreateManyArgs} args - Arguments to create many Ramos.
     * @example
     * // Create many Ramos
     * const ramos = await prisma.ramos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ramosCreateManyArgs>(args?: SelectSubset<T, ramosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ramos.
     * @param {ramosDeleteArgs} args - Arguments to delete one Ramos.
     * @example
     * // Delete one Ramos
     * const Ramos = await prisma.ramos.delete({
     *   where: {
     *     // ... filter to delete one Ramos
     *   }
     * })
     * 
     */
    delete<T extends ramosDeleteArgs>(args: SelectSubset<T, ramosDeleteArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ramos.
     * @param {ramosUpdateArgs} args - Arguments to update one Ramos.
     * @example
     * // Update one Ramos
     * const ramos = await prisma.ramos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ramosUpdateArgs>(args: SelectSubset<T, ramosUpdateArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ramos.
     * @param {ramosDeleteManyArgs} args - Arguments to filter Ramos to delete.
     * @example
     * // Delete a few Ramos
     * const { count } = await prisma.ramos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ramosDeleteManyArgs>(args?: SelectSubset<T, ramosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ramos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ramos
     * const ramos = await prisma.ramos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ramosUpdateManyArgs>(args: SelectSubset<T, ramosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ramos.
     * @param {ramosUpsertArgs} args - Arguments to update or create a Ramos.
     * @example
     * // Update or create a Ramos
     * const ramos = await prisma.ramos.upsert({
     *   create: {
     *     // ... data to create a Ramos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ramos we want to update
     *   }
     * })
     */
    upsert<T extends ramosUpsertArgs>(args: SelectSubset<T, ramosUpsertArgs<ExtArgs>>): Prisma__ramosClient<$Result.GetResult<Prisma.$ramosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ramos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramosCountArgs} args - Arguments to filter Ramos to count.
     * @example
     * // Count the number of Ramos
     * const count = await prisma.ramos.count({
     *   where: {
     *     // ... the filter for the Ramos we want to count
     *   }
     * })
    **/
    count<T extends ramosCountArgs>(
      args?: Subset<T, ramosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RamosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ramos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RamosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RamosAggregateArgs>(args: Subset<T, RamosAggregateArgs>): Prisma.PrismaPromise<GetRamosAggregateType<T>>

    /**
     * Group by Ramos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ramosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ramosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ramosGroupByArgs['orderBy'] }
        : { orderBy?: ramosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ramosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRamosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ramos model
   */
  readonly fields: ramosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ramos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ramosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companias_productos<T extends ramos$companias_productosArgs<ExtArgs> = {}>(args?: Subset<T, ramos$companias_productosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companias_productosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companias_ramos<T extends ramos$companias_ramosArgs<ExtArgs> = {}>(args?: Subset<T, ramos$companias_ramosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companias_ramosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    polizas<T extends ramos$polizasArgs<ExtArgs> = {}>(args?: Subset<T, ramos$polizasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ramos model
   */
  interface ramosFieldRefs {
    readonly id: FieldRef<"ramos", 'BigInt'>
    readonly label: FieldRef<"ramos", 'String'>
    readonly estatus: FieldRef<"ramos", 'Boolean'>
    readonly created_at: FieldRef<"ramos", 'DateTime'>
    readonly updated_at: FieldRef<"ramos", 'DateTime'>
    readonly deleted_at: FieldRef<"ramos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ramos findUnique
   */
  export type ramosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramos
     */
    select?: ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ramos
     */
    omit?: ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ramosInclude<ExtArgs> | null
    /**
     * Filter, which ramos to fetch.
     */
    where: ramosWhereUniqueInput
  }

  /**
   * ramos findUniqueOrThrow
   */
  export type ramosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramos
     */
    select?: ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ramos
     */
    omit?: ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ramosInclude<ExtArgs> | null
    /**
     * Filter, which ramos to fetch.
     */
    where: ramosWhereUniqueInput
  }

  /**
   * ramos findFirst
   */
  export type ramosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramos
     */
    select?: ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ramos
     */
    omit?: ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ramosInclude<ExtArgs> | null
    /**
     * Filter, which ramos to fetch.
     */
    where?: ramosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramos to fetch.
     */
    orderBy?: ramosOrderByWithRelationInput | ramosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramos.
     */
    cursor?: ramosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramos.
     */
    distinct?: RamosScalarFieldEnum | RamosScalarFieldEnum[]
  }

  /**
   * ramos findFirstOrThrow
   */
  export type ramosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramos
     */
    select?: ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ramos
     */
    omit?: ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ramosInclude<ExtArgs> | null
    /**
     * Filter, which ramos to fetch.
     */
    where?: ramosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramos to fetch.
     */
    orderBy?: ramosOrderByWithRelationInput | ramosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ramos.
     */
    cursor?: ramosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ramos.
     */
    distinct?: RamosScalarFieldEnum | RamosScalarFieldEnum[]
  }

  /**
   * ramos findMany
   */
  export type ramosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramos
     */
    select?: ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ramos
     */
    omit?: ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ramosInclude<ExtArgs> | null
    /**
     * Filter, which ramos to fetch.
     */
    where?: ramosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ramos to fetch.
     */
    orderBy?: ramosOrderByWithRelationInput | ramosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ramos.
     */
    cursor?: ramosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ramos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ramos.
     */
    skip?: number
    distinct?: RamosScalarFieldEnum | RamosScalarFieldEnum[]
  }

  /**
   * ramos create
   */
  export type ramosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramos
     */
    select?: ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ramos
     */
    omit?: ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ramosInclude<ExtArgs> | null
    /**
     * The data needed to create a ramos.
     */
    data: XOR<ramosCreateInput, ramosUncheckedCreateInput>
  }

  /**
   * ramos createMany
   */
  export type ramosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ramos.
     */
    data: ramosCreateManyInput | ramosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ramos update
   */
  export type ramosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramos
     */
    select?: ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ramos
     */
    omit?: ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ramosInclude<ExtArgs> | null
    /**
     * The data needed to update a ramos.
     */
    data: XOR<ramosUpdateInput, ramosUncheckedUpdateInput>
    /**
     * Choose, which ramos to update.
     */
    where: ramosWhereUniqueInput
  }

  /**
   * ramos updateMany
   */
  export type ramosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ramos.
     */
    data: XOR<ramosUpdateManyMutationInput, ramosUncheckedUpdateManyInput>
    /**
     * Filter which ramos to update
     */
    where?: ramosWhereInput
    /**
     * Limit how many ramos to update.
     */
    limit?: number
  }

  /**
   * ramos upsert
   */
  export type ramosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramos
     */
    select?: ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ramos
     */
    omit?: ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ramosInclude<ExtArgs> | null
    /**
     * The filter to search for the ramos to update in case it exists.
     */
    where: ramosWhereUniqueInput
    /**
     * In case the ramos found by the `where` argument doesn't exist, create a new ramos with this data.
     */
    create: XOR<ramosCreateInput, ramosUncheckedCreateInput>
    /**
     * In case the ramos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ramosUpdateInput, ramosUncheckedUpdateInput>
  }

  /**
   * ramos delete
   */
  export type ramosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramos
     */
    select?: ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ramos
     */
    omit?: ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ramosInclude<ExtArgs> | null
    /**
     * Filter which ramos to delete.
     */
    where: ramosWhereUniqueInput
  }

  /**
   * ramos deleteMany
   */
  export type ramosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ramos to delete
     */
    where?: ramosWhereInput
    /**
     * Limit how many ramos to delete.
     */
    limit?: number
  }

  /**
   * ramos.companias_productos
   */
  export type ramos$companias_productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_productos
     */
    select?: companias_productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_productos
     */
    omit?: companias_productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_productosInclude<ExtArgs> | null
    where?: companias_productosWhereInput
    orderBy?: companias_productosOrderByWithRelationInput | companias_productosOrderByWithRelationInput[]
    cursor?: companias_productosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Companias_productosScalarFieldEnum | Companias_productosScalarFieldEnum[]
  }

  /**
   * ramos.companias_ramos
   */
  export type ramos$companias_ramosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companias_ramos
     */
    select?: companias_ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companias_ramos
     */
    omit?: companias_ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companias_ramosInclude<ExtArgs> | null
    where?: companias_ramosWhereInput
    orderBy?: companias_ramosOrderByWithRelationInput | companias_ramosOrderByWithRelationInput[]
    cursor?: companias_ramosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Companias_ramosScalarFieldEnum | Companias_ramosScalarFieldEnum[]
  }

  /**
   * ramos.polizas
   */
  export type ramos$polizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    where?: polizasWhereInput
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    cursor?: polizasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * ramos without action
   */
  export type ramosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ramos
     */
    select?: ramosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ramos
     */
    omit?: ramosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ramosInclude<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsAvgAggregateOutputType = {
    user_id: number | null
    last_activity: number | null
  }

  export type SessionsSumAggregateOutputType = {
    user_id: bigint | null
    last_activity: number | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    user_id: bigint | null
    ip_address: string | null
    user_agent: string | null
    payload: string | null
    last_activity: number | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    user_id: bigint | null
    ip_address: string | null
    user_agent: string | null
    payload: string | null
    last_activity: number | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    user_id: number
    ip_address: number
    user_agent: number
    payload: number
    last_activity: number
    _all: number
  }


  export type SessionsAvgAggregateInputType = {
    user_id?: true
    last_activity?: true
  }

  export type SessionsSumAggregateInputType = {
    user_id?: true
    last_activity?: true
  }

  export type SessionsMinAggregateInputType = {
    id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _avg?: SessionsAvgAggregateInputType
    _sum?: SessionsSumAggregateInputType
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: string
    user_id: bigint | null
    ip_address: string | null
    user_agent: string | null
    payload: string
    last_activity: number
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    payload?: boolean
    last_activity?: boolean
  }, ExtArgs["result"]["sessions"]>



  export type sessionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    payload?: boolean
    last_activity?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "ip_address" | "user_agent" | "payload" | "last_activity", ExtArgs["result"]["sessions"]>

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: bigint | null
      ip_address: string | null
      user_agent: string | null
      payload: string
      last_activity: number
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'String'>
    readonly user_id: FieldRef<"sessions", 'BigInt'>
    readonly ip_address: FieldRef<"sessions", 'String'>
    readonly user_agent: FieldRef<"sessions", 'String'>
    readonly payload: FieldRef<"sessions", 'String'>
    readonly last_activity: FieldRef<"sessions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
  }


  /**
   * Model tipos_de_usuarios
   */

  export type AggregateTipos_de_usuarios = {
    _count: Tipos_de_usuariosCountAggregateOutputType | null
    _avg: Tipos_de_usuariosAvgAggregateOutputType | null
    _sum: Tipos_de_usuariosSumAggregateOutputType | null
    _min: Tipos_de_usuariosMinAggregateOutputType | null
    _max: Tipos_de_usuariosMaxAggregateOutputType | null
  }

  export type Tipos_de_usuariosAvgAggregateOutputType = {
    id: number | null
  }

  export type Tipos_de_usuariosSumAggregateOutputType = {
    id: bigint | null
  }

  export type Tipos_de_usuariosMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Tipos_de_usuariosMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Tipos_de_usuariosCountAggregateOutputType = {
    id: number
    label: number
    estatus: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Tipos_de_usuariosAvgAggregateInputType = {
    id?: true
  }

  export type Tipos_de_usuariosSumAggregateInputType = {
    id?: true
  }

  export type Tipos_de_usuariosMinAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Tipos_de_usuariosMaxAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Tipos_de_usuariosCountAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Tipos_de_usuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipos_de_usuarios to aggregate.
     */
    where?: tipos_de_usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_de_usuarios to fetch.
     */
    orderBy?: tipos_de_usuariosOrderByWithRelationInput | tipos_de_usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipos_de_usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_de_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_de_usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipos_de_usuarios
    **/
    _count?: true | Tipos_de_usuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipos_de_usuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipos_de_usuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipos_de_usuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipos_de_usuariosMaxAggregateInputType
  }

  export type GetTipos_de_usuariosAggregateType<T extends Tipos_de_usuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateTipos_de_usuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipos_de_usuarios[P]>
      : GetScalarType<T[P], AggregateTipos_de_usuarios[P]>
  }




  export type tipos_de_usuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipos_de_usuariosWhereInput
    orderBy?: tipos_de_usuariosOrderByWithAggregationInput | tipos_de_usuariosOrderByWithAggregationInput[]
    by: Tipos_de_usuariosScalarFieldEnum[] | Tipos_de_usuariosScalarFieldEnum
    having?: tipos_de_usuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipos_de_usuariosCountAggregateInputType | true
    _avg?: Tipos_de_usuariosAvgAggregateInputType
    _sum?: Tipos_de_usuariosSumAggregateInputType
    _min?: Tipos_de_usuariosMinAggregateInputType
    _max?: Tipos_de_usuariosMaxAggregateInputType
  }

  export type Tipos_de_usuariosGroupByOutputType = {
    id: bigint
    label: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: Tipos_de_usuariosCountAggregateOutputType | null
    _avg: Tipos_de_usuariosAvgAggregateOutputType | null
    _sum: Tipos_de_usuariosSumAggregateOutputType | null
    _min: Tipos_de_usuariosMinAggregateOutputType | null
    _max: Tipos_de_usuariosMaxAggregateOutputType | null
  }

  type GetTipos_de_usuariosGroupByPayload<T extends tipos_de_usuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipos_de_usuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipos_de_usuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipos_de_usuariosGroupByOutputType[P]>
            : GetScalarType<T[P], Tipos_de_usuariosGroupByOutputType[P]>
        }
      >
    >


  export type tipos_de_usuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    usuario_team?: boolean | tipos_de_usuarios$usuario_teamArgs<ExtArgs>
    _count?: boolean | Tipos_de_usuariosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipos_de_usuarios"]>



  export type tipos_de_usuariosSelectScalar = {
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type tipos_de_usuariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "estatus" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["tipos_de_usuarios"]>
  export type tipos_de_usuariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario_team?: boolean | tipos_de_usuarios$usuario_teamArgs<ExtArgs>
    _count?: boolean | Tipos_de_usuariosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tipos_de_usuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipos_de_usuarios"
    objects: {
      usuario_team: Prisma.$usuario_teamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["tipos_de_usuarios"]>
    composites: {}
  }

  type tipos_de_usuariosGetPayload<S extends boolean | null | undefined | tipos_de_usuariosDefaultArgs> = $Result.GetResult<Prisma.$tipos_de_usuariosPayload, S>

  type tipos_de_usuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tipos_de_usuariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tipos_de_usuariosCountAggregateInputType | true
    }

  export interface tipos_de_usuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipos_de_usuarios'], meta: { name: 'tipos_de_usuarios' } }
    /**
     * Find zero or one Tipos_de_usuarios that matches the filter.
     * @param {tipos_de_usuariosFindUniqueArgs} args - Arguments to find a Tipos_de_usuarios
     * @example
     * // Get one Tipos_de_usuarios
     * const tipos_de_usuarios = await prisma.tipos_de_usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipos_de_usuariosFindUniqueArgs>(args: SelectSubset<T, tipos_de_usuariosFindUniqueArgs<ExtArgs>>): Prisma__tipos_de_usuariosClient<$Result.GetResult<Prisma.$tipos_de_usuariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tipos_de_usuarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipos_de_usuariosFindUniqueOrThrowArgs} args - Arguments to find a Tipos_de_usuarios
     * @example
     * // Get one Tipos_de_usuarios
     * const tipos_de_usuarios = await prisma.tipos_de_usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipos_de_usuariosFindUniqueOrThrowArgs>(args: SelectSubset<T, tipos_de_usuariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipos_de_usuariosClient<$Result.GetResult<Prisma.$tipos_de_usuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tipos_de_usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_usuariosFindFirstArgs} args - Arguments to find a Tipos_de_usuarios
     * @example
     * // Get one Tipos_de_usuarios
     * const tipos_de_usuarios = await prisma.tipos_de_usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipos_de_usuariosFindFirstArgs>(args?: SelectSubset<T, tipos_de_usuariosFindFirstArgs<ExtArgs>>): Prisma__tipos_de_usuariosClient<$Result.GetResult<Prisma.$tipos_de_usuariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tipos_de_usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_usuariosFindFirstOrThrowArgs} args - Arguments to find a Tipos_de_usuarios
     * @example
     * // Get one Tipos_de_usuarios
     * const tipos_de_usuarios = await prisma.tipos_de_usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipos_de_usuariosFindFirstOrThrowArgs>(args?: SelectSubset<T, tipos_de_usuariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipos_de_usuariosClient<$Result.GetResult<Prisma.$tipos_de_usuariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tipos_de_usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_usuariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipos_de_usuarios
     * const tipos_de_usuarios = await prisma.tipos_de_usuarios.findMany()
     * 
     * // Get first 10 Tipos_de_usuarios
     * const tipos_de_usuarios = await prisma.tipos_de_usuarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipos_de_usuariosWithIdOnly = await prisma.tipos_de_usuarios.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tipos_de_usuariosFindManyArgs>(args?: SelectSubset<T, tipos_de_usuariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipos_de_usuariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tipos_de_usuarios.
     * @param {tipos_de_usuariosCreateArgs} args - Arguments to create a Tipos_de_usuarios.
     * @example
     * // Create one Tipos_de_usuarios
     * const Tipos_de_usuarios = await prisma.tipos_de_usuarios.create({
     *   data: {
     *     // ... data to create a Tipos_de_usuarios
     *   }
     * })
     * 
     */
    create<T extends tipos_de_usuariosCreateArgs>(args: SelectSubset<T, tipos_de_usuariosCreateArgs<ExtArgs>>): Prisma__tipos_de_usuariosClient<$Result.GetResult<Prisma.$tipos_de_usuariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tipos_de_usuarios.
     * @param {tipos_de_usuariosCreateManyArgs} args - Arguments to create many Tipos_de_usuarios.
     * @example
     * // Create many Tipos_de_usuarios
     * const tipos_de_usuarios = await prisma.tipos_de_usuarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipos_de_usuariosCreateManyArgs>(args?: SelectSubset<T, tipos_de_usuariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipos_de_usuarios.
     * @param {tipos_de_usuariosDeleteArgs} args - Arguments to delete one Tipos_de_usuarios.
     * @example
     * // Delete one Tipos_de_usuarios
     * const Tipos_de_usuarios = await prisma.tipos_de_usuarios.delete({
     *   where: {
     *     // ... filter to delete one Tipos_de_usuarios
     *   }
     * })
     * 
     */
    delete<T extends tipos_de_usuariosDeleteArgs>(args: SelectSubset<T, tipos_de_usuariosDeleteArgs<ExtArgs>>): Prisma__tipos_de_usuariosClient<$Result.GetResult<Prisma.$tipos_de_usuariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tipos_de_usuarios.
     * @param {tipos_de_usuariosUpdateArgs} args - Arguments to update one Tipos_de_usuarios.
     * @example
     * // Update one Tipos_de_usuarios
     * const tipos_de_usuarios = await prisma.tipos_de_usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipos_de_usuariosUpdateArgs>(args: SelectSubset<T, tipos_de_usuariosUpdateArgs<ExtArgs>>): Prisma__tipos_de_usuariosClient<$Result.GetResult<Prisma.$tipos_de_usuariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tipos_de_usuarios.
     * @param {tipos_de_usuariosDeleteManyArgs} args - Arguments to filter Tipos_de_usuarios to delete.
     * @example
     * // Delete a few Tipos_de_usuarios
     * const { count } = await prisma.tipos_de_usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipos_de_usuariosDeleteManyArgs>(args?: SelectSubset<T, tipos_de_usuariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipos_de_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_usuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipos_de_usuarios
     * const tipos_de_usuarios = await prisma.tipos_de_usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipos_de_usuariosUpdateManyArgs>(args: SelectSubset<T, tipos_de_usuariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipos_de_usuarios.
     * @param {tipos_de_usuariosUpsertArgs} args - Arguments to update or create a Tipos_de_usuarios.
     * @example
     * // Update or create a Tipos_de_usuarios
     * const tipos_de_usuarios = await prisma.tipos_de_usuarios.upsert({
     *   create: {
     *     // ... data to create a Tipos_de_usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipos_de_usuarios we want to update
     *   }
     * })
     */
    upsert<T extends tipos_de_usuariosUpsertArgs>(args: SelectSubset<T, tipos_de_usuariosUpsertArgs<ExtArgs>>): Prisma__tipos_de_usuariosClient<$Result.GetResult<Prisma.$tipos_de_usuariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tipos_de_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_usuariosCountArgs} args - Arguments to filter Tipos_de_usuarios to count.
     * @example
     * // Count the number of Tipos_de_usuarios
     * const count = await prisma.tipos_de_usuarios.count({
     *   where: {
     *     // ... the filter for the Tipos_de_usuarios we want to count
     *   }
     * })
    **/
    count<T extends tipos_de_usuariosCountArgs>(
      args?: Subset<T, tipos_de_usuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipos_de_usuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipos_de_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipos_de_usuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipos_de_usuariosAggregateArgs>(args: Subset<T, Tipos_de_usuariosAggregateArgs>): Prisma.PrismaPromise<GetTipos_de_usuariosAggregateType<T>>

    /**
     * Group by Tipos_de_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_usuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipos_de_usuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipos_de_usuariosGroupByArgs['orderBy'] }
        : { orderBy?: tipos_de_usuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipos_de_usuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipos_de_usuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipos_de_usuarios model
   */
  readonly fields: tipos_de_usuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipos_de_usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipos_de_usuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario_team<T extends tipos_de_usuarios$usuario_teamArgs<ExtArgs> = {}>(args?: Subset<T, tipos_de_usuarios$usuario_teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipos_de_usuarios model
   */
  interface tipos_de_usuariosFieldRefs {
    readonly id: FieldRef<"tipos_de_usuarios", 'BigInt'>
    readonly label: FieldRef<"tipos_de_usuarios", 'String'>
    readonly estatus: FieldRef<"tipos_de_usuarios", 'Boolean'>
    readonly created_at: FieldRef<"tipos_de_usuarios", 'DateTime'>
    readonly updated_at: FieldRef<"tipos_de_usuarios", 'DateTime'>
    readonly deleted_at: FieldRef<"tipos_de_usuarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tipos_de_usuarios findUnique
   */
  export type tipos_de_usuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_usuarios
     */
    select?: tipos_de_usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_usuarios
     */
    omit?: tipos_de_usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_usuariosInclude<ExtArgs> | null
    /**
     * Filter, which tipos_de_usuarios to fetch.
     */
    where: tipos_de_usuariosWhereUniqueInput
  }

  /**
   * tipos_de_usuarios findUniqueOrThrow
   */
  export type tipos_de_usuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_usuarios
     */
    select?: tipos_de_usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_usuarios
     */
    omit?: tipos_de_usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_usuariosInclude<ExtArgs> | null
    /**
     * Filter, which tipos_de_usuarios to fetch.
     */
    where: tipos_de_usuariosWhereUniqueInput
  }

  /**
   * tipos_de_usuarios findFirst
   */
  export type tipos_de_usuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_usuarios
     */
    select?: tipos_de_usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_usuarios
     */
    omit?: tipos_de_usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_usuariosInclude<ExtArgs> | null
    /**
     * Filter, which tipos_de_usuarios to fetch.
     */
    where?: tipos_de_usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_de_usuarios to fetch.
     */
    orderBy?: tipos_de_usuariosOrderByWithRelationInput | tipos_de_usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipos_de_usuarios.
     */
    cursor?: tipos_de_usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_de_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_de_usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipos_de_usuarios.
     */
    distinct?: Tipos_de_usuariosScalarFieldEnum | Tipos_de_usuariosScalarFieldEnum[]
  }

  /**
   * tipos_de_usuarios findFirstOrThrow
   */
  export type tipos_de_usuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_usuarios
     */
    select?: tipos_de_usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_usuarios
     */
    omit?: tipos_de_usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_usuariosInclude<ExtArgs> | null
    /**
     * Filter, which tipos_de_usuarios to fetch.
     */
    where?: tipos_de_usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_de_usuarios to fetch.
     */
    orderBy?: tipos_de_usuariosOrderByWithRelationInput | tipos_de_usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipos_de_usuarios.
     */
    cursor?: tipos_de_usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_de_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_de_usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipos_de_usuarios.
     */
    distinct?: Tipos_de_usuariosScalarFieldEnum | Tipos_de_usuariosScalarFieldEnum[]
  }

  /**
   * tipos_de_usuarios findMany
   */
  export type tipos_de_usuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_usuarios
     */
    select?: tipos_de_usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_usuarios
     */
    omit?: tipos_de_usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_usuariosInclude<ExtArgs> | null
    /**
     * Filter, which tipos_de_usuarios to fetch.
     */
    where?: tipos_de_usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_de_usuarios to fetch.
     */
    orderBy?: tipos_de_usuariosOrderByWithRelationInput | tipos_de_usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipos_de_usuarios.
     */
    cursor?: tipos_de_usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_de_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_de_usuarios.
     */
    skip?: number
    distinct?: Tipos_de_usuariosScalarFieldEnum | Tipos_de_usuariosScalarFieldEnum[]
  }

  /**
   * tipos_de_usuarios create
   */
  export type tipos_de_usuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_usuarios
     */
    select?: tipos_de_usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_usuarios
     */
    omit?: tipos_de_usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_usuariosInclude<ExtArgs> | null
    /**
     * The data needed to create a tipos_de_usuarios.
     */
    data: XOR<tipos_de_usuariosCreateInput, tipos_de_usuariosUncheckedCreateInput>
  }

  /**
   * tipos_de_usuarios createMany
   */
  export type tipos_de_usuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipos_de_usuarios.
     */
    data: tipos_de_usuariosCreateManyInput | tipos_de_usuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipos_de_usuarios update
   */
  export type tipos_de_usuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_usuarios
     */
    select?: tipos_de_usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_usuarios
     */
    omit?: tipos_de_usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_usuariosInclude<ExtArgs> | null
    /**
     * The data needed to update a tipos_de_usuarios.
     */
    data: XOR<tipos_de_usuariosUpdateInput, tipos_de_usuariosUncheckedUpdateInput>
    /**
     * Choose, which tipos_de_usuarios to update.
     */
    where: tipos_de_usuariosWhereUniqueInput
  }

  /**
   * tipos_de_usuarios updateMany
   */
  export type tipos_de_usuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipos_de_usuarios.
     */
    data: XOR<tipos_de_usuariosUpdateManyMutationInput, tipos_de_usuariosUncheckedUpdateManyInput>
    /**
     * Filter which tipos_de_usuarios to update
     */
    where?: tipos_de_usuariosWhereInput
    /**
     * Limit how many tipos_de_usuarios to update.
     */
    limit?: number
  }

  /**
   * tipos_de_usuarios upsert
   */
  export type tipos_de_usuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_usuarios
     */
    select?: tipos_de_usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_usuarios
     */
    omit?: tipos_de_usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_usuariosInclude<ExtArgs> | null
    /**
     * The filter to search for the tipos_de_usuarios to update in case it exists.
     */
    where: tipos_de_usuariosWhereUniqueInput
    /**
     * In case the tipos_de_usuarios found by the `where` argument doesn't exist, create a new tipos_de_usuarios with this data.
     */
    create: XOR<tipos_de_usuariosCreateInput, tipos_de_usuariosUncheckedCreateInput>
    /**
     * In case the tipos_de_usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipos_de_usuariosUpdateInput, tipos_de_usuariosUncheckedUpdateInput>
  }

  /**
   * tipos_de_usuarios delete
   */
  export type tipos_de_usuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_usuarios
     */
    select?: tipos_de_usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_usuarios
     */
    omit?: tipos_de_usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_usuariosInclude<ExtArgs> | null
    /**
     * Filter which tipos_de_usuarios to delete.
     */
    where: tipos_de_usuariosWhereUniqueInput
  }

  /**
   * tipos_de_usuarios deleteMany
   */
  export type tipos_de_usuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipos_de_usuarios to delete
     */
    where?: tipos_de_usuariosWhereInput
    /**
     * Limit how many tipos_de_usuarios to delete.
     */
    limit?: number
  }

  /**
   * tipos_de_usuarios.usuario_team
   */
  export type tipos_de_usuarios$usuario_teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    where?: usuario_teamWhereInput
    orderBy?: usuario_teamOrderByWithRelationInput | usuario_teamOrderByWithRelationInput[]
    cursor?: usuario_teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Usuario_teamScalarFieldEnum | Usuario_teamScalarFieldEnum[]
  }

  /**
   * tipos_de_usuarios without action
   */
  export type tipos_de_usuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_usuarios
     */
    select?: tipos_de_usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_usuarios
     */
    omit?: tipos_de_usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_usuariosInclude<ExtArgs> | null
  }


  /**
   * Model tipos_de_vencimiento
   */

  export type AggregateTipos_de_vencimiento = {
    _count: Tipos_de_vencimientoCountAggregateOutputType | null
    _avg: Tipos_de_vencimientoAvgAggregateOutputType | null
    _sum: Tipos_de_vencimientoSumAggregateOutputType | null
    _min: Tipos_de_vencimientoMinAggregateOutputType | null
    _max: Tipos_de_vencimientoMaxAggregateOutputType | null
  }

  export type Tipos_de_vencimientoAvgAggregateOutputType = {
    id: number | null
  }

  export type Tipos_de_vencimientoSumAggregateOutputType = {
    id: bigint | null
  }

  export type Tipos_de_vencimientoMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Tipos_de_vencimientoMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Tipos_de_vencimientoCountAggregateOutputType = {
    id: number
    label: number
    estatus: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Tipos_de_vencimientoAvgAggregateInputType = {
    id?: true
  }

  export type Tipos_de_vencimientoSumAggregateInputType = {
    id?: true
  }

  export type Tipos_de_vencimientoMinAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Tipos_de_vencimientoMaxAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Tipos_de_vencimientoCountAggregateInputType = {
    id?: true
    label?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Tipos_de_vencimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipos_de_vencimiento to aggregate.
     */
    where?: tipos_de_vencimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_de_vencimientos to fetch.
     */
    orderBy?: tipos_de_vencimientoOrderByWithRelationInput | tipos_de_vencimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipos_de_vencimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_de_vencimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_de_vencimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipos_de_vencimientos
    **/
    _count?: true | Tipos_de_vencimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipos_de_vencimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipos_de_vencimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipos_de_vencimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipos_de_vencimientoMaxAggregateInputType
  }

  export type GetTipos_de_vencimientoAggregateType<T extends Tipos_de_vencimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipos_de_vencimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipos_de_vencimiento[P]>
      : GetScalarType<T[P], AggregateTipos_de_vencimiento[P]>
  }




  export type tipos_de_vencimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipos_de_vencimientoWhereInput
    orderBy?: tipos_de_vencimientoOrderByWithAggregationInput | tipos_de_vencimientoOrderByWithAggregationInput[]
    by: Tipos_de_vencimientoScalarFieldEnum[] | Tipos_de_vencimientoScalarFieldEnum
    having?: tipos_de_vencimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipos_de_vencimientoCountAggregateInputType | true
    _avg?: Tipos_de_vencimientoAvgAggregateInputType
    _sum?: Tipos_de_vencimientoSumAggregateInputType
    _min?: Tipos_de_vencimientoMinAggregateInputType
    _max?: Tipos_de_vencimientoMaxAggregateInputType
  }

  export type Tipos_de_vencimientoGroupByOutputType = {
    id: bigint
    label: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: Tipos_de_vencimientoCountAggregateOutputType | null
    _avg: Tipos_de_vencimientoAvgAggregateOutputType | null
    _sum: Tipos_de_vencimientoSumAggregateOutputType | null
    _min: Tipos_de_vencimientoMinAggregateOutputType | null
    _max: Tipos_de_vencimientoMaxAggregateOutputType | null
  }

  type GetTipos_de_vencimientoGroupByPayload<T extends tipos_de_vencimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipos_de_vencimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipos_de_vencimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipos_de_vencimientoGroupByOutputType[P]>
            : GetScalarType<T[P], Tipos_de_vencimientoGroupByOutputType[P]>
        }
      >
    >


  export type tipos_de_vencimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    polizas?: boolean | tipos_de_vencimiento$polizasArgs<ExtArgs>
    _count?: boolean | Tipos_de_vencimientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipos_de_vencimiento"]>



  export type tipos_de_vencimientoSelectScalar = {
    id?: boolean
    label?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type tipos_de_vencimientoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "estatus" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["tipos_de_vencimiento"]>
  export type tipos_de_vencimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | tipos_de_vencimiento$polizasArgs<ExtArgs>
    _count?: boolean | Tipos_de_vencimientoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tipos_de_vencimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipos_de_vencimiento"
    objects: {
      polizas: Prisma.$polizasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["tipos_de_vencimiento"]>
    composites: {}
  }

  type tipos_de_vencimientoGetPayload<S extends boolean | null | undefined | tipos_de_vencimientoDefaultArgs> = $Result.GetResult<Prisma.$tipos_de_vencimientoPayload, S>

  type tipos_de_vencimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tipos_de_vencimientoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tipos_de_vencimientoCountAggregateInputType | true
    }

  export interface tipos_de_vencimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipos_de_vencimiento'], meta: { name: 'tipos_de_vencimiento' } }
    /**
     * Find zero or one Tipos_de_vencimiento that matches the filter.
     * @param {tipos_de_vencimientoFindUniqueArgs} args - Arguments to find a Tipos_de_vencimiento
     * @example
     * // Get one Tipos_de_vencimiento
     * const tipos_de_vencimiento = await prisma.tipos_de_vencimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipos_de_vencimientoFindUniqueArgs>(args: SelectSubset<T, tipos_de_vencimientoFindUniqueArgs<ExtArgs>>): Prisma__tipos_de_vencimientoClient<$Result.GetResult<Prisma.$tipos_de_vencimientoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tipos_de_vencimiento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipos_de_vencimientoFindUniqueOrThrowArgs} args - Arguments to find a Tipos_de_vencimiento
     * @example
     * // Get one Tipos_de_vencimiento
     * const tipos_de_vencimiento = await prisma.tipos_de_vencimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipos_de_vencimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, tipos_de_vencimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipos_de_vencimientoClient<$Result.GetResult<Prisma.$tipos_de_vencimientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tipos_de_vencimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_vencimientoFindFirstArgs} args - Arguments to find a Tipos_de_vencimiento
     * @example
     * // Get one Tipos_de_vencimiento
     * const tipos_de_vencimiento = await prisma.tipos_de_vencimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipos_de_vencimientoFindFirstArgs>(args?: SelectSubset<T, tipos_de_vencimientoFindFirstArgs<ExtArgs>>): Prisma__tipos_de_vencimientoClient<$Result.GetResult<Prisma.$tipos_de_vencimientoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tipos_de_vencimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_vencimientoFindFirstOrThrowArgs} args - Arguments to find a Tipos_de_vencimiento
     * @example
     * // Get one Tipos_de_vencimiento
     * const tipos_de_vencimiento = await prisma.tipos_de_vencimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipos_de_vencimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, tipos_de_vencimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipos_de_vencimientoClient<$Result.GetResult<Prisma.$tipos_de_vencimientoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tipos_de_vencimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_vencimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipos_de_vencimientos
     * const tipos_de_vencimientos = await prisma.tipos_de_vencimiento.findMany()
     * 
     * // Get first 10 Tipos_de_vencimientos
     * const tipos_de_vencimientos = await prisma.tipos_de_vencimiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipos_de_vencimientoWithIdOnly = await prisma.tipos_de_vencimiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tipos_de_vencimientoFindManyArgs>(args?: SelectSubset<T, tipos_de_vencimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipos_de_vencimientoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tipos_de_vencimiento.
     * @param {tipos_de_vencimientoCreateArgs} args - Arguments to create a Tipos_de_vencimiento.
     * @example
     * // Create one Tipos_de_vencimiento
     * const Tipos_de_vencimiento = await prisma.tipos_de_vencimiento.create({
     *   data: {
     *     // ... data to create a Tipos_de_vencimiento
     *   }
     * })
     * 
     */
    create<T extends tipos_de_vencimientoCreateArgs>(args: SelectSubset<T, tipos_de_vencimientoCreateArgs<ExtArgs>>): Prisma__tipos_de_vencimientoClient<$Result.GetResult<Prisma.$tipos_de_vencimientoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tipos_de_vencimientos.
     * @param {tipos_de_vencimientoCreateManyArgs} args - Arguments to create many Tipos_de_vencimientos.
     * @example
     * // Create many Tipos_de_vencimientos
     * const tipos_de_vencimiento = await prisma.tipos_de_vencimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipos_de_vencimientoCreateManyArgs>(args?: SelectSubset<T, tipos_de_vencimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipos_de_vencimiento.
     * @param {tipos_de_vencimientoDeleteArgs} args - Arguments to delete one Tipos_de_vencimiento.
     * @example
     * // Delete one Tipos_de_vencimiento
     * const Tipos_de_vencimiento = await prisma.tipos_de_vencimiento.delete({
     *   where: {
     *     // ... filter to delete one Tipos_de_vencimiento
     *   }
     * })
     * 
     */
    delete<T extends tipos_de_vencimientoDeleteArgs>(args: SelectSubset<T, tipos_de_vencimientoDeleteArgs<ExtArgs>>): Prisma__tipos_de_vencimientoClient<$Result.GetResult<Prisma.$tipos_de_vencimientoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tipos_de_vencimiento.
     * @param {tipos_de_vencimientoUpdateArgs} args - Arguments to update one Tipos_de_vencimiento.
     * @example
     * // Update one Tipos_de_vencimiento
     * const tipos_de_vencimiento = await prisma.tipos_de_vencimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipos_de_vencimientoUpdateArgs>(args: SelectSubset<T, tipos_de_vencimientoUpdateArgs<ExtArgs>>): Prisma__tipos_de_vencimientoClient<$Result.GetResult<Prisma.$tipos_de_vencimientoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tipos_de_vencimientos.
     * @param {tipos_de_vencimientoDeleteManyArgs} args - Arguments to filter Tipos_de_vencimientos to delete.
     * @example
     * // Delete a few Tipos_de_vencimientos
     * const { count } = await prisma.tipos_de_vencimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipos_de_vencimientoDeleteManyArgs>(args?: SelectSubset<T, tipos_de_vencimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipos_de_vencimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_vencimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipos_de_vencimientos
     * const tipos_de_vencimiento = await prisma.tipos_de_vencimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipos_de_vencimientoUpdateManyArgs>(args: SelectSubset<T, tipos_de_vencimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipos_de_vencimiento.
     * @param {tipos_de_vencimientoUpsertArgs} args - Arguments to update or create a Tipos_de_vencimiento.
     * @example
     * // Update or create a Tipos_de_vencimiento
     * const tipos_de_vencimiento = await prisma.tipos_de_vencimiento.upsert({
     *   create: {
     *     // ... data to create a Tipos_de_vencimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipos_de_vencimiento we want to update
     *   }
     * })
     */
    upsert<T extends tipos_de_vencimientoUpsertArgs>(args: SelectSubset<T, tipos_de_vencimientoUpsertArgs<ExtArgs>>): Prisma__tipos_de_vencimientoClient<$Result.GetResult<Prisma.$tipos_de_vencimientoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tipos_de_vencimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_vencimientoCountArgs} args - Arguments to filter Tipos_de_vencimientos to count.
     * @example
     * // Count the number of Tipos_de_vencimientos
     * const count = await prisma.tipos_de_vencimiento.count({
     *   where: {
     *     // ... the filter for the Tipos_de_vencimientos we want to count
     *   }
     * })
    **/
    count<T extends tipos_de_vencimientoCountArgs>(
      args?: Subset<T, tipos_de_vencimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipos_de_vencimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipos_de_vencimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipos_de_vencimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipos_de_vencimientoAggregateArgs>(args: Subset<T, Tipos_de_vencimientoAggregateArgs>): Prisma.PrismaPromise<GetTipos_de_vencimientoAggregateType<T>>

    /**
     * Group by Tipos_de_vencimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipos_de_vencimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipos_de_vencimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipos_de_vencimientoGroupByArgs['orderBy'] }
        : { orderBy?: tipos_de_vencimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipos_de_vencimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipos_de_vencimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipos_de_vencimiento model
   */
  readonly fields: tipos_de_vencimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipos_de_vencimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipos_de_vencimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    polizas<T extends tipos_de_vencimiento$polizasArgs<ExtArgs> = {}>(args?: Subset<T, tipos_de_vencimiento$polizasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipos_de_vencimiento model
   */
  interface tipos_de_vencimientoFieldRefs {
    readonly id: FieldRef<"tipos_de_vencimiento", 'BigInt'>
    readonly label: FieldRef<"tipos_de_vencimiento", 'String'>
    readonly estatus: FieldRef<"tipos_de_vencimiento", 'Boolean'>
    readonly created_at: FieldRef<"tipos_de_vencimiento", 'DateTime'>
    readonly updated_at: FieldRef<"tipos_de_vencimiento", 'DateTime'>
    readonly deleted_at: FieldRef<"tipos_de_vencimiento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tipos_de_vencimiento findUnique
   */
  export type tipos_de_vencimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_vencimiento
     */
    select?: tipos_de_vencimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_vencimiento
     */
    omit?: tipos_de_vencimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_vencimientoInclude<ExtArgs> | null
    /**
     * Filter, which tipos_de_vencimiento to fetch.
     */
    where: tipos_de_vencimientoWhereUniqueInput
  }

  /**
   * tipos_de_vencimiento findUniqueOrThrow
   */
  export type tipos_de_vencimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_vencimiento
     */
    select?: tipos_de_vencimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_vencimiento
     */
    omit?: tipos_de_vencimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_vencimientoInclude<ExtArgs> | null
    /**
     * Filter, which tipos_de_vencimiento to fetch.
     */
    where: tipos_de_vencimientoWhereUniqueInput
  }

  /**
   * tipos_de_vencimiento findFirst
   */
  export type tipos_de_vencimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_vencimiento
     */
    select?: tipos_de_vencimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_vencimiento
     */
    omit?: tipos_de_vencimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_vencimientoInclude<ExtArgs> | null
    /**
     * Filter, which tipos_de_vencimiento to fetch.
     */
    where?: tipos_de_vencimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_de_vencimientos to fetch.
     */
    orderBy?: tipos_de_vencimientoOrderByWithRelationInput | tipos_de_vencimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipos_de_vencimientos.
     */
    cursor?: tipos_de_vencimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_de_vencimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_de_vencimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipos_de_vencimientos.
     */
    distinct?: Tipos_de_vencimientoScalarFieldEnum | Tipos_de_vencimientoScalarFieldEnum[]
  }

  /**
   * tipos_de_vencimiento findFirstOrThrow
   */
  export type tipos_de_vencimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_vencimiento
     */
    select?: tipos_de_vencimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_vencimiento
     */
    omit?: tipos_de_vencimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_vencimientoInclude<ExtArgs> | null
    /**
     * Filter, which tipos_de_vencimiento to fetch.
     */
    where?: tipos_de_vencimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_de_vencimientos to fetch.
     */
    orderBy?: tipos_de_vencimientoOrderByWithRelationInput | tipos_de_vencimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipos_de_vencimientos.
     */
    cursor?: tipos_de_vencimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_de_vencimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_de_vencimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipos_de_vencimientos.
     */
    distinct?: Tipos_de_vencimientoScalarFieldEnum | Tipos_de_vencimientoScalarFieldEnum[]
  }

  /**
   * tipos_de_vencimiento findMany
   */
  export type tipos_de_vencimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_vencimiento
     */
    select?: tipos_de_vencimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_vencimiento
     */
    omit?: tipos_de_vencimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_vencimientoInclude<ExtArgs> | null
    /**
     * Filter, which tipos_de_vencimientos to fetch.
     */
    where?: tipos_de_vencimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipos_de_vencimientos to fetch.
     */
    orderBy?: tipos_de_vencimientoOrderByWithRelationInput | tipos_de_vencimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipos_de_vencimientos.
     */
    cursor?: tipos_de_vencimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipos_de_vencimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipos_de_vencimientos.
     */
    skip?: number
    distinct?: Tipos_de_vencimientoScalarFieldEnum | Tipos_de_vencimientoScalarFieldEnum[]
  }

  /**
   * tipos_de_vencimiento create
   */
  export type tipos_de_vencimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_vencimiento
     */
    select?: tipos_de_vencimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_vencimiento
     */
    omit?: tipos_de_vencimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_vencimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a tipos_de_vencimiento.
     */
    data: XOR<tipos_de_vencimientoCreateInput, tipos_de_vencimientoUncheckedCreateInput>
  }

  /**
   * tipos_de_vencimiento createMany
   */
  export type tipos_de_vencimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipos_de_vencimientos.
     */
    data: tipos_de_vencimientoCreateManyInput | tipos_de_vencimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipos_de_vencimiento update
   */
  export type tipos_de_vencimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_vencimiento
     */
    select?: tipos_de_vencimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_vencimiento
     */
    omit?: tipos_de_vencimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_vencimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a tipos_de_vencimiento.
     */
    data: XOR<tipos_de_vencimientoUpdateInput, tipos_de_vencimientoUncheckedUpdateInput>
    /**
     * Choose, which tipos_de_vencimiento to update.
     */
    where: tipos_de_vencimientoWhereUniqueInput
  }

  /**
   * tipos_de_vencimiento updateMany
   */
  export type tipos_de_vencimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipos_de_vencimientos.
     */
    data: XOR<tipos_de_vencimientoUpdateManyMutationInput, tipos_de_vencimientoUncheckedUpdateManyInput>
    /**
     * Filter which tipos_de_vencimientos to update
     */
    where?: tipos_de_vencimientoWhereInput
    /**
     * Limit how many tipos_de_vencimientos to update.
     */
    limit?: number
  }

  /**
   * tipos_de_vencimiento upsert
   */
  export type tipos_de_vencimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_vencimiento
     */
    select?: tipos_de_vencimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_vencimiento
     */
    omit?: tipos_de_vencimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_vencimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the tipos_de_vencimiento to update in case it exists.
     */
    where: tipos_de_vencimientoWhereUniqueInput
    /**
     * In case the tipos_de_vencimiento found by the `where` argument doesn't exist, create a new tipos_de_vencimiento with this data.
     */
    create: XOR<tipos_de_vencimientoCreateInput, tipos_de_vencimientoUncheckedCreateInput>
    /**
     * In case the tipos_de_vencimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipos_de_vencimientoUpdateInput, tipos_de_vencimientoUncheckedUpdateInput>
  }

  /**
   * tipos_de_vencimiento delete
   */
  export type tipos_de_vencimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_vencimiento
     */
    select?: tipos_de_vencimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_vencimiento
     */
    omit?: tipos_de_vencimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_vencimientoInclude<ExtArgs> | null
    /**
     * Filter which tipos_de_vencimiento to delete.
     */
    where: tipos_de_vencimientoWhereUniqueInput
  }

  /**
   * tipos_de_vencimiento deleteMany
   */
  export type tipos_de_vencimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipos_de_vencimientos to delete
     */
    where?: tipos_de_vencimientoWhereInput
    /**
     * Limit how many tipos_de_vencimientos to delete.
     */
    limit?: number
  }

  /**
   * tipos_de_vencimiento.polizas
   */
  export type tipos_de_vencimiento$polizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    where?: polizasWhereInput
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    cursor?: polizasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * tipos_de_vencimiento without action
   */
  export type tipos_de_vencimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipos_de_vencimiento
     */
    select?: tipos_de_vencimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipos_de_vencimiento
     */
    omit?: tipos_de_vencimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipos_de_vencimientoInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: bigint | null
  }

  export type UsersMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    email_verified_at: Date | null
    password: string | null
    remember_token: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    email_verified_at: Date | null
    password: string | null
    remember_token: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    email_verified_at: number
    password: number
    remember_token: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified_at?: true
    password?: true
    remember_token?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified_at?: true
    password?: true
    remember_token?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified_at?: true
    password?: true
    remember_token?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: bigint
    name: string
    email: string
    email_verified_at: Date | null
    password: string
    remember_token: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    remember_token?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    remember_token?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "email_verified_at" | "password" | "remember_token" | "created_at" | "updated_at", ExtArgs["result"]["users"]>

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      email: string
      email_verified_at: Date | null
      password: string
      remember_token: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'BigInt'>
    readonly name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly email_verified_at: FieldRef<"users", 'DateTime'>
    readonly password: FieldRef<"users", 'String'>
    readonly remember_token: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
  }


  /**
   * Model usuario_claves
   */

  export type AggregateUsuario_claves = {
    _count: Usuario_clavesCountAggregateOutputType | null
    _avg: Usuario_clavesAvgAggregateOutputType | null
    _sum: Usuario_clavesSumAggregateOutputType | null
    _min: Usuario_clavesMinAggregateOutputType | null
    _max: Usuario_clavesMaxAggregateOutputType | null
  }

  export type Usuario_clavesAvgAggregateOutputType = {
    id: number | null
    compania_id: number | null
    usuario_id: number | null
  }

  export type Usuario_clavesSumAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    usuario_id: bigint | null
  }

  export type Usuario_clavesMinAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    clave: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    usuario_id: bigint | null
  }

  export type Usuario_clavesMaxAggregateOutputType = {
    id: bigint | null
    compania_id: bigint | null
    clave: string | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
    usuario_id: bigint | null
  }

  export type Usuario_clavesCountAggregateOutputType = {
    id: number
    compania_id: number
    clave: number
    estatus: number
    created_at: number
    updated_at: number
    usuario_id: number
    _all: number
  }


  export type Usuario_clavesAvgAggregateInputType = {
    id?: true
    compania_id?: true
    usuario_id?: true
  }

  export type Usuario_clavesSumAggregateInputType = {
    id?: true
    compania_id?: true
    usuario_id?: true
  }

  export type Usuario_clavesMinAggregateInputType = {
    id?: true
    compania_id?: true
    clave?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    usuario_id?: true
  }

  export type Usuario_clavesMaxAggregateInputType = {
    id?: true
    compania_id?: true
    clave?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    usuario_id?: true
  }

  export type Usuario_clavesCountAggregateInputType = {
    id?: true
    compania_id?: true
    clave?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    usuario_id?: true
    _all?: true
  }

  export type Usuario_clavesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario_claves to aggregate.
     */
    where?: usuario_clavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_claves to fetch.
     */
    orderBy?: usuario_clavesOrderByWithRelationInput | usuario_clavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuario_clavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_claves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_claves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuario_claves
    **/
    _count?: true | Usuario_clavesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Usuario_clavesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Usuario_clavesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Usuario_clavesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Usuario_clavesMaxAggregateInputType
  }

  export type GetUsuario_clavesAggregateType<T extends Usuario_clavesAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario_claves]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario_claves[P]>
      : GetScalarType<T[P], AggregateUsuario_claves[P]>
  }




  export type usuario_clavesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuario_clavesWhereInput
    orderBy?: usuario_clavesOrderByWithAggregationInput | usuario_clavesOrderByWithAggregationInput[]
    by: Usuario_clavesScalarFieldEnum[] | Usuario_clavesScalarFieldEnum
    having?: usuario_clavesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Usuario_clavesCountAggregateInputType | true
    _avg?: Usuario_clavesAvgAggregateInputType
    _sum?: Usuario_clavesSumAggregateInputType
    _min?: Usuario_clavesMinAggregateInputType
    _max?: Usuario_clavesMaxAggregateInputType
  }

  export type Usuario_clavesGroupByOutputType = {
    id: bigint
    compania_id: bigint
    clave: string
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    usuario_id: bigint
    _count: Usuario_clavesCountAggregateOutputType | null
    _avg: Usuario_clavesAvgAggregateOutputType | null
    _sum: Usuario_clavesSumAggregateOutputType | null
    _min: Usuario_clavesMinAggregateOutputType | null
    _max: Usuario_clavesMaxAggregateOutputType | null
  }

  type GetUsuario_clavesGroupByPayload<T extends usuario_clavesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Usuario_clavesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Usuario_clavesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Usuario_clavesGroupByOutputType[P]>
            : GetScalarType<T[P], Usuario_clavesGroupByOutputType[P]>
        }
      >
    >


  export type usuario_clavesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    compania_id?: boolean
    clave?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    usuario_id?: boolean
    compania?: boolean | companiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario_claves"]>



  export type usuario_clavesSelectScalar = {
    id?: boolean
    compania_id?: boolean
    clave?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    usuario_id?: boolean
  }

  export type usuario_clavesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "compania_id" | "clave" | "estatus" | "created_at" | "updated_at" | "usuario_id", ExtArgs["result"]["usuario_claves"]>
  export type usuario_clavesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compania?: boolean | companiaDefaultArgs<ExtArgs>
  }

  export type $usuario_clavesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuario_claves"
    objects: {
      compania: Prisma.$companiaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      compania_id: bigint
      clave: string
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
      usuario_id: bigint
    }, ExtArgs["result"]["usuario_claves"]>
    composites: {}
  }

  type usuario_clavesGetPayload<S extends boolean | null | undefined | usuario_clavesDefaultArgs> = $Result.GetResult<Prisma.$usuario_clavesPayload, S>

  type usuario_clavesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuario_clavesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Usuario_clavesCountAggregateInputType | true
    }

  export interface usuario_clavesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuario_claves'], meta: { name: 'usuario_claves' } }
    /**
     * Find zero or one Usuario_claves that matches the filter.
     * @param {usuario_clavesFindUniqueArgs} args - Arguments to find a Usuario_claves
     * @example
     * // Get one Usuario_claves
     * const usuario_claves = await prisma.usuario_claves.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuario_clavesFindUniqueArgs>(args: SelectSubset<T, usuario_clavesFindUniqueArgs<ExtArgs>>): Prisma__usuario_clavesClient<$Result.GetResult<Prisma.$usuario_clavesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario_claves that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuario_clavesFindUniqueOrThrowArgs} args - Arguments to find a Usuario_claves
     * @example
     * // Get one Usuario_claves
     * const usuario_claves = await prisma.usuario_claves.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuario_clavesFindUniqueOrThrowArgs>(args: SelectSubset<T, usuario_clavesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuario_clavesClient<$Result.GetResult<Prisma.$usuario_clavesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario_claves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_clavesFindFirstArgs} args - Arguments to find a Usuario_claves
     * @example
     * // Get one Usuario_claves
     * const usuario_claves = await prisma.usuario_claves.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuario_clavesFindFirstArgs>(args?: SelectSubset<T, usuario_clavesFindFirstArgs<ExtArgs>>): Prisma__usuario_clavesClient<$Result.GetResult<Prisma.$usuario_clavesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario_claves that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_clavesFindFirstOrThrowArgs} args - Arguments to find a Usuario_claves
     * @example
     * // Get one Usuario_claves
     * const usuario_claves = await prisma.usuario_claves.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuario_clavesFindFirstOrThrowArgs>(args?: SelectSubset<T, usuario_clavesFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuario_clavesClient<$Result.GetResult<Prisma.$usuario_clavesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuario_claves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_clavesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuario_claves
     * const usuario_claves = await prisma.usuario_claves.findMany()
     * 
     * // Get first 10 Usuario_claves
     * const usuario_claves = await prisma.usuario_claves.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuario_clavesWithIdOnly = await prisma.usuario_claves.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuario_clavesFindManyArgs>(args?: SelectSubset<T, usuario_clavesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuario_clavesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario_claves.
     * @param {usuario_clavesCreateArgs} args - Arguments to create a Usuario_claves.
     * @example
     * // Create one Usuario_claves
     * const Usuario_claves = await prisma.usuario_claves.create({
     *   data: {
     *     // ... data to create a Usuario_claves
     *   }
     * })
     * 
     */
    create<T extends usuario_clavesCreateArgs>(args: SelectSubset<T, usuario_clavesCreateArgs<ExtArgs>>): Prisma__usuario_clavesClient<$Result.GetResult<Prisma.$usuario_clavesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuario_claves.
     * @param {usuario_clavesCreateManyArgs} args - Arguments to create many Usuario_claves.
     * @example
     * // Create many Usuario_claves
     * const usuario_claves = await prisma.usuario_claves.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuario_clavesCreateManyArgs>(args?: SelectSubset<T, usuario_clavesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario_claves.
     * @param {usuario_clavesDeleteArgs} args - Arguments to delete one Usuario_claves.
     * @example
     * // Delete one Usuario_claves
     * const Usuario_claves = await prisma.usuario_claves.delete({
     *   where: {
     *     // ... filter to delete one Usuario_claves
     *   }
     * })
     * 
     */
    delete<T extends usuario_clavesDeleteArgs>(args: SelectSubset<T, usuario_clavesDeleteArgs<ExtArgs>>): Prisma__usuario_clavesClient<$Result.GetResult<Prisma.$usuario_clavesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario_claves.
     * @param {usuario_clavesUpdateArgs} args - Arguments to update one Usuario_claves.
     * @example
     * // Update one Usuario_claves
     * const usuario_claves = await prisma.usuario_claves.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuario_clavesUpdateArgs>(args: SelectSubset<T, usuario_clavesUpdateArgs<ExtArgs>>): Prisma__usuario_clavesClient<$Result.GetResult<Prisma.$usuario_clavesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuario_claves.
     * @param {usuario_clavesDeleteManyArgs} args - Arguments to filter Usuario_claves to delete.
     * @example
     * // Delete a few Usuario_claves
     * const { count } = await prisma.usuario_claves.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuario_clavesDeleteManyArgs>(args?: SelectSubset<T, usuario_clavesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuario_claves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_clavesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuario_claves
     * const usuario_claves = await prisma.usuario_claves.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuario_clavesUpdateManyArgs>(args: SelectSubset<T, usuario_clavesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario_claves.
     * @param {usuario_clavesUpsertArgs} args - Arguments to update or create a Usuario_claves.
     * @example
     * // Update or create a Usuario_claves
     * const usuario_claves = await prisma.usuario_claves.upsert({
     *   create: {
     *     // ... data to create a Usuario_claves
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario_claves we want to update
     *   }
     * })
     */
    upsert<T extends usuario_clavesUpsertArgs>(args: SelectSubset<T, usuario_clavesUpsertArgs<ExtArgs>>): Prisma__usuario_clavesClient<$Result.GetResult<Prisma.$usuario_clavesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuario_claves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_clavesCountArgs} args - Arguments to filter Usuario_claves to count.
     * @example
     * // Count the number of Usuario_claves
     * const count = await prisma.usuario_claves.count({
     *   where: {
     *     // ... the filter for the Usuario_claves we want to count
     *   }
     * })
    **/
    count<T extends usuario_clavesCountArgs>(
      args?: Subset<T, usuario_clavesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Usuario_clavesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario_claves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_clavesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Usuario_clavesAggregateArgs>(args: Subset<T, Usuario_clavesAggregateArgs>): Prisma.PrismaPromise<GetUsuario_clavesAggregateType<T>>

    /**
     * Group by Usuario_claves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_clavesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuario_clavesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuario_clavesGroupByArgs['orderBy'] }
        : { orderBy?: usuario_clavesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuario_clavesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuario_clavesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuario_claves model
   */
  readonly fields: usuario_clavesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario_claves.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuario_clavesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    compania<T extends companiaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiaDefaultArgs<ExtArgs>>): Prisma__companiaClient<$Result.GetResult<Prisma.$companiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuario_claves model
   */
  interface usuario_clavesFieldRefs {
    readonly id: FieldRef<"usuario_claves", 'BigInt'>
    readonly compania_id: FieldRef<"usuario_claves", 'BigInt'>
    readonly clave: FieldRef<"usuario_claves", 'String'>
    readonly estatus: FieldRef<"usuario_claves", 'Boolean'>
    readonly created_at: FieldRef<"usuario_claves", 'DateTime'>
    readonly updated_at: FieldRef<"usuario_claves", 'DateTime'>
    readonly usuario_id: FieldRef<"usuario_claves", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * usuario_claves findUnique
   */
  export type usuario_clavesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
    /**
     * Filter, which usuario_claves to fetch.
     */
    where: usuario_clavesWhereUniqueInput
  }

  /**
   * usuario_claves findUniqueOrThrow
   */
  export type usuario_clavesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
    /**
     * Filter, which usuario_claves to fetch.
     */
    where: usuario_clavesWhereUniqueInput
  }

  /**
   * usuario_claves findFirst
   */
  export type usuario_clavesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
    /**
     * Filter, which usuario_claves to fetch.
     */
    where?: usuario_clavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_claves to fetch.
     */
    orderBy?: usuario_clavesOrderByWithRelationInput | usuario_clavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_claves.
     */
    cursor?: usuario_clavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_claves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_claves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_claves.
     */
    distinct?: Usuario_clavesScalarFieldEnum | Usuario_clavesScalarFieldEnum[]
  }

  /**
   * usuario_claves findFirstOrThrow
   */
  export type usuario_clavesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
    /**
     * Filter, which usuario_claves to fetch.
     */
    where?: usuario_clavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_claves to fetch.
     */
    orderBy?: usuario_clavesOrderByWithRelationInput | usuario_clavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_claves.
     */
    cursor?: usuario_clavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_claves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_claves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_claves.
     */
    distinct?: Usuario_clavesScalarFieldEnum | Usuario_clavesScalarFieldEnum[]
  }

  /**
   * usuario_claves findMany
   */
  export type usuario_clavesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
    /**
     * Filter, which usuario_claves to fetch.
     */
    where?: usuario_clavesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_claves to fetch.
     */
    orderBy?: usuario_clavesOrderByWithRelationInput | usuario_clavesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuario_claves.
     */
    cursor?: usuario_clavesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_claves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_claves.
     */
    skip?: number
    distinct?: Usuario_clavesScalarFieldEnum | Usuario_clavesScalarFieldEnum[]
  }

  /**
   * usuario_claves create
   */
  export type usuario_clavesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
    /**
     * The data needed to create a usuario_claves.
     */
    data: XOR<usuario_clavesCreateInput, usuario_clavesUncheckedCreateInput>
  }

  /**
   * usuario_claves createMany
   */
  export type usuario_clavesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuario_claves.
     */
    data: usuario_clavesCreateManyInput | usuario_clavesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuario_claves update
   */
  export type usuario_clavesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
    /**
     * The data needed to update a usuario_claves.
     */
    data: XOR<usuario_clavesUpdateInput, usuario_clavesUncheckedUpdateInput>
    /**
     * Choose, which usuario_claves to update.
     */
    where: usuario_clavesWhereUniqueInput
  }

  /**
   * usuario_claves updateMany
   */
  export type usuario_clavesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuario_claves.
     */
    data: XOR<usuario_clavesUpdateManyMutationInput, usuario_clavesUncheckedUpdateManyInput>
    /**
     * Filter which usuario_claves to update
     */
    where?: usuario_clavesWhereInput
    /**
     * Limit how many usuario_claves to update.
     */
    limit?: number
  }

  /**
   * usuario_claves upsert
   */
  export type usuario_clavesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
    /**
     * The filter to search for the usuario_claves to update in case it exists.
     */
    where: usuario_clavesWhereUniqueInput
    /**
     * In case the usuario_claves found by the `where` argument doesn't exist, create a new usuario_claves with this data.
     */
    create: XOR<usuario_clavesCreateInput, usuario_clavesUncheckedCreateInput>
    /**
     * In case the usuario_claves was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuario_clavesUpdateInput, usuario_clavesUncheckedUpdateInput>
  }

  /**
   * usuario_claves delete
   */
  export type usuario_clavesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
    /**
     * Filter which usuario_claves to delete.
     */
    where: usuario_clavesWhereUniqueInput
  }

  /**
   * usuario_claves deleteMany
   */
  export type usuario_clavesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario_claves to delete
     */
    where?: usuario_clavesWhereInput
    /**
     * Limit how many usuario_claves to delete.
     */
    limit?: number
  }

  /**
   * usuario_claves without action
   */
  export type usuario_clavesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_claves
     */
    select?: usuario_clavesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_claves
     */
    omit?: usuario_clavesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_clavesInclude<ExtArgs> | null
  }


  /**
   * Model usuario_team
   */

  export type AggregateUsuario_team = {
    _count: Usuario_teamCountAggregateOutputType | null
    _avg: Usuario_teamAvgAggregateOutputType | null
    _sum: Usuario_teamSumAggregateOutputType | null
    _min: Usuario_teamMinAggregateOutputType | null
    _max: Usuario_teamMaxAggregateOutputType | null
  }

  export type Usuario_teamAvgAggregateOutputType = {
    id: number | null
    principal_id: number | null
    tipo_id: number | null
    usuario_id: number | null
  }

  export type Usuario_teamSumAggregateOutputType = {
    id: bigint | null
    principal_id: bigint | null
    tipo_id: bigint | null
    usuario_id: bigint | null
  }

  export type Usuario_teamMinAggregateOutputType = {
    id: bigint | null
    principal_id: bigint | null
    tipo_id: bigint | null
    usuario_id: bigint | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Usuario_teamMaxAggregateOutputType = {
    id: bigint | null
    principal_id: bigint | null
    tipo_id: bigint | null
    usuario_id: bigint | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Usuario_teamCountAggregateOutputType = {
    id: number
    principal_id: number
    tipo_id: number
    usuario_id: number
    estatus: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Usuario_teamAvgAggregateInputType = {
    id?: true
    principal_id?: true
    tipo_id?: true
    usuario_id?: true
  }

  export type Usuario_teamSumAggregateInputType = {
    id?: true
    principal_id?: true
    tipo_id?: true
    usuario_id?: true
  }

  export type Usuario_teamMinAggregateInputType = {
    id?: true
    principal_id?: true
    tipo_id?: true
    usuario_id?: true
    estatus?: true
    created_at?: true
    updated_at?: true
  }

  export type Usuario_teamMaxAggregateInputType = {
    id?: true
    principal_id?: true
    tipo_id?: true
    usuario_id?: true
    estatus?: true
    created_at?: true
    updated_at?: true
  }

  export type Usuario_teamCountAggregateInputType = {
    id?: true
    principal_id?: true
    tipo_id?: true
    usuario_id?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Usuario_teamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario_team to aggregate.
     */
    where?: usuario_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_teams to fetch.
     */
    orderBy?: usuario_teamOrderByWithRelationInput | usuario_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuario_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuario_teams
    **/
    _count?: true | Usuario_teamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Usuario_teamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Usuario_teamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Usuario_teamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Usuario_teamMaxAggregateInputType
  }

  export type GetUsuario_teamAggregateType<T extends Usuario_teamAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario_team]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario_team[P]>
      : GetScalarType<T[P], AggregateUsuario_team[P]>
  }




  export type usuario_teamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuario_teamWhereInput
    orderBy?: usuario_teamOrderByWithAggregationInput | usuario_teamOrderByWithAggregationInput[]
    by: Usuario_teamScalarFieldEnum[] | Usuario_teamScalarFieldEnum
    having?: usuario_teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Usuario_teamCountAggregateInputType | true
    _avg?: Usuario_teamAvgAggregateInputType
    _sum?: Usuario_teamSumAggregateInputType
    _min?: Usuario_teamMinAggregateInputType
    _max?: Usuario_teamMaxAggregateInputType
  }

  export type Usuario_teamGroupByOutputType = {
    id: bigint
    principal_id: bigint
    tipo_id: bigint
    usuario_id: bigint
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: Usuario_teamCountAggregateOutputType | null
    _avg: Usuario_teamAvgAggregateOutputType | null
    _sum: Usuario_teamSumAggregateOutputType | null
    _min: Usuario_teamMinAggregateOutputType | null
    _max: Usuario_teamMaxAggregateOutputType | null
  }

  type GetUsuario_teamGroupByPayload<T extends usuario_teamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Usuario_teamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Usuario_teamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Usuario_teamGroupByOutputType[P]>
            : GetScalarType<T[P], Usuario_teamGroupByOutputType[P]>
        }
      >
    >


  export type usuario_teamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    principal_id?: boolean
    tipo_id?: boolean
    usuario_id?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    tipos_de_usuarios?: boolean | tipos_de_usuariosDefaultArgs<ExtArgs>
    usuarios?: boolean | usuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario_team"]>



  export type usuario_teamSelectScalar = {
    id?: boolean
    principal_id?: boolean
    tipo_id?: boolean
    usuario_id?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usuario_teamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "principal_id" | "tipo_id" | "usuario_id" | "estatus" | "created_at" | "updated_at", ExtArgs["result"]["usuario_team"]>
  export type usuario_teamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipos_de_usuarios?: boolean | tipos_de_usuariosDefaultArgs<ExtArgs>
    usuarios?: boolean | usuariosDefaultArgs<ExtArgs>
  }

  export type $usuario_teamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuario_team"
    objects: {
      tipos_de_usuarios: Prisma.$tipos_de_usuariosPayload<ExtArgs>
      usuarios: Prisma.$usuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      principal_id: bigint
      tipo_id: bigint
      usuario_id: bigint
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["usuario_team"]>
    composites: {}
  }

  type usuario_teamGetPayload<S extends boolean | null | undefined | usuario_teamDefaultArgs> = $Result.GetResult<Prisma.$usuario_teamPayload, S>

  type usuario_teamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuario_teamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Usuario_teamCountAggregateInputType | true
    }

  export interface usuario_teamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuario_team'], meta: { name: 'usuario_team' } }
    /**
     * Find zero or one Usuario_team that matches the filter.
     * @param {usuario_teamFindUniqueArgs} args - Arguments to find a Usuario_team
     * @example
     * // Get one Usuario_team
     * const usuario_team = await prisma.usuario_team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuario_teamFindUniqueArgs>(args: SelectSubset<T, usuario_teamFindUniqueArgs<ExtArgs>>): Prisma__usuario_teamClient<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario_team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuario_teamFindUniqueOrThrowArgs} args - Arguments to find a Usuario_team
     * @example
     * // Get one Usuario_team
     * const usuario_team = await prisma.usuario_team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuario_teamFindUniqueOrThrowArgs>(args: SelectSubset<T, usuario_teamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuario_teamClient<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario_team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_teamFindFirstArgs} args - Arguments to find a Usuario_team
     * @example
     * // Get one Usuario_team
     * const usuario_team = await prisma.usuario_team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuario_teamFindFirstArgs>(args?: SelectSubset<T, usuario_teamFindFirstArgs<ExtArgs>>): Prisma__usuario_teamClient<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario_team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_teamFindFirstOrThrowArgs} args - Arguments to find a Usuario_team
     * @example
     * // Get one Usuario_team
     * const usuario_team = await prisma.usuario_team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuario_teamFindFirstOrThrowArgs>(args?: SelectSubset<T, usuario_teamFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuario_teamClient<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuario_teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_teamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuario_teams
     * const usuario_teams = await prisma.usuario_team.findMany()
     * 
     * // Get first 10 Usuario_teams
     * const usuario_teams = await prisma.usuario_team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuario_teamWithIdOnly = await prisma.usuario_team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuario_teamFindManyArgs>(args?: SelectSubset<T, usuario_teamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario_team.
     * @param {usuario_teamCreateArgs} args - Arguments to create a Usuario_team.
     * @example
     * // Create one Usuario_team
     * const Usuario_team = await prisma.usuario_team.create({
     *   data: {
     *     // ... data to create a Usuario_team
     *   }
     * })
     * 
     */
    create<T extends usuario_teamCreateArgs>(args: SelectSubset<T, usuario_teamCreateArgs<ExtArgs>>): Prisma__usuario_teamClient<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuario_teams.
     * @param {usuario_teamCreateManyArgs} args - Arguments to create many Usuario_teams.
     * @example
     * // Create many Usuario_teams
     * const usuario_team = await prisma.usuario_team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuario_teamCreateManyArgs>(args?: SelectSubset<T, usuario_teamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario_team.
     * @param {usuario_teamDeleteArgs} args - Arguments to delete one Usuario_team.
     * @example
     * // Delete one Usuario_team
     * const Usuario_team = await prisma.usuario_team.delete({
     *   where: {
     *     // ... filter to delete one Usuario_team
     *   }
     * })
     * 
     */
    delete<T extends usuario_teamDeleteArgs>(args: SelectSubset<T, usuario_teamDeleteArgs<ExtArgs>>): Prisma__usuario_teamClient<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario_team.
     * @param {usuario_teamUpdateArgs} args - Arguments to update one Usuario_team.
     * @example
     * // Update one Usuario_team
     * const usuario_team = await prisma.usuario_team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuario_teamUpdateArgs>(args: SelectSubset<T, usuario_teamUpdateArgs<ExtArgs>>): Prisma__usuario_teamClient<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuario_teams.
     * @param {usuario_teamDeleteManyArgs} args - Arguments to filter Usuario_teams to delete.
     * @example
     * // Delete a few Usuario_teams
     * const { count } = await prisma.usuario_team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuario_teamDeleteManyArgs>(args?: SelectSubset<T, usuario_teamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuario_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuario_teams
     * const usuario_team = await prisma.usuario_team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuario_teamUpdateManyArgs>(args: SelectSubset<T, usuario_teamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario_team.
     * @param {usuario_teamUpsertArgs} args - Arguments to update or create a Usuario_team.
     * @example
     * // Update or create a Usuario_team
     * const usuario_team = await prisma.usuario_team.upsert({
     *   create: {
     *     // ... data to create a Usuario_team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario_team we want to update
     *   }
     * })
     */
    upsert<T extends usuario_teamUpsertArgs>(args: SelectSubset<T, usuario_teamUpsertArgs<ExtArgs>>): Prisma__usuario_teamClient<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuario_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_teamCountArgs} args - Arguments to filter Usuario_teams to count.
     * @example
     * // Count the number of Usuario_teams
     * const count = await prisma.usuario_team.count({
     *   where: {
     *     // ... the filter for the Usuario_teams we want to count
     *   }
     * })
    **/
    count<T extends usuario_teamCountArgs>(
      args?: Subset<T, usuario_teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Usuario_teamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario_team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_teamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Usuario_teamAggregateArgs>(args: Subset<T, Usuario_teamAggregateArgs>): Prisma.PrismaPromise<GetUsuario_teamAggregateType<T>>

    /**
     * Group by Usuario_team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_teamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuario_teamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuario_teamGroupByArgs['orderBy'] }
        : { orderBy?: usuario_teamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuario_teamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuario_teamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuario_team model
   */
  readonly fields: usuario_teamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario_team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuario_teamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tipos_de_usuarios<T extends tipos_de_usuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipos_de_usuariosDefaultArgs<ExtArgs>>): Prisma__tipos_de_usuariosClient<$Result.GetResult<Prisma.$tipos_de_usuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuarios<T extends usuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosDefaultArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuario_team model
   */
  interface usuario_teamFieldRefs {
    readonly id: FieldRef<"usuario_team", 'BigInt'>
    readonly principal_id: FieldRef<"usuario_team", 'BigInt'>
    readonly tipo_id: FieldRef<"usuario_team", 'BigInt'>
    readonly usuario_id: FieldRef<"usuario_team", 'BigInt'>
    readonly estatus: FieldRef<"usuario_team", 'Boolean'>
    readonly created_at: FieldRef<"usuario_team", 'DateTime'>
    readonly updated_at: FieldRef<"usuario_team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * usuario_team findUnique
   */
  export type usuario_teamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    /**
     * Filter, which usuario_team to fetch.
     */
    where: usuario_teamWhereUniqueInput
  }

  /**
   * usuario_team findUniqueOrThrow
   */
  export type usuario_teamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    /**
     * Filter, which usuario_team to fetch.
     */
    where: usuario_teamWhereUniqueInput
  }

  /**
   * usuario_team findFirst
   */
  export type usuario_teamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    /**
     * Filter, which usuario_team to fetch.
     */
    where?: usuario_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_teams to fetch.
     */
    orderBy?: usuario_teamOrderByWithRelationInput | usuario_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_teams.
     */
    cursor?: usuario_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_teams.
     */
    distinct?: Usuario_teamScalarFieldEnum | Usuario_teamScalarFieldEnum[]
  }

  /**
   * usuario_team findFirstOrThrow
   */
  export type usuario_teamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    /**
     * Filter, which usuario_team to fetch.
     */
    where?: usuario_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_teams to fetch.
     */
    orderBy?: usuario_teamOrderByWithRelationInput | usuario_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_teams.
     */
    cursor?: usuario_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_teams.
     */
    distinct?: Usuario_teamScalarFieldEnum | Usuario_teamScalarFieldEnum[]
  }

  /**
   * usuario_team findMany
   */
  export type usuario_teamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    /**
     * Filter, which usuario_teams to fetch.
     */
    where?: usuario_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_teams to fetch.
     */
    orderBy?: usuario_teamOrderByWithRelationInput | usuario_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuario_teams.
     */
    cursor?: usuario_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_teams.
     */
    skip?: number
    distinct?: Usuario_teamScalarFieldEnum | Usuario_teamScalarFieldEnum[]
  }

  /**
   * usuario_team create
   */
  export type usuario_teamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    /**
     * The data needed to create a usuario_team.
     */
    data: XOR<usuario_teamCreateInput, usuario_teamUncheckedCreateInput>
  }

  /**
   * usuario_team createMany
   */
  export type usuario_teamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuario_teams.
     */
    data: usuario_teamCreateManyInput | usuario_teamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuario_team update
   */
  export type usuario_teamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    /**
     * The data needed to update a usuario_team.
     */
    data: XOR<usuario_teamUpdateInput, usuario_teamUncheckedUpdateInput>
    /**
     * Choose, which usuario_team to update.
     */
    where: usuario_teamWhereUniqueInput
  }

  /**
   * usuario_team updateMany
   */
  export type usuario_teamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuario_teams.
     */
    data: XOR<usuario_teamUpdateManyMutationInput, usuario_teamUncheckedUpdateManyInput>
    /**
     * Filter which usuario_teams to update
     */
    where?: usuario_teamWhereInput
    /**
     * Limit how many usuario_teams to update.
     */
    limit?: number
  }

  /**
   * usuario_team upsert
   */
  export type usuario_teamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    /**
     * The filter to search for the usuario_team to update in case it exists.
     */
    where: usuario_teamWhereUniqueInput
    /**
     * In case the usuario_team found by the `where` argument doesn't exist, create a new usuario_team with this data.
     */
    create: XOR<usuario_teamCreateInput, usuario_teamUncheckedCreateInput>
    /**
     * In case the usuario_team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuario_teamUpdateInput, usuario_teamUncheckedUpdateInput>
  }

  /**
   * usuario_team delete
   */
  export type usuario_teamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    /**
     * Filter which usuario_team to delete.
     */
    where: usuario_teamWhereUniqueInput
  }

  /**
   * usuario_team deleteMany
   */
  export type usuario_teamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario_teams to delete
     */
    where?: usuario_teamWhereInput
    /**
     * Limit how many usuario_teams to delete.
     */
    limit?: number
  }

  /**
   * usuario_team without action
   */
  export type usuario_teamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
  }


  /**
   * Model usuarios
   */

  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosAvgAggregateOutputType = {
    id: number | null
    tipo_id: number | null
  }

  export type UsuariosSumAggregateOutputType = {
    id: bigint | null
    tipo_id: bigint | null
  }

  export type UsuariosMinAggregateOutputType = {
    id: bigint | null
    nombre: string | null
    correo: string | null
    password: string | null
    tipo_id: bigint | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsuariosMaxAggregateOutputType = {
    id: bigint | null
    nombre: string | null
    correo: string | null
    password: string | null
    tipo_id: bigint | null
    estatus: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsuariosCountAggregateOutputType = {
    id: number
    nombre: number
    correo: number
    password: number
    tipo_id: number
    estatus: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsuariosAvgAggregateInputType = {
    id?: true
    tipo_id?: true
  }

  export type UsuariosSumAggregateInputType = {
    id?: true
    tipo_id?: true
  }

  export type UsuariosMinAggregateInputType = {
    id?: true
    nombre?: true
    correo?: true
    password?: true
    tipo_id?: true
    estatus?: true
    created_at?: true
    updated_at?: true
  }

  export type UsuariosMaxAggregateInputType = {
    id?: true
    nombre?: true
    correo?: true
    password?: true
    tipo_id?: true
    estatus?: true
    created_at?: true
    updated_at?: true
  }

  export type UsuariosCountAggregateInputType = {
    id?: true
    nombre?: true
    correo?: true
    password?: true
    tipo_id?: true
    estatus?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to aggregate.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type usuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuariosWhereInput
    orderBy?: usuariosOrderByWithAggregationInput | usuariosOrderByWithAggregationInput[]
    by: UsuariosScalarFieldEnum[] | UsuariosScalarFieldEnum
    having?: usuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _avg?: UsuariosAvgAggregateInputType
    _sum?: UsuariosSumAggregateInputType
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }

  export type UsuariosGroupByOutputType = {
    id: bigint
    nombre: string
    correo: string
    password: string
    tipo_id: bigint
    estatus: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends usuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type usuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    correo?: boolean
    password?: boolean
    tipo_id?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
    polizas?: boolean | usuarios$polizasArgs<ExtArgs>
    usuario_team?: boolean | usuarios$usuario_teamArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarios"]>



  export type usuariosSelectScalar = {
    id?: boolean
    nombre?: boolean
    correo?: boolean
    password?: boolean
    tipo_id?: boolean
    estatus?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usuariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "correo" | "password" | "tipo_id" | "estatus" | "created_at" | "updated_at", ExtArgs["result"]["usuarios"]>
  export type usuariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    polizas?: boolean | usuarios$polizasArgs<ExtArgs>
    usuario_team?: boolean | usuarios$usuario_teamArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuarios"
    objects: {
      polizas: Prisma.$polizasPayload<ExtArgs>[]
      usuario_team: Prisma.$usuario_teamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      nombre: string
      correo: string
      password: string
      tipo_id: bigint
      estatus: boolean
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["usuarios"]>
    composites: {}
  }

  type usuariosGetPayload<S extends boolean | null | undefined | usuariosDefaultArgs> = $Result.GetResult<Prisma.$usuariosPayload, S>

  type usuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface usuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuarios'], meta: { name: 'usuarios' } }
    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {usuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuariosFindUniqueArgs>(args: SelectSubset<T, usuariosFindUniqueArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuariosFindUniqueOrThrowArgs>(args: SelectSubset<T, usuariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuariosFindFirstArgs>(args?: SelectSubset<T, usuariosFindFirstArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuariosFindFirstOrThrowArgs>(args?: SelectSubset<T, usuariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuariosFindManyArgs>(args?: SelectSubset<T, usuariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuarios.
     * @param {usuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
     */
    create<T extends usuariosCreateArgs>(args: SelectSubset<T, usuariosCreateArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {usuariosCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuariosCreateManyArgs>(args?: SelectSubset<T, usuariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuarios.
     * @param {usuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
     */
    delete<T extends usuariosDeleteArgs>(args: SelectSubset<T, usuariosDeleteArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuarios.
     * @param {usuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuariosUpdateArgs>(args: SelectSubset<T, usuariosUpdateArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {usuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuariosDeleteManyArgs>(args?: SelectSubset<T, usuariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuariosUpdateManyArgs>(args: SelectSubset<T, usuariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuarios.
     * @param {usuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
     */
    upsert<T extends usuariosUpsertArgs>(args: SelectSubset<T, usuariosUpsertArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuariosCountArgs>(
      args?: Subset<T, usuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuariosGroupByArgs['orderBy'] }
        : { orderBy?: usuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuarios model
   */
  readonly fields: usuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    polizas<T extends usuarios$polizasArgs<ExtArgs> = {}>(args?: Subset<T, usuarios$polizasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$polizasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuario_team<T extends usuarios$usuario_teamArgs<ExtArgs> = {}>(args?: Subset<T, usuarios$usuario_teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuario_teamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuarios model
   */
  interface usuariosFieldRefs {
    readonly id: FieldRef<"usuarios", 'BigInt'>
    readonly nombre: FieldRef<"usuarios", 'String'>
    readonly correo: FieldRef<"usuarios", 'String'>
    readonly password: FieldRef<"usuarios", 'String'>
    readonly tipo_id: FieldRef<"usuarios", 'BigInt'>
    readonly estatus: FieldRef<"usuarios", 'Boolean'>
    readonly created_at: FieldRef<"usuarios", 'DateTime'>
    readonly updated_at: FieldRef<"usuarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * usuarios findUnique
   */
  export type usuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios findUniqueOrThrow
   */
  export type usuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios findFirst
   */
  export type usuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios findFirstOrThrow
   */
  export type usuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios findMany
   */
  export type usuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios create
   */
  export type usuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * The data needed to create a usuarios.
     */
    data: XOR<usuariosCreateInput, usuariosUncheckedCreateInput>
  }

  /**
   * usuarios createMany
   */
  export type usuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuariosCreateManyInput | usuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuarios update
   */
  export type usuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * The data needed to update a usuarios.
     */
    data: XOR<usuariosUpdateInput, usuariosUncheckedUpdateInput>
    /**
     * Choose, which usuarios to update.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios updateMany
   */
  export type usuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuariosUpdateManyMutationInput, usuariosUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuariosWhereInput
    /**
     * Limit how many usuarios to update.
     */
    limit?: number
  }

  /**
   * usuarios upsert
   */
  export type usuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * The filter to search for the usuarios to update in case it exists.
     */
    where: usuariosWhereUniqueInput
    /**
     * In case the usuarios found by the `where` argument doesn't exist, create a new usuarios with this data.
     */
    create: XOR<usuariosCreateInput, usuariosUncheckedCreateInput>
    /**
     * In case the usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuariosUpdateInput, usuariosUncheckedUpdateInput>
  }

  /**
   * usuarios delete
   */
  export type usuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter which usuarios to delete.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios deleteMany
   */
  export type usuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuariosWhereInput
    /**
     * Limit how many usuarios to delete.
     */
    limit?: number
  }

  /**
   * usuarios.polizas
   */
  export type usuarios$polizasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the polizas
     */
    select?: polizasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the polizas
     */
    omit?: polizasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: polizasInclude<ExtArgs> | null
    where?: polizasWhereInput
    orderBy?: polizasOrderByWithRelationInput | polizasOrderByWithRelationInput[]
    cursor?: polizasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolizasScalarFieldEnum | PolizasScalarFieldEnum[]
  }

  /**
   * usuarios.usuario_team
   */
  export type usuarios$usuario_teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_team
     */
    select?: usuario_teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario_team
     */
    omit?: usuario_teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_teamInclude<ExtArgs> | null
    where?: usuario_teamWhereInput
    orderBy?: usuario_teamOrderByWithRelationInput | usuario_teamOrderByWithRelationInput[]
    cursor?: usuario_teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Usuario_teamScalarFieldEnum | Usuario_teamScalarFieldEnum[]
  }

  /**
   * usuarios without action
   */
  export type usuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuarios
     */
    omit?: usuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ActividadesScalarFieldEnum: {
    id: 'id',
    label: 'label',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ActividadesScalarFieldEnum = (typeof ActividadesScalarFieldEnum)[keyof typeof ActividadesScalarFieldEnum]


  export const CacheScalarFieldEnum: {
    key: 'key',
    value: 'value',
    expiration: 'expiration'
  };

  export type CacheScalarFieldEnum = (typeof CacheScalarFieldEnum)[keyof typeof CacheScalarFieldEnum]


  export const Cache_locksScalarFieldEnum: {
    key: 'key',
    owner: 'owner',
    expiration: 'expiration'
  };

  export type Cache_locksScalarFieldEnum = (typeof Cache_locksScalarFieldEnum)[keyof typeof Cache_locksScalarFieldEnum]


  export const ClientesScalarFieldEnum: {
    id: 'id',
    rfc: 'rfc',
    nombre: 'nombre',
    fechaNacimiento: 'fechaNacimiento',
    direccion: 'direccion',
    colonia: 'colonia',
    codigoPostal: 'codigoPostal',
    estado_id: 'estado_id',
    ciudad: 'ciudad',
    correo: 'correo',
    telefono: 'telefono',
    celular: 'celular',
    oficina: 'oficina',
    casa: 'casa',
    observaciones: 'observaciones',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientesScalarFieldEnum = (typeof ClientesScalarFieldEnum)[keyof typeof ClientesScalarFieldEnum]


  export const CompaniaScalarFieldEnum: {
    id: 'id',
    rfc: 'rfc',
    nombre: 'nombre',
    nombreCorto: 'nombreCorto',
    direccion: 'direccion',
    estado: 'estado',
    codigoPostal: 'codigoPostal',
    ciudad: 'ciudad',
    limitePrimerPago: 'limitePrimerPago',
    limitePrimerSubsecuente: 'limitePrimerSubsecuente',
    estatus: 'estatus',
    colonia: 'colonia',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CompaniaScalarFieldEnum = (typeof CompaniaScalarFieldEnum)[keyof typeof CompaniaScalarFieldEnum]


  export const Compania_representantesScalarFieldEnum: {
    id: 'id',
    compania_id: 'compania_id',
    nombre: 'nombre',
    telefono: 'telefono',
    correo: 'correo',
    cargo: 'cargo',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Compania_representantesScalarFieldEnum = (typeof Compania_representantesScalarFieldEnum)[keyof typeof Compania_representantesScalarFieldEnum]


  export const Companias_productosScalarFieldEnum: {
    id: 'id',
    compania_id: 'compania_id',
    ramo_id: 'ramo_id',
    nombre: 'nombre',
    created_at: 'created_at',
    updated_at: 'updated_at',
    estatus: 'estatus'
  };

  export type Companias_productosScalarFieldEnum = (typeof Companias_productosScalarFieldEnum)[keyof typeof Companias_productosScalarFieldEnum]


  export const Companias_ramosScalarFieldEnum: {
    id: 'id',
    compania_id: 'compania_id',
    ramo_id: 'ramo_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    estatus: 'estatus'
  };

  export type Companias_ramosScalarFieldEnum = (typeof Companias_ramosScalarFieldEnum)[keyof typeof Companias_ramosScalarFieldEnum]


  export const EstadosScalarFieldEnum: {
    id: 'id',
    label: 'label',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type EstadosScalarFieldEnum = (typeof EstadosScalarFieldEnum)[keyof typeof EstadosScalarFieldEnum]


  export const Estatus_clienteScalarFieldEnum: {
    id: 'id',
    label: 'label',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Estatus_clienteScalarFieldEnum = (typeof Estatus_clienteScalarFieldEnum)[keyof typeof Estatus_clienteScalarFieldEnum]


  export const Estatus_polizasScalarFieldEnum: {
    id: 'id',
    label: 'label',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Estatus_polizasScalarFieldEnum = (typeof Estatus_polizasScalarFieldEnum)[keyof typeof Estatus_polizasScalarFieldEnum]


  export const Failed_jobsScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    connection: 'connection',
    queue: 'queue',
    payload: 'payload',
    exception: 'exception',
    failed_at: 'failed_at'
  };

  export type Failed_jobsScalarFieldEnum = (typeof Failed_jobsScalarFieldEnum)[keyof typeof Failed_jobsScalarFieldEnum]


  export const Formas_de_pagoScalarFieldEnum: {
    id: 'id',
    label: 'label',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Formas_de_pagoScalarFieldEnum = (typeof Formas_de_pagoScalarFieldEnum)[keyof typeof Formas_de_pagoScalarFieldEnum]


  export const Job_batchesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    total_jobs: 'total_jobs',
    pending_jobs: 'pending_jobs',
    failed_jobs: 'failed_jobs',
    failed_job_ids: 'failed_job_ids',
    options: 'options',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    finished_at: 'finished_at'
  };

  export type Job_batchesScalarFieldEnum = (typeof Job_batchesScalarFieldEnum)[keyof typeof Job_batchesScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    id: 'id',
    queue: 'queue',
    payload: 'payload',
    attempts: 'attempts',
    reserved_at: 'reserved_at',
    available_at: 'available_at',
    created_at: 'created_at'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const Metodos_de_pagoScalarFieldEnum: {
    id: 'id',
    label: 'label',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Metodos_de_pagoScalarFieldEnum = (typeof Metodos_de_pagoScalarFieldEnum)[keyof typeof Metodos_de_pagoScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    migration: 'migration',
    batch: 'batch'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const MonedasScalarFieldEnum: {
    id: 'id',
    label: 'label',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type MonedasScalarFieldEnum = (typeof MonedasScalarFieldEnum)[keyof typeof MonedasScalarFieldEnum]


  export const Password_reset_tokensScalarFieldEnum: {
    email: 'email',
    token: 'token',
    created_at: 'created_at'
  };

  export type Password_reset_tokensScalarFieldEnum = (typeof Password_reset_tokensScalarFieldEnum)[keyof typeof Password_reset_tokensScalarFieldEnum]


  export const Personal_access_tokensScalarFieldEnum: {
    id: 'id',
    tokenable_type: 'tokenable_type',
    tokenable_id: 'tokenable_id',
    name: 'name',
    token: 'token',
    abilities: 'abilities',
    last_used_at: 'last_used_at',
    expires_at: 'expires_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Personal_access_tokensScalarFieldEnum = (typeof Personal_access_tokensScalarFieldEnum)[keyof typeof Personal_access_tokensScalarFieldEnum]


  export const Poliza_aseguradosScalarFieldEnum: {
    id: 'id',
    poliza_id: 'poliza_id',
    cliente_id: 'cliente_id',
    rfc: 'rfc',
    nombre: 'nombre',
    fechaNacimiento: 'fechaNacimiento',
    direccion: 'direccion',
    colonia: 'colonia',
    codigoPostal: 'codigoPostal',
    estado_id: 'estado_id',
    ciudad: 'ciudad',
    correo: 'correo',
    telefono: 'telefono',
    celular: 'celular',
    oficina: 'oficina',
    casa: 'casa',
    observaciones: 'observaciones',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Poliza_aseguradosScalarFieldEnum = (typeof Poliza_aseguradosScalarFieldEnum)[keyof typeof Poliza_aseguradosScalarFieldEnum]


  export const Poliza_historialScalarFieldEnum: {
    id: 'id',
    poliza_id: 'poliza_id',
    accion: 'accion',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Poliza_historialScalarFieldEnum = (typeof Poliza_historialScalarFieldEnum)[keyof typeof Poliza_historialScalarFieldEnum]


  export const Poliza_recibosScalarFieldEnum: {
    id: 'id',
    poliza_id: 'poliza_id',
    numeroRecibo: 'numeroRecibo',
    vencimiento: 'vencimiento',
    importe: 'importe',
    estatus: 'estatus',
    fechaPago: 'fechaPago',
    fechaCancelado: 'fechaCancelado',
    evidencia: 'evidencia',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Poliza_recibosScalarFieldEnum = (typeof Poliza_recibosScalarFieldEnum)[keyof typeof Poliza_recibosScalarFieldEnum]


  export const PolizasScalarFieldEnum: {
    id: 'id',
    numeroPoliza: 'numeroPoliza',
    numeroCliente: 'numeroCliente',
    inicioVigencia: 'inicioVigencia',
    finVigencia: 'finVigencia',
    antiguedad: 'antiguedad',
    primaNeta: 'primaNeta',
    financiamiento: 'financiamiento',
    primaTotal: 'primaTotal',
    estatus_id: 'estatus_id',
    comisionAgente: 'comisionAgente',
    pagoInicial: 'pagoInicial',
    pagoSubsecuente: 'pagoSubsecuente',
    cliente_id: 'cliente_id',
    formaPago_id: 'formaPago_id',
    tipoVencimiento_id: 'tipoVencimiento_id',
    compania_id: 'compania_id',
    subAgente_id: 'subAgente_id',
    ramo_id: 'ramo_id',
    metodoPago_id: 'metodoPago_id',
    moneda_id: 'moneda_id',
    producto_id: 'producto_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PolizasScalarFieldEnum = (typeof PolizasScalarFieldEnum)[keyof typeof PolizasScalarFieldEnum]


  export const RamosScalarFieldEnum: {
    id: 'id',
    label: 'label',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type RamosScalarFieldEnum = (typeof RamosScalarFieldEnum)[keyof typeof RamosScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    payload: 'payload',
    last_activity: 'last_activity'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const Tipos_de_usuariosScalarFieldEnum: {
    id: 'id',
    label: 'label',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Tipos_de_usuariosScalarFieldEnum = (typeof Tipos_de_usuariosScalarFieldEnum)[keyof typeof Tipos_de_usuariosScalarFieldEnum]


  export const Tipos_de_vencimientoScalarFieldEnum: {
    id: 'id',
    label: 'label',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Tipos_de_vencimientoScalarFieldEnum = (typeof Tipos_de_vencimientoScalarFieldEnum)[keyof typeof Tipos_de_vencimientoScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    email_verified_at: 'email_verified_at',
    password: 'password',
    remember_token: 'remember_token',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Usuario_clavesScalarFieldEnum: {
    id: 'id',
    compania_id: 'compania_id',
    clave: 'clave',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at',
    usuario_id: 'usuario_id'
  };

  export type Usuario_clavesScalarFieldEnum = (typeof Usuario_clavesScalarFieldEnum)[keyof typeof Usuario_clavesScalarFieldEnum]


  export const Usuario_teamScalarFieldEnum: {
    id: 'id',
    principal_id: 'principal_id',
    tipo_id: 'tipo_id',
    usuario_id: 'usuario_id',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Usuario_teamScalarFieldEnum = (typeof Usuario_teamScalarFieldEnum)[keyof typeof Usuario_teamScalarFieldEnum]


  export const UsuariosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    correo: 'correo',
    password: 'password',
    tipo_id: 'tipo_id',
    estatus: 'estatus',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const actividadesOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type actividadesOrderByRelevanceFieldEnum = (typeof actividadesOrderByRelevanceFieldEnum)[keyof typeof actividadesOrderByRelevanceFieldEnum]


  export const cacheOrderByRelevanceFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type cacheOrderByRelevanceFieldEnum = (typeof cacheOrderByRelevanceFieldEnum)[keyof typeof cacheOrderByRelevanceFieldEnum]


  export const cache_locksOrderByRelevanceFieldEnum: {
    key: 'key',
    owner: 'owner'
  };

  export type cache_locksOrderByRelevanceFieldEnum = (typeof cache_locksOrderByRelevanceFieldEnum)[keyof typeof cache_locksOrderByRelevanceFieldEnum]


  export const clientesOrderByRelevanceFieldEnum: {
    rfc: 'rfc',
    nombre: 'nombre',
    direccion: 'direccion',
    colonia: 'colonia',
    codigoPostal: 'codigoPostal',
    ciudad: 'ciudad',
    correo: 'correo',
    telefono: 'telefono',
    celular: 'celular',
    oficina: 'oficina',
    casa: 'casa',
    observaciones: 'observaciones'
  };

  export type clientesOrderByRelevanceFieldEnum = (typeof clientesOrderByRelevanceFieldEnum)[keyof typeof clientesOrderByRelevanceFieldEnum]


  export const companiaOrderByRelevanceFieldEnum: {
    rfc: 'rfc',
    nombre: 'nombre',
    nombreCorto: 'nombreCorto',
    direccion: 'direccion',
    estado: 'estado',
    codigoPostal: 'codigoPostal',
    ciudad: 'ciudad',
    colonia: 'colonia'
  };

  export type companiaOrderByRelevanceFieldEnum = (typeof companiaOrderByRelevanceFieldEnum)[keyof typeof companiaOrderByRelevanceFieldEnum]


  export const compania_representantesOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    telefono: 'telefono',
    correo: 'correo',
    cargo: 'cargo'
  };

  export type compania_representantesOrderByRelevanceFieldEnum = (typeof compania_representantesOrderByRelevanceFieldEnum)[keyof typeof compania_representantesOrderByRelevanceFieldEnum]


  export const companias_productosOrderByRelevanceFieldEnum: {
    nombre: 'nombre'
  };

  export type companias_productosOrderByRelevanceFieldEnum = (typeof companias_productosOrderByRelevanceFieldEnum)[keyof typeof companias_productosOrderByRelevanceFieldEnum]


  export const estadosOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type estadosOrderByRelevanceFieldEnum = (typeof estadosOrderByRelevanceFieldEnum)[keyof typeof estadosOrderByRelevanceFieldEnum]


  export const estatus_clienteOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type estatus_clienteOrderByRelevanceFieldEnum = (typeof estatus_clienteOrderByRelevanceFieldEnum)[keyof typeof estatus_clienteOrderByRelevanceFieldEnum]


  export const estatus_polizasOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type estatus_polizasOrderByRelevanceFieldEnum = (typeof estatus_polizasOrderByRelevanceFieldEnum)[keyof typeof estatus_polizasOrderByRelevanceFieldEnum]


  export const failed_jobsOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    connection: 'connection',
    queue: 'queue',
    payload: 'payload',
    exception: 'exception'
  };

  export type failed_jobsOrderByRelevanceFieldEnum = (typeof failed_jobsOrderByRelevanceFieldEnum)[keyof typeof failed_jobsOrderByRelevanceFieldEnum]


  export const formas_de_pagoOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type formas_de_pagoOrderByRelevanceFieldEnum = (typeof formas_de_pagoOrderByRelevanceFieldEnum)[keyof typeof formas_de_pagoOrderByRelevanceFieldEnum]


  export const job_batchesOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    failed_job_ids: 'failed_job_ids',
    options: 'options'
  };

  export type job_batchesOrderByRelevanceFieldEnum = (typeof job_batchesOrderByRelevanceFieldEnum)[keyof typeof job_batchesOrderByRelevanceFieldEnum]


  export const jobsOrderByRelevanceFieldEnum: {
    queue: 'queue',
    payload: 'payload'
  };

  export type jobsOrderByRelevanceFieldEnum = (typeof jobsOrderByRelevanceFieldEnum)[keyof typeof jobsOrderByRelevanceFieldEnum]


  export const metodos_de_pagoOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type metodos_de_pagoOrderByRelevanceFieldEnum = (typeof metodos_de_pagoOrderByRelevanceFieldEnum)[keyof typeof metodos_de_pagoOrderByRelevanceFieldEnum]


  export const migrationsOrderByRelevanceFieldEnum: {
    migration: 'migration'
  };

  export type migrationsOrderByRelevanceFieldEnum = (typeof migrationsOrderByRelevanceFieldEnum)[keyof typeof migrationsOrderByRelevanceFieldEnum]


  export const monedasOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type monedasOrderByRelevanceFieldEnum = (typeof monedasOrderByRelevanceFieldEnum)[keyof typeof monedasOrderByRelevanceFieldEnum]


  export const password_reset_tokensOrderByRelevanceFieldEnum: {
    email: 'email',
    token: 'token'
  };

  export type password_reset_tokensOrderByRelevanceFieldEnum = (typeof password_reset_tokensOrderByRelevanceFieldEnum)[keyof typeof password_reset_tokensOrderByRelevanceFieldEnum]


  export const personal_access_tokensOrderByRelevanceFieldEnum: {
    tokenable_type: 'tokenable_type',
    name: 'name',
    token: 'token',
    abilities: 'abilities'
  };

  export type personal_access_tokensOrderByRelevanceFieldEnum = (typeof personal_access_tokensOrderByRelevanceFieldEnum)[keyof typeof personal_access_tokensOrderByRelevanceFieldEnum]


  export const poliza_aseguradosOrderByRelevanceFieldEnum: {
    rfc: 'rfc',
    nombre: 'nombre',
    direccion: 'direccion',
    colonia: 'colonia',
    codigoPostal: 'codigoPostal',
    ciudad: 'ciudad',
    correo: 'correo',
    telefono: 'telefono',
    celular: 'celular',
    oficina: 'oficina',
    casa: 'casa',
    observaciones: 'observaciones'
  };

  export type poliza_aseguradosOrderByRelevanceFieldEnum = (typeof poliza_aseguradosOrderByRelevanceFieldEnum)[keyof typeof poliza_aseguradosOrderByRelevanceFieldEnum]


  export const poliza_historialOrderByRelevanceFieldEnum: {
    accion: 'accion'
  };

  export type poliza_historialOrderByRelevanceFieldEnum = (typeof poliza_historialOrderByRelevanceFieldEnum)[keyof typeof poliza_historialOrderByRelevanceFieldEnum]


  export const poliza_recibosOrderByRelevanceFieldEnum: {
    numeroRecibo: 'numeroRecibo',
    evidencia: 'evidencia'
  };

  export type poliza_recibosOrderByRelevanceFieldEnum = (typeof poliza_recibosOrderByRelevanceFieldEnum)[keyof typeof poliza_recibosOrderByRelevanceFieldEnum]


  export const polizasOrderByRelevanceFieldEnum: {
    numeroPoliza: 'numeroPoliza',
    numeroCliente: 'numeroCliente'
  };

  export type polizasOrderByRelevanceFieldEnum = (typeof polizasOrderByRelevanceFieldEnum)[keyof typeof polizasOrderByRelevanceFieldEnum]


  export const ramosOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type ramosOrderByRelevanceFieldEnum = (typeof ramosOrderByRelevanceFieldEnum)[keyof typeof ramosOrderByRelevanceFieldEnum]


  export const sessionsOrderByRelevanceFieldEnum: {
    id: 'id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    payload: 'payload'
  };

  export type sessionsOrderByRelevanceFieldEnum = (typeof sessionsOrderByRelevanceFieldEnum)[keyof typeof sessionsOrderByRelevanceFieldEnum]


  export const tipos_de_usuariosOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type tipos_de_usuariosOrderByRelevanceFieldEnum = (typeof tipos_de_usuariosOrderByRelevanceFieldEnum)[keyof typeof tipos_de_usuariosOrderByRelevanceFieldEnum]


  export const tipos_de_vencimientoOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type tipos_de_vencimientoOrderByRelevanceFieldEnum = (typeof tipos_de_vencimientoOrderByRelevanceFieldEnum)[keyof typeof tipos_de_vencimientoOrderByRelevanceFieldEnum]


  export const usersOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    password: 'password',
    remember_token: 'remember_token'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  export const usuario_clavesOrderByRelevanceFieldEnum: {
    clave: 'clave'
  };

  export type usuario_clavesOrderByRelevanceFieldEnum = (typeof usuario_clavesOrderByRelevanceFieldEnum)[keyof typeof usuario_clavesOrderByRelevanceFieldEnum]


  export const usuariosOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    correo: 'correo',
    password: 'password'
  };

  export type usuariosOrderByRelevanceFieldEnum = (typeof usuariosOrderByRelevanceFieldEnum)[keyof typeof usuariosOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'poliza_recibos_estatus'
   */
  export type Enumpoliza_recibos_estatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'poliza_recibos_estatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type actividadesWhereInput = {
    AND?: actividadesWhereInput | actividadesWhereInput[]
    OR?: actividadesWhereInput[]
    NOT?: actividadesWhereInput | actividadesWhereInput[]
    id?: BigIntFilter<"actividades"> | bigint | number
    label?: StringFilter<"actividades"> | string
    estatus?: BoolFilter<"actividades"> | boolean
    created_at?: DateTimeNullableFilter<"actividades"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"actividades"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"actividades"> | Date | string | null
  }

  export type actividadesOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _relevance?: actividadesOrderByRelevanceInput
  }

  export type actividadesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: actividadesWhereInput | actividadesWhereInput[]
    OR?: actividadesWhereInput[]
    NOT?: actividadesWhereInput | actividadesWhereInput[]
    label?: StringFilter<"actividades"> | string
    estatus?: BoolFilter<"actividades"> | boolean
    created_at?: DateTimeNullableFilter<"actividades"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"actividades"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"actividades"> | Date | string | null
  }, "id">

  export type actividadesOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: actividadesCountOrderByAggregateInput
    _avg?: actividadesAvgOrderByAggregateInput
    _max?: actividadesMaxOrderByAggregateInput
    _min?: actividadesMinOrderByAggregateInput
    _sum?: actividadesSumOrderByAggregateInput
  }

  export type actividadesScalarWhereWithAggregatesInput = {
    AND?: actividadesScalarWhereWithAggregatesInput | actividadesScalarWhereWithAggregatesInput[]
    OR?: actividadesScalarWhereWithAggregatesInput[]
    NOT?: actividadesScalarWhereWithAggregatesInput | actividadesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"actividades"> | bigint | number
    label?: StringWithAggregatesFilter<"actividades"> | string
    estatus?: BoolWithAggregatesFilter<"actividades"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"actividades"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"actividades"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"actividades"> | Date | string | null
  }

  export type cacheWhereInput = {
    AND?: cacheWhereInput | cacheWhereInput[]
    OR?: cacheWhereInput[]
    NOT?: cacheWhereInput | cacheWhereInput[]
    key?: StringFilter<"cache"> | string
    value?: StringFilter<"cache"> | string
    expiration?: IntFilter<"cache"> | number
  }

  export type cacheOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
    _relevance?: cacheOrderByRelevanceInput
  }

  export type cacheWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: cacheWhereInput | cacheWhereInput[]
    OR?: cacheWhereInput[]
    NOT?: cacheWhereInput | cacheWhereInput[]
    value?: StringFilter<"cache"> | string
    expiration?: IntFilter<"cache"> | number
  }, "key">

  export type cacheOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
    _count?: cacheCountOrderByAggregateInput
    _avg?: cacheAvgOrderByAggregateInput
    _max?: cacheMaxOrderByAggregateInput
    _min?: cacheMinOrderByAggregateInput
    _sum?: cacheSumOrderByAggregateInput
  }

  export type cacheScalarWhereWithAggregatesInput = {
    AND?: cacheScalarWhereWithAggregatesInput | cacheScalarWhereWithAggregatesInput[]
    OR?: cacheScalarWhereWithAggregatesInput[]
    NOT?: cacheScalarWhereWithAggregatesInput | cacheScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"cache"> | string
    value?: StringWithAggregatesFilter<"cache"> | string
    expiration?: IntWithAggregatesFilter<"cache"> | number
  }

  export type cache_locksWhereInput = {
    AND?: cache_locksWhereInput | cache_locksWhereInput[]
    OR?: cache_locksWhereInput[]
    NOT?: cache_locksWhereInput | cache_locksWhereInput[]
    key?: StringFilter<"cache_locks"> | string
    owner?: StringFilter<"cache_locks"> | string
    expiration?: IntFilter<"cache_locks"> | number
  }

  export type cache_locksOrderByWithRelationInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
    _relevance?: cache_locksOrderByRelevanceInput
  }

  export type cache_locksWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: cache_locksWhereInput | cache_locksWhereInput[]
    OR?: cache_locksWhereInput[]
    NOT?: cache_locksWhereInput | cache_locksWhereInput[]
    owner?: StringFilter<"cache_locks"> | string
    expiration?: IntFilter<"cache_locks"> | number
  }, "key">

  export type cache_locksOrderByWithAggregationInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
    _count?: cache_locksCountOrderByAggregateInput
    _avg?: cache_locksAvgOrderByAggregateInput
    _max?: cache_locksMaxOrderByAggregateInput
    _min?: cache_locksMinOrderByAggregateInput
    _sum?: cache_locksSumOrderByAggregateInput
  }

  export type cache_locksScalarWhereWithAggregatesInput = {
    AND?: cache_locksScalarWhereWithAggregatesInput | cache_locksScalarWhereWithAggregatesInput[]
    OR?: cache_locksScalarWhereWithAggregatesInput[]
    NOT?: cache_locksScalarWhereWithAggregatesInput | cache_locksScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"cache_locks"> | string
    owner?: StringWithAggregatesFilter<"cache_locks"> | string
    expiration?: IntWithAggregatesFilter<"cache_locks"> | number
  }

  export type clientesWhereInput = {
    AND?: clientesWhereInput | clientesWhereInput[]
    OR?: clientesWhereInput[]
    NOT?: clientesWhereInput | clientesWhereInput[]
    id?: BigIntFilter<"clientes"> | bigint | number
    rfc?: StringFilter<"clientes"> | string
    nombre?: StringFilter<"clientes"> | string
    fechaNacimiento?: DateTimeFilter<"clientes"> | Date | string
    direccion?: StringFilter<"clientes"> | string
    colonia?: StringFilter<"clientes"> | string
    codigoPostal?: StringFilter<"clientes"> | string
    estado_id?: BigIntFilter<"clientes"> | bigint | number
    ciudad?: StringFilter<"clientes"> | string
    correo?: StringNullableFilter<"clientes"> | string | null
    telefono?: StringNullableFilter<"clientes"> | string | null
    celular?: StringNullableFilter<"clientes"> | string | null
    oficina?: StringNullableFilter<"clientes"> | string | null
    casa?: StringNullableFilter<"clientes"> | string | null
    observaciones?: StringNullableFilter<"clientes"> | string | null
    created_at?: DateTimeNullableFilter<"clientes"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"clientes"> | Date | string | null
    polizas?: PolizasListRelationFilter
  }

  export type clientesOrderByWithRelationInput = {
    id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    colonia?: SortOrder
    codigoPostal?: SortOrder
    estado_id?: SortOrder
    ciudad?: SortOrder
    correo?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    oficina?: SortOrderInput | SortOrder
    casa?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    polizas?: polizasOrderByRelationAggregateInput
    _relevance?: clientesOrderByRelevanceInput
  }

  export type clientesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    rfc?: string
    AND?: clientesWhereInput | clientesWhereInput[]
    OR?: clientesWhereInput[]
    NOT?: clientesWhereInput | clientesWhereInput[]
    nombre?: StringFilter<"clientes"> | string
    fechaNacimiento?: DateTimeFilter<"clientes"> | Date | string
    direccion?: StringFilter<"clientes"> | string
    colonia?: StringFilter<"clientes"> | string
    codigoPostal?: StringFilter<"clientes"> | string
    estado_id?: BigIntFilter<"clientes"> | bigint | number
    ciudad?: StringFilter<"clientes"> | string
    correo?: StringNullableFilter<"clientes"> | string | null
    telefono?: StringNullableFilter<"clientes"> | string | null
    celular?: StringNullableFilter<"clientes"> | string | null
    oficina?: StringNullableFilter<"clientes"> | string | null
    casa?: StringNullableFilter<"clientes"> | string | null
    observaciones?: StringNullableFilter<"clientes"> | string | null
    created_at?: DateTimeNullableFilter<"clientes"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"clientes"> | Date | string | null
    polizas?: PolizasListRelationFilter
  }, "id" | "rfc">

  export type clientesOrderByWithAggregationInput = {
    id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    colonia?: SortOrder
    codigoPostal?: SortOrder
    estado_id?: SortOrder
    ciudad?: SortOrder
    correo?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    oficina?: SortOrderInput | SortOrder
    casa?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: clientesCountOrderByAggregateInput
    _avg?: clientesAvgOrderByAggregateInput
    _max?: clientesMaxOrderByAggregateInput
    _min?: clientesMinOrderByAggregateInput
    _sum?: clientesSumOrderByAggregateInput
  }

  export type clientesScalarWhereWithAggregatesInput = {
    AND?: clientesScalarWhereWithAggregatesInput | clientesScalarWhereWithAggregatesInput[]
    OR?: clientesScalarWhereWithAggregatesInput[]
    NOT?: clientesScalarWhereWithAggregatesInput | clientesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"clientes"> | bigint | number
    rfc?: StringWithAggregatesFilter<"clientes"> | string
    nombre?: StringWithAggregatesFilter<"clientes"> | string
    fechaNacimiento?: DateTimeWithAggregatesFilter<"clientes"> | Date | string
    direccion?: StringWithAggregatesFilter<"clientes"> | string
    colonia?: StringWithAggregatesFilter<"clientes"> | string
    codigoPostal?: StringWithAggregatesFilter<"clientes"> | string
    estado_id?: BigIntWithAggregatesFilter<"clientes"> | bigint | number
    ciudad?: StringWithAggregatesFilter<"clientes"> | string
    correo?: StringNullableWithAggregatesFilter<"clientes"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"clientes"> | string | null
    celular?: StringNullableWithAggregatesFilter<"clientes"> | string | null
    oficina?: StringNullableWithAggregatesFilter<"clientes"> | string | null
    casa?: StringNullableWithAggregatesFilter<"clientes"> | string | null
    observaciones?: StringNullableWithAggregatesFilter<"clientes"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"clientes"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"clientes"> | Date | string | null
  }

  export type companiaWhereInput = {
    AND?: companiaWhereInput | companiaWhereInput[]
    OR?: companiaWhereInput[]
    NOT?: companiaWhereInput | companiaWhereInput[]
    id?: BigIntFilter<"compania"> | bigint | number
    rfc?: StringFilter<"compania"> | string
    nombre?: StringFilter<"compania"> | string
    nombreCorto?: StringFilter<"compania"> | string
    direccion?: StringNullableFilter<"compania"> | string | null
    estado?: StringNullableFilter<"compania"> | string | null
    codigoPostal?: StringNullableFilter<"compania"> | string | null
    ciudad?: StringNullableFilter<"compania"> | string | null
    limitePrimerPago?: DecimalNullableFilter<"compania"> | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: DecimalNullableFilter<"compania"> | Decimal | DecimalJsLike | number | string | null
    estatus?: BoolNullableFilter<"compania"> | boolean | null
    colonia?: StringNullableFilter<"compania"> | string | null
    created_at?: DateTimeNullableFilter<"compania"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"compania"> | Date | string | null
    compania_representantes?: Compania_representantesListRelationFilter
    companias_productos?: Companias_productosListRelationFilter
    companias_ramos?: Companias_ramosListRelationFilter
    polizas?: PolizasListRelationFilter
    usuario_claves?: Usuario_clavesListRelationFilter
  }

  export type companiaOrderByWithRelationInput = {
    id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    nombreCorto?: SortOrder
    direccion?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    codigoPostal?: SortOrderInput | SortOrder
    ciudad?: SortOrderInput | SortOrder
    limitePrimerPago?: SortOrderInput | SortOrder
    limitePrimerSubsecuente?: SortOrderInput | SortOrder
    estatus?: SortOrderInput | SortOrder
    colonia?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    compania_representantes?: compania_representantesOrderByRelationAggregateInput
    companias_productos?: companias_productosOrderByRelationAggregateInput
    companias_ramos?: companias_ramosOrderByRelationAggregateInput
    polizas?: polizasOrderByRelationAggregateInput
    usuario_claves?: usuario_clavesOrderByRelationAggregateInput
    _relevance?: companiaOrderByRelevanceInput
  }

  export type companiaWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    rfc?: string
    AND?: companiaWhereInput | companiaWhereInput[]
    OR?: companiaWhereInput[]
    NOT?: companiaWhereInput | companiaWhereInput[]
    nombre?: StringFilter<"compania"> | string
    nombreCorto?: StringFilter<"compania"> | string
    direccion?: StringNullableFilter<"compania"> | string | null
    estado?: StringNullableFilter<"compania"> | string | null
    codigoPostal?: StringNullableFilter<"compania"> | string | null
    ciudad?: StringNullableFilter<"compania"> | string | null
    limitePrimerPago?: DecimalNullableFilter<"compania"> | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: DecimalNullableFilter<"compania"> | Decimal | DecimalJsLike | number | string | null
    estatus?: BoolNullableFilter<"compania"> | boolean | null
    colonia?: StringNullableFilter<"compania"> | string | null
    created_at?: DateTimeNullableFilter<"compania"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"compania"> | Date | string | null
    compania_representantes?: Compania_representantesListRelationFilter
    companias_productos?: Companias_productosListRelationFilter
    companias_ramos?: Companias_ramosListRelationFilter
    polizas?: PolizasListRelationFilter
    usuario_claves?: Usuario_clavesListRelationFilter
  }, "id" | "rfc">

  export type companiaOrderByWithAggregationInput = {
    id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    nombreCorto?: SortOrder
    direccion?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    codigoPostal?: SortOrderInput | SortOrder
    ciudad?: SortOrderInput | SortOrder
    limitePrimerPago?: SortOrderInput | SortOrder
    limitePrimerSubsecuente?: SortOrderInput | SortOrder
    estatus?: SortOrderInput | SortOrder
    colonia?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: companiaCountOrderByAggregateInput
    _avg?: companiaAvgOrderByAggregateInput
    _max?: companiaMaxOrderByAggregateInput
    _min?: companiaMinOrderByAggregateInput
    _sum?: companiaSumOrderByAggregateInput
  }

  export type companiaScalarWhereWithAggregatesInput = {
    AND?: companiaScalarWhereWithAggregatesInput | companiaScalarWhereWithAggregatesInput[]
    OR?: companiaScalarWhereWithAggregatesInput[]
    NOT?: companiaScalarWhereWithAggregatesInput | companiaScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"compania"> | bigint | number
    rfc?: StringWithAggregatesFilter<"compania"> | string
    nombre?: StringWithAggregatesFilter<"compania"> | string
    nombreCorto?: StringWithAggregatesFilter<"compania"> | string
    direccion?: StringNullableWithAggregatesFilter<"compania"> | string | null
    estado?: StringNullableWithAggregatesFilter<"compania"> | string | null
    codigoPostal?: StringNullableWithAggregatesFilter<"compania"> | string | null
    ciudad?: StringNullableWithAggregatesFilter<"compania"> | string | null
    limitePrimerPago?: DecimalNullableWithAggregatesFilter<"compania"> | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: DecimalNullableWithAggregatesFilter<"compania"> | Decimal | DecimalJsLike | number | string | null
    estatus?: BoolNullableWithAggregatesFilter<"compania"> | boolean | null
    colonia?: StringNullableWithAggregatesFilter<"compania"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"compania"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"compania"> | Date | string | null
  }

  export type compania_representantesWhereInput = {
    AND?: compania_representantesWhereInput | compania_representantesWhereInput[]
    OR?: compania_representantesWhereInput[]
    NOT?: compania_representantesWhereInput | compania_representantesWhereInput[]
    id?: BigIntFilter<"compania_representantes"> | bigint | number
    compania_id?: BigIntFilter<"compania_representantes"> | bigint | number
    nombre?: StringFilter<"compania_representantes"> | string
    telefono?: StringFilter<"compania_representantes"> | string
    correo?: StringFilter<"compania_representantes"> | string
    cargo?: StringFilter<"compania_representantes"> | string
    estatus?: BoolNullableFilter<"compania_representantes"> | boolean | null
    created_at?: DateTimeNullableFilter<"compania_representantes"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"compania_representantes"> | Date | string | null
    compania?: XOR<CompaniaScalarRelationFilter, companiaWhereInput>
  }

  export type compania_representantesOrderByWithRelationInput = {
    id?: SortOrder
    compania_id?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    cargo?: SortOrder
    estatus?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    compania?: companiaOrderByWithRelationInput
    _relevance?: compania_representantesOrderByRelevanceInput
  }

  export type compania_representantesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    correo?: string
    AND?: compania_representantesWhereInput | compania_representantesWhereInput[]
    OR?: compania_representantesWhereInput[]
    NOT?: compania_representantesWhereInput | compania_representantesWhereInput[]
    compania_id?: BigIntFilter<"compania_representantes"> | bigint | number
    nombre?: StringFilter<"compania_representantes"> | string
    telefono?: StringFilter<"compania_representantes"> | string
    cargo?: StringFilter<"compania_representantes"> | string
    estatus?: BoolNullableFilter<"compania_representantes"> | boolean | null
    created_at?: DateTimeNullableFilter<"compania_representantes"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"compania_representantes"> | Date | string | null
    compania?: XOR<CompaniaScalarRelationFilter, companiaWhereInput>
  }, "id" | "correo">

  export type compania_representantesOrderByWithAggregationInput = {
    id?: SortOrder
    compania_id?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    cargo?: SortOrder
    estatus?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: compania_representantesCountOrderByAggregateInput
    _avg?: compania_representantesAvgOrderByAggregateInput
    _max?: compania_representantesMaxOrderByAggregateInput
    _min?: compania_representantesMinOrderByAggregateInput
    _sum?: compania_representantesSumOrderByAggregateInput
  }

  export type compania_representantesScalarWhereWithAggregatesInput = {
    AND?: compania_representantesScalarWhereWithAggregatesInput | compania_representantesScalarWhereWithAggregatesInput[]
    OR?: compania_representantesScalarWhereWithAggregatesInput[]
    NOT?: compania_representantesScalarWhereWithAggregatesInput | compania_representantesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"compania_representantes"> | bigint | number
    compania_id?: BigIntWithAggregatesFilter<"compania_representantes"> | bigint | number
    nombre?: StringWithAggregatesFilter<"compania_representantes"> | string
    telefono?: StringWithAggregatesFilter<"compania_representantes"> | string
    correo?: StringWithAggregatesFilter<"compania_representantes"> | string
    cargo?: StringWithAggregatesFilter<"compania_representantes"> | string
    estatus?: BoolNullableWithAggregatesFilter<"compania_representantes"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"compania_representantes"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"compania_representantes"> | Date | string | null
  }

  export type companias_productosWhereInput = {
    AND?: companias_productosWhereInput | companias_productosWhereInput[]
    OR?: companias_productosWhereInput[]
    NOT?: companias_productosWhereInput | companias_productosWhereInput[]
    id?: BigIntFilter<"companias_productos"> | bigint | number
    compania_id?: BigIntFilter<"companias_productos"> | bigint | number
    ramo_id?: BigIntFilter<"companias_productos"> | bigint | number
    nombre?: StringFilter<"companias_productos"> | string
    created_at?: DateTimeNullableFilter<"companias_productos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"companias_productos"> | Date | string | null
    estatus?: BoolNullableFilter<"companias_productos"> | boolean | null
    compania?: XOR<CompaniaScalarRelationFilter, companiaWhereInput>
    ramos?: XOR<RamosScalarRelationFilter, ramosWhereInput>
    polizas?: PolizasListRelationFilter
  }

  export type companias_productosOrderByWithRelationInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
    nombre?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    estatus?: SortOrderInput | SortOrder
    compania?: companiaOrderByWithRelationInput
    ramos?: ramosOrderByWithRelationInput
    polizas?: polizasOrderByRelationAggregateInput
    _relevance?: companias_productosOrderByRelevanceInput
  }

  export type companias_productosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: companias_productosWhereInput | companias_productosWhereInput[]
    OR?: companias_productosWhereInput[]
    NOT?: companias_productosWhereInput | companias_productosWhereInput[]
    compania_id?: BigIntFilter<"companias_productos"> | bigint | number
    ramo_id?: BigIntFilter<"companias_productos"> | bigint | number
    nombre?: StringFilter<"companias_productos"> | string
    created_at?: DateTimeNullableFilter<"companias_productos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"companias_productos"> | Date | string | null
    estatus?: BoolNullableFilter<"companias_productos"> | boolean | null
    compania?: XOR<CompaniaScalarRelationFilter, companiaWhereInput>
    ramos?: XOR<RamosScalarRelationFilter, ramosWhereInput>
    polizas?: PolizasListRelationFilter
  }, "id">

  export type companias_productosOrderByWithAggregationInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
    nombre?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    estatus?: SortOrderInput | SortOrder
    _count?: companias_productosCountOrderByAggregateInput
    _avg?: companias_productosAvgOrderByAggregateInput
    _max?: companias_productosMaxOrderByAggregateInput
    _min?: companias_productosMinOrderByAggregateInput
    _sum?: companias_productosSumOrderByAggregateInput
  }

  export type companias_productosScalarWhereWithAggregatesInput = {
    AND?: companias_productosScalarWhereWithAggregatesInput | companias_productosScalarWhereWithAggregatesInput[]
    OR?: companias_productosScalarWhereWithAggregatesInput[]
    NOT?: companias_productosScalarWhereWithAggregatesInput | companias_productosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"companias_productos"> | bigint | number
    compania_id?: BigIntWithAggregatesFilter<"companias_productos"> | bigint | number
    ramo_id?: BigIntWithAggregatesFilter<"companias_productos"> | bigint | number
    nombre?: StringWithAggregatesFilter<"companias_productos"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"companias_productos"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"companias_productos"> | Date | string | null
    estatus?: BoolNullableWithAggregatesFilter<"companias_productos"> | boolean | null
  }

  export type companias_ramosWhereInput = {
    AND?: companias_ramosWhereInput | companias_ramosWhereInput[]
    OR?: companias_ramosWhereInput[]
    NOT?: companias_ramosWhereInput | companias_ramosWhereInput[]
    id?: BigIntFilter<"companias_ramos"> | bigint | number
    compania_id?: BigIntFilter<"companias_ramos"> | bigint | number
    ramo_id?: BigIntFilter<"companias_ramos"> | bigint | number
    created_at?: DateTimeNullableFilter<"companias_ramos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"companias_ramos"> | Date | string | null
    estatus?: BoolNullableFilter<"companias_ramos"> | boolean | null
    compania?: XOR<CompaniaScalarRelationFilter, companiaWhereInput>
    ramos?: XOR<RamosScalarRelationFilter, ramosWhereInput>
  }

  export type companias_ramosOrderByWithRelationInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    estatus?: SortOrderInput | SortOrder
    compania?: companiaOrderByWithRelationInput
    ramos?: ramosOrderByWithRelationInput
  }

  export type companias_ramosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: companias_ramosWhereInput | companias_ramosWhereInput[]
    OR?: companias_ramosWhereInput[]
    NOT?: companias_ramosWhereInput | companias_ramosWhereInput[]
    compania_id?: BigIntFilter<"companias_ramos"> | bigint | number
    ramo_id?: BigIntFilter<"companias_ramos"> | bigint | number
    created_at?: DateTimeNullableFilter<"companias_ramos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"companias_ramos"> | Date | string | null
    estatus?: BoolNullableFilter<"companias_ramos"> | boolean | null
    compania?: XOR<CompaniaScalarRelationFilter, companiaWhereInput>
    ramos?: XOR<RamosScalarRelationFilter, ramosWhereInput>
  }, "id">

  export type companias_ramosOrderByWithAggregationInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    estatus?: SortOrderInput | SortOrder
    _count?: companias_ramosCountOrderByAggregateInput
    _avg?: companias_ramosAvgOrderByAggregateInput
    _max?: companias_ramosMaxOrderByAggregateInput
    _min?: companias_ramosMinOrderByAggregateInput
    _sum?: companias_ramosSumOrderByAggregateInput
  }

  export type companias_ramosScalarWhereWithAggregatesInput = {
    AND?: companias_ramosScalarWhereWithAggregatesInput | companias_ramosScalarWhereWithAggregatesInput[]
    OR?: companias_ramosScalarWhereWithAggregatesInput[]
    NOT?: companias_ramosScalarWhereWithAggregatesInput | companias_ramosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"companias_ramos"> | bigint | number
    compania_id?: BigIntWithAggregatesFilter<"companias_ramos"> | bigint | number
    ramo_id?: BigIntWithAggregatesFilter<"companias_ramos"> | bigint | number
    created_at?: DateTimeNullableWithAggregatesFilter<"companias_ramos"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"companias_ramos"> | Date | string | null
    estatus?: BoolNullableWithAggregatesFilter<"companias_ramos"> | boolean | null
  }

  export type estadosWhereInput = {
    AND?: estadosWhereInput | estadosWhereInput[]
    OR?: estadosWhereInput[]
    NOT?: estadosWhereInput | estadosWhereInput[]
    id?: BigIntFilter<"estados"> | bigint | number
    label?: StringFilter<"estados"> | string
    estatus?: BoolFilter<"estados"> | boolean
    created_at?: DateTimeNullableFilter<"estados"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"estados"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"estados"> | Date | string | null
  }

  export type estadosOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _relevance?: estadosOrderByRelevanceInput
  }

  export type estadosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: estadosWhereInput | estadosWhereInput[]
    OR?: estadosWhereInput[]
    NOT?: estadosWhereInput | estadosWhereInput[]
    label?: StringFilter<"estados"> | string
    estatus?: BoolFilter<"estados"> | boolean
    created_at?: DateTimeNullableFilter<"estados"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"estados"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"estados"> | Date | string | null
  }, "id">

  export type estadosOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: estadosCountOrderByAggregateInput
    _avg?: estadosAvgOrderByAggregateInput
    _max?: estadosMaxOrderByAggregateInput
    _min?: estadosMinOrderByAggregateInput
    _sum?: estadosSumOrderByAggregateInput
  }

  export type estadosScalarWhereWithAggregatesInput = {
    AND?: estadosScalarWhereWithAggregatesInput | estadosScalarWhereWithAggregatesInput[]
    OR?: estadosScalarWhereWithAggregatesInput[]
    NOT?: estadosScalarWhereWithAggregatesInput | estadosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"estados"> | bigint | number
    label?: StringWithAggregatesFilter<"estados"> | string
    estatus?: BoolWithAggregatesFilter<"estados"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"estados"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"estados"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"estados"> | Date | string | null
  }

  export type estatus_clienteWhereInput = {
    AND?: estatus_clienteWhereInput | estatus_clienteWhereInput[]
    OR?: estatus_clienteWhereInput[]
    NOT?: estatus_clienteWhereInput | estatus_clienteWhereInput[]
    id?: BigIntFilter<"estatus_cliente"> | bigint | number
    label?: StringFilter<"estatus_cliente"> | string
    estatus?: BoolFilter<"estatus_cliente"> | boolean
    created_at?: DateTimeNullableFilter<"estatus_cliente"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"estatus_cliente"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"estatus_cliente"> | Date | string | null
  }

  export type estatus_clienteOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _relevance?: estatus_clienteOrderByRelevanceInput
  }

  export type estatus_clienteWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: estatus_clienteWhereInput | estatus_clienteWhereInput[]
    OR?: estatus_clienteWhereInput[]
    NOT?: estatus_clienteWhereInput | estatus_clienteWhereInput[]
    label?: StringFilter<"estatus_cliente"> | string
    estatus?: BoolFilter<"estatus_cliente"> | boolean
    created_at?: DateTimeNullableFilter<"estatus_cliente"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"estatus_cliente"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"estatus_cliente"> | Date | string | null
  }, "id">

  export type estatus_clienteOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: estatus_clienteCountOrderByAggregateInput
    _avg?: estatus_clienteAvgOrderByAggregateInput
    _max?: estatus_clienteMaxOrderByAggregateInput
    _min?: estatus_clienteMinOrderByAggregateInput
    _sum?: estatus_clienteSumOrderByAggregateInput
  }

  export type estatus_clienteScalarWhereWithAggregatesInput = {
    AND?: estatus_clienteScalarWhereWithAggregatesInput | estatus_clienteScalarWhereWithAggregatesInput[]
    OR?: estatus_clienteScalarWhereWithAggregatesInput[]
    NOT?: estatus_clienteScalarWhereWithAggregatesInput | estatus_clienteScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"estatus_cliente"> | bigint | number
    label?: StringWithAggregatesFilter<"estatus_cliente"> | string
    estatus?: BoolWithAggregatesFilter<"estatus_cliente"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"estatus_cliente"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"estatus_cliente"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"estatus_cliente"> | Date | string | null
  }

  export type estatus_polizasWhereInput = {
    AND?: estatus_polizasWhereInput | estatus_polizasWhereInput[]
    OR?: estatus_polizasWhereInput[]
    NOT?: estatus_polizasWhereInput | estatus_polizasWhereInput[]
    id?: BigIntFilter<"estatus_polizas"> | bigint | number
    label?: StringFilter<"estatus_polizas"> | string
    estatus?: BoolFilter<"estatus_polizas"> | boolean
    created_at?: DateTimeNullableFilter<"estatus_polizas"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"estatus_polizas"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"estatus_polizas"> | Date | string | null
  }

  export type estatus_polizasOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _relevance?: estatus_polizasOrderByRelevanceInput
  }

  export type estatus_polizasWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: estatus_polizasWhereInput | estatus_polizasWhereInput[]
    OR?: estatus_polizasWhereInput[]
    NOT?: estatus_polizasWhereInput | estatus_polizasWhereInput[]
    label?: StringFilter<"estatus_polizas"> | string
    estatus?: BoolFilter<"estatus_polizas"> | boolean
    created_at?: DateTimeNullableFilter<"estatus_polizas"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"estatus_polizas"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"estatus_polizas"> | Date | string | null
  }, "id">

  export type estatus_polizasOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: estatus_polizasCountOrderByAggregateInput
    _avg?: estatus_polizasAvgOrderByAggregateInput
    _max?: estatus_polizasMaxOrderByAggregateInput
    _min?: estatus_polizasMinOrderByAggregateInput
    _sum?: estatus_polizasSumOrderByAggregateInput
  }

  export type estatus_polizasScalarWhereWithAggregatesInput = {
    AND?: estatus_polizasScalarWhereWithAggregatesInput | estatus_polizasScalarWhereWithAggregatesInput[]
    OR?: estatus_polizasScalarWhereWithAggregatesInput[]
    NOT?: estatus_polizasScalarWhereWithAggregatesInput | estatus_polizasScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"estatus_polizas"> | bigint | number
    label?: StringWithAggregatesFilter<"estatus_polizas"> | string
    estatus?: BoolWithAggregatesFilter<"estatus_polizas"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"estatus_polizas"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"estatus_polizas"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"estatus_polizas"> | Date | string | null
  }

  export type failed_jobsWhereInput = {
    AND?: failed_jobsWhereInput | failed_jobsWhereInput[]
    OR?: failed_jobsWhereInput[]
    NOT?: failed_jobsWhereInput | failed_jobsWhereInput[]
    id?: BigIntFilter<"failed_jobs"> | bigint | number
    uuid?: StringFilter<"failed_jobs"> | string
    connection?: StringFilter<"failed_jobs"> | string
    queue?: StringFilter<"failed_jobs"> | string
    payload?: StringFilter<"failed_jobs"> | string
    exception?: StringFilter<"failed_jobs"> | string
    failed_at?: DateTimeFilter<"failed_jobs"> | Date | string
  }

  export type failed_jobsOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failed_at?: SortOrder
    _relevance?: failed_jobsOrderByRelevanceInput
  }

  export type failed_jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    uuid?: string
    AND?: failed_jobsWhereInput | failed_jobsWhereInput[]
    OR?: failed_jobsWhereInput[]
    NOT?: failed_jobsWhereInput | failed_jobsWhereInput[]
    connection?: StringFilter<"failed_jobs"> | string
    queue?: StringFilter<"failed_jobs"> | string
    payload?: StringFilter<"failed_jobs"> | string
    exception?: StringFilter<"failed_jobs"> | string
    failed_at?: DateTimeFilter<"failed_jobs"> | Date | string
  }, "id" | "uuid">

  export type failed_jobsOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failed_at?: SortOrder
    _count?: failed_jobsCountOrderByAggregateInput
    _avg?: failed_jobsAvgOrderByAggregateInput
    _max?: failed_jobsMaxOrderByAggregateInput
    _min?: failed_jobsMinOrderByAggregateInput
    _sum?: failed_jobsSumOrderByAggregateInput
  }

  export type failed_jobsScalarWhereWithAggregatesInput = {
    AND?: failed_jobsScalarWhereWithAggregatesInput | failed_jobsScalarWhereWithAggregatesInput[]
    OR?: failed_jobsScalarWhereWithAggregatesInput[]
    NOT?: failed_jobsScalarWhereWithAggregatesInput | failed_jobsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"failed_jobs"> | bigint | number
    uuid?: StringWithAggregatesFilter<"failed_jobs"> | string
    connection?: StringWithAggregatesFilter<"failed_jobs"> | string
    queue?: StringWithAggregatesFilter<"failed_jobs"> | string
    payload?: StringWithAggregatesFilter<"failed_jobs"> | string
    exception?: StringWithAggregatesFilter<"failed_jobs"> | string
    failed_at?: DateTimeWithAggregatesFilter<"failed_jobs"> | Date | string
  }

  export type formas_de_pagoWhereInput = {
    AND?: formas_de_pagoWhereInput | formas_de_pagoWhereInput[]
    OR?: formas_de_pagoWhereInput[]
    NOT?: formas_de_pagoWhereInput | formas_de_pagoWhereInput[]
    id?: BigIntFilter<"formas_de_pago"> | bigint | number
    label?: StringFilter<"formas_de_pago"> | string
    estatus?: BoolFilter<"formas_de_pago"> | boolean
    created_at?: DateTimeNullableFilter<"formas_de_pago"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"formas_de_pago"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"formas_de_pago"> | Date | string | null
    polizas?: PolizasListRelationFilter
  }

  export type formas_de_pagoOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    polizas?: polizasOrderByRelationAggregateInput
    _relevance?: formas_de_pagoOrderByRelevanceInput
  }

  export type formas_de_pagoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: formas_de_pagoWhereInput | formas_de_pagoWhereInput[]
    OR?: formas_de_pagoWhereInput[]
    NOT?: formas_de_pagoWhereInput | formas_de_pagoWhereInput[]
    label?: StringFilter<"formas_de_pago"> | string
    estatus?: BoolFilter<"formas_de_pago"> | boolean
    created_at?: DateTimeNullableFilter<"formas_de_pago"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"formas_de_pago"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"formas_de_pago"> | Date | string | null
    polizas?: PolizasListRelationFilter
  }, "id">

  export type formas_de_pagoOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: formas_de_pagoCountOrderByAggregateInput
    _avg?: formas_de_pagoAvgOrderByAggregateInput
    _max?: formas_de_pagoMaxOrderByAggregateInput
    _min?: formas_de_pagoMinOrderByAggregateInput
    _sum?: formas_de_pagoSumOrderByAggregateInput
  }

  export type formas_de_pagoScalarWhereWithAggregatesInput = {
    AND?: formas_de_pagoScalarWhereWithAggregatesInput | formas_de_pagoScalarWhereWithAggregatesInput[]
    OR?: formas_de_pagoScalarWhereWithAggregatesInput[]
    NOT?: formas_de_pagoScalarWhereWithAggregatesInput | formas_de_pagoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"formas_de_pago"> | bigint | number
    label?: StringWithAggregatesFilter<"formas_de_pago"> | string
    estatus?: BoolWithAggregatesFilter<"formas_de_pago"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"formas_de_pago"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"formas_de_pago"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"formas_de_pago"> | Date | string | null
  }

  export type job_batchesWhereInput = {
    AND?: job_batchesWhereInput | job_batchesWhereInput[]
    OR?: job_batchesWhereInput[]
    NOT?: job_batchesWhereInput | job_batchesWhereInput[]
    id?: StringFilter<"job_batches"> | string
    name?: StringFilter<"job_batches"> | string
    total_jobs?: IntFilter<"job_batches"> | number
    pending_jobs?: IntFilter<"job_batches"> | number
    failed_jobs?: IntFilter<"job_batches"> | number
    failed_job_ids?: StringFilter<"job_batches"> | string
    options?: StringNullableFilter<"job_batches"> | string | null
    cancelled_at?: IntNullableFilter<"job_batches"> | number | null
    created_at?: IntFilter<"job_batches"> | number
    finished_at?: IntNullableFilter<"job_batches"> | number | null
  }

  export type job_batchesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    failed_job_ids?: SortOrder
    options?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    finished_at?: SortOrderInput | SortOrder
    _relevance?: job_batchesOrderByRelevanceInput
  }

  export type job_batchesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: job_batchesWhereInput | job_batchesWhereInput[]
    OR?: job_batchesWhereInput[]
    NOT?: job_batchesWhereInput | job_batchesWhereInput[]
    name?: StringFilter<"job_batches"> | string
    total_jobs?: IntFilter<"job_batches"> | number
    pending_jobs?: IntFilter<"job_batches"> | number
    failed_jobs?: IntFilter<"job_batches"> | number
    failed_job_ids?: StringFilter<"job_batches"> | string
    options?: StringNullableFilter<"job_batches"> | string | null
    cancelled_at?: IntNullableFilter<"job_batches"> | number | null
    created_at?: IntFilter<"job_batches"> | number
    finished_at?: IntNullableFilter<"job_batches"> | number | null
  }, "id">

  export type job_batchesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    failed_job_ids?: SortOrder
    options?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    finished_at?: SortOrderInput | SortOrder
    _count?: job_batchesCountOrderByAggregateInput
    _avg?: job_batchesAvgOrderByAggregateInput
    _max?: job_batchesMaxOrderByAggregateInput
    _min?: job_batchesMinOrderByAggregateInput
    _sum?: job_batchesSumOrderByAggregateInput
  }

  export type job_batchesScalarWhereWithAggregatesInput = {
    AND?: job_batchesScalarWhereWithAggregatesInput | job_batchesScalarWhereWithAggregatesInput[]
    OR?: job_batchesScalarWhereWithAggregatesInput[]
    NOT?: job_batchesScalarWhereWithAggregatesInput | job_batchesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"job_batches"> | string
    name?: StringWithAggregatesFilter<"job_batches"> | string
    total_jobs?: IntWithAggregatesFilter<"job_batches"> | number
    pending_jobs?: IntWithAggregatesFilter<"job_batches"> | number
    failed_jobs?: IntWithAggregatesFilter<"job_batches"> | number
    failed_job_ids?: StringWithAggregatesFilter<"job_batches"> | string
    options?: StringNullableWithAggregatesFilter<"job_batches"> | string | null
    cancelled_at?: IntNullableWithAggregatesFilter<"job_batches"> | number | null
    created_at?: IntWithAggregatesFilter<"job_batches"> | number
    finished_at?: IntNullableWithAggregatesFilter<"job_batches"> | number | null
  }

  export type jobsWhereInput = {
    AND?: jobsWhereInput | jobsWhereInput[]
    OR?: jobsWhereInput[]
    NOT?: jobsWhereInput | jobsWhereInput[]
    id?: BigIntFilter<"jobs"> | bigint | number
    queue?: StringFilter<"jobs"> | string
    payload?: StringFilter<"jobs"> | string
    attempts?: IntFilter<"jobs"> | number
    reserved_at?: IntNullableFilter<"jobs"> | number | null
    available_at?: IntFilter<"jobs"> | number
    created_at?: IntFilter<"jobs"> | number
  }

  export type jobsOrderByWithRelationInput = {
    id?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrderInput | SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
    _relevance?: jobsOrderByRelevanceInput
  }

  export type jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: jobsWhereInput | jobsWhereInput[]
    OR?: jobsWhereInput[]
    NOT?: jobsWhereInput | jobsWhereInput[]
    queue?: StringFilter<"jobs"> | string
    payload?: StringFilter<"jobs"> | string
    attempts?: IntFilter<"jobs"> | number
    reserved_at?: IntNullableFilter<"jobs"> | number | null
    available_at?: IntFilter<"jobs"> | number
    created_at?: IntFilter<"jobs"> | number
  }, "id">

  export type jobsOrderByWithAggregationInput = {
    id?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrderInput | SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
    _count?: jobsCountOrderByAggregateInput
    _avg?: jobsAvgOrderByAggregateInput
    _max?: jobsMaxOrderByAggregateInput
    _min?: jobsMinOrderByAggregateInput
    _sum?: jobsSumOrderByAggregateInput
  }

  export type jobsScalarWhereWithAggregatesInput = {
    AND?: jobsScalarWhereWithAggregatesInput | jobsScalarWhereWithAggregatesInput[]
    OR?: jobsScalarWhereWithAggregatesInput[]
    NOT?: jobsScalarWhereWithAggregatesInput | jobsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"jobs"> | bigint | number
    queue?: StringWithAggregatesFilter<"jobs"> | string
    payload?: StringWithAggregatesFilter<"jobs"> | string
    attempts?: IntWithAggregatesFilter<"jobs"> | number
    reserved_at?: IntNullableWithAggregatesFilter<"jobs"> | number | null
    available_at?: IntWithAggregatesFilter<"jobs"> | number
    created_at?: IntWithAggregatesFilter<"jobs"> | number
  }

  export type metodos_de_pagoWhereInput = {
    AND?: metodos_de_pagoWhereInput | metodos_de_pagoWhereInput[]
    OR?: metodos_de_pagoWhereInput[]
    NOT?: metodos_de_pagoWhereInput | metodos_de_pagoWhereInput[]
    id?: BigIntFilter<"metodos_de_pago"> | bigint | number
    label?: StringFilter<"metodos_de_pago"> | string
    estatus?: BoolFilter<"metodos_de_pago"> | boolean
    created_at?: DateTimeNullableFilter<"metodos_de_pago"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"metodos_de_pago"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"metodos_de_pago"> | Date | string | null
    polizas?: PolizasListRelationFilter
  }

  export type metodos_de_pagoOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    polizas?: polizasOrderByRelationAggregateInput
    _relevance?: metodos_de_pagoOrderByRelevanceInput
  }

  export type metodos_de_pagoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: metodos_de_pagoWhereInput | metodos_de_pagoWhereInput[]
    OR?: metodos_de_pagoWhereInput[]
    NOT?: metodos_de_pagoWhereInput | metodos_de_pagoWhereInput[]
    label?: StringFilter<"metodos_de_pago"> | string
    estatus?: BoolFilter<"metodos_de_pago"> | boolean
    created_at?: DateTimeNullableFilter<"metodos_de_pago"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"metodos_de_pago"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"metodos_de_pago"> | Date | string | null
    polizas?: PolizasListRelationFilter
  }, "id">

  export type metodos_de_pagoOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: metodos_de_pagoCountOrderByAggregateInput
    _avg?: metodos_de_pagoAvgOrderByAggregateInput
    _max?: metodos_de_pagoMaxOrderByAggregateInput
    _min?: metodos_de_pagoMinOrderByAggregateInput
    _sum?: metodos_de_pagoSumOrderByAggregateInput
  }

  export type metodos_de_pagoScalarWhereWithAggregatesInput = {
    AND?: metodos_de_pagoScalarWhereWithAggregatesInput | metodos_de_pagoScalarWhereWithAggregatesInput[]
    OR?: metodos_de_pagoScalarWhereWithAggregatesInput[]
    NOT?: metodos_de_pagoScalarWhereWithAggregatesInput | metodos_de_pagoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"metodos_de_pago"> | bigint | number
    label?: StringWithAggregatesFilter<"metodos_de_pago"> | string
    estatus?: BoolWithAggregatesFilter<"metodos_de_pago"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"metodos_de_pago"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"metodos_de_pago"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"metodos_de_pago"> | Date | string | null
  }

  export type migrationsWhereInput = {
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    id?: IntFilter<"migrations"> | number
    migration?: StringFilter<"migrations"> | string
    batch?: IntFilter<"migrations"> | number
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
    _relevance?: migrationsOrderByRelevanceInput
  }

  export type migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    migration?: StringFilter<"migrations"> | string
    batch?: IntFilter<"migrations"> | number
  }, "id">

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    OR?: migrationsScalarWhereWithAggregatesInput[]
    NOT?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migrations"> | number
    migration?: StringWithAggregatesFilter<"migrations"> | string
    batch?: IntWithAggregatesFilter<"migrations"> | number
  }

  export type monedasWhereInput = {
    AND?: monedasWhereInput | monedasWhereInput[]
    OR?: monedasWhereInput[]
    NOT?: monedasWhereInput | monedasWhereInput[]
    id?: BigIntFilter<"monedas"> | bigint | number
    label?: StringFilter<"monedas"> | string
    estatus?: BoolFilter<"monedas"> | boolean
    created_at?: DateTimeNullableFilter<"monedas"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"monedas"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"monedas"> | Date | string | null
    polizas?: PolizasListRelationFilter
  }

  export type monedasOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    polizas?: polizasOrderByRelationAggregateInput
    _relevance?: monedasOrderByRelevanceInput
  }

  export type monedasWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: monedasWhereInput | monedasWhereInput[]
    OR?: monedasWhereInput[]
    NOT?: monedasWhereInput | monedasWhereInput[]
    label?: StringFilter<"monedas"> | string
    estatus?: BoolFilter<"monedas"> | boolean
    created_at?: DateTimeNullableFilter<"monedas"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"monedas"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"monedas"> | Date | string | null
    polizas?: PolizasListRelationFilter
  }, "id">

  export type monedasOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: monedasCountOrderByAggregateInput
    _avg?: monedasAvgOrderByAggregateInput
    _max?: monedasMaxOrderByAggregateInput
    _min?: monedasMinOrderByAggregateInput
    _sum?: monedasSumOrderByAggregateInput
  }

  export type monedasScalarWhereWithAggregatesInput = {
    AND?: monedasScalarWhereWithAggregatesInput | monedasScalarWhereWithAggregatesInput[]
    OR?: monedasScalarWhereWithAggregatesInput[]
    NOT?: monedasScalarWhereWithAggregatesInput | monedasScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"monedas"> | bigint | number
    label?: StringWithAggregatesFilter<"monedas"> | string
    estatus?: BoolWithAggregatesFilter<"monedas"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"monedas"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"monedas"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"monedas"> | Date | string | null
  }

  export type password_reset_tokensWhereInput = {
    AND?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    OR?: password_reset_tokensWhereInput[]
    NOT?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    email?: StringFilter<"password_reset_tokens"> | string
    token?: StringFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableFilter<"password_reset_tokens"> | Date | string | null
  }

  export type password_reset_tokensOrderByWithRelationInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _relevance?: password_reset_tokensOrderByRelevanceInput
  }

  export type password_reset_tokensWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    AND?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    OR?: password_reset_tokensWhereInput[]
    NOT?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    token?: StringFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableFilter<"password_reset_tokens"> | Date | string | null
  }, "email">

  export type password_reset_tokensOrderByWithAggregationInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: password_reset_tokensCountOrderByAggregateInput
    _max?: password_reset_tokensMaxOrderByAggregateInput
    _min?: password_reset_tokensMinOrderByAggregateInput
  }

  export type password_reset_tokensScalarWhereWithAggregatesInput = {
    AND?: password_reset_tokensScalarWhereWithAggregatesInput | password_reset_tokensScalarWhereWithAggregatesInput[]
    OR?: password_reset_tokensScalarWhereWithAggregatesInput[]
    NOT?: password_reset_tokensScalarWhereWithAggregatesInput | password_reset_tokensScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"password_reset_tokens"> | string
    token?: StringWithAggregatesFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"password_reset_tokens"> | Date | string | null
  }

  export type personal_access_tokensWhereInput = {
    AND?: personal_access_tokensWhereInput | personal_access_tokensWhereInput[]
    OR?: personal_access_tokensWhereInput[]
    NOT?: personal_access_tokensWhereInput | personal_access_tokensWhereInput[]
    id?: BigIntFilter<"personal_access_tokens"> | bigint | number
    tokenable_type?: StringFilter<"personal_access_tokens"> | string
    tokenable_id?: BigIntFilter<"personal_access_tokens"> | bigint | number
    name?: StringFilter<"personal_access_tokens"> | string
    token?: StringFilter<"personal_access_tokens"> | string
    abilities?: StringNullableFilter<"personal_access_tokens"> | string | null
    last_used_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    created_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
  }

  export type personal_access_tokensOrderByWithRelationInput = {
    id?: SortOrder
    tokenable_type?: SortOrder
    tokenable_id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrderInput | SortOrder
    last_used_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: personal_access_tokensOrderByRelevanceInput
  }

  export type personal_access_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    token?: string
    AND?: personal_access_tokensWhereInput | personal_access_tokensWhereInput[]
    OR?: personal_access_tokensWhereInput[]
    NOT?: personal_access_tokensWhereInput | personal_access_tokensWhereInput[]
    tokenable_type?: StringFilter<"personal_access_tokens"> | string
    tokenable_id?: BigIntFilter<"personal_access_tokens"> | bigint | number
    name?: StringFilter<"personal_access_tokens"> | string
    abilities?: StringNullableFilter<"personal_access_tokens"> | string | null
    last_used_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    created_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"personal_access_tokens"> | Date | string | null
  }, "id" | "token">

  export type personal_access_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    tokenable_type?: SortOrder
    tokenable_id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrderInput | SortOrder
    last_used_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: personal_access_tokensCountOrderByAggregateInput
    _avg?: personal_access_tokensAvgOrderByAggregateInput
    _max?: personal_access_tokensMaxOrderByAggregateInput
    _min?: personal_access_tokensMinOrderByAggregateInput
    _sum?: personal_access_tokensSumOrderByAggregateInput
  }

  export type personal_access_tokensScalarWhereWithAggregatesInput = {
    AND?: personal_access_tokensScalarWhereWithAggregatesInput | personal_access_tokensScalarWhereWithAggregatesInput[]
    OR?: personal_access_tokensScalarWhereWithAggregatesInput[]
    NOT?: personal_access_tokensScalarWhereWithAggregatesInput | personal_access_tokensScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"personal_access_tokens"> | bigint | number
    tokenable_type?: StringWithAggregatesFilter<"personal_access_tokens"> | string
    tokenable_id?: BigIntWithAggregatesFilter<"personal_access_tokens"> | bigint | number
    name?: StringWithAggregatesFilter<"personal_access_tokens"> | string
    token?: StringWithAggregatesFilter<"personal_access_tokens"> | string
    abilities?: StringNullableWithAggregatesFilter<"personal_access_tokens"> | string | null
    last_used_at?: DateTimeNullableWithAggregatesFilter<"personal_access_tokens"> | Date | string | null
    expires_at?: DateTimeNullableWithAggregatesFilter<"personal_access_tokens"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"personal_access_tokens"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"personal_access_tokens"> | Date | string | null
  }

  export type poliza_aseguradosWhereInput = {
    AND?: poliza_aseguradosWhereInput | poliza_aseguradosWhereInput[]
    OR?: poliza_aseguradosWhereInput[]
    NOT?: poliza_aseguradosWhereInput | poliza_aseguradosWhereInput[]
    id?: BigIntFilter<"poliza_asegurados"> | bigint | number
    poliza_id?: BigIntFilter<"poliza_asegurados"> | bigint | number
    cliente_id?: BigIntNullableFilter<"poliza_asegurados"> | bigint | number | null
    rfc?: StringFilter<"poliza_asegurados"> | string
    nombre?: StringFilter<"poliza_asegurados"> | string
    fechaNacimiento?: DateTimeFilter<"poliza_asegurados"> | Date | string
    direccion?: StringFilter<"poliza_asegurados"> | string
    colonia?: StringFilter<"poliza_asegurados"> | string
    codigoPostal?: StringFilter<"poliza_asegurados"> | string
    estado_id?: BigIntFilter<"poliza_asegurados"> | bigint | number
    ciudad?: StringFilter<"poliza_asegurados"> | string
    correo?: StringNullableFilter<"poliza_asegurados"> | string | null
    telefono?: StringNullableFilter<"poliza_asegurados"> | string | null
    celular?: StringNullableFilter<"poliza_asegurados"> | string | null
    oficina?: StringNullableFilter<"poliza_asegurados"> | string | null
    casa?: StringNullableFilter<"poliza_asegurados"> | string | null
    observaciones?: StringNullableFilter<"poliza_asegurados"> | string | null
    created_at?: DateTimeNullableFilter<"poliza_asegurados"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"poliza_asegurados"> | Date | string | null
  }

  export type poliza_aseguradosOrderByWithRelationInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    cliente_id?: SortOrderInput | SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    colonia?: SortOrder
    codigoPostal?: SortOrder
    estado_id?: SortOrder
    ciudad?: SortOrder
    correo?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    oficina?: SortOrderInput | SortOrder
    casa?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: poliza_aseguradosOrderByRelevanceInput
  }

  export type poliza_aseguradosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    rfc?: string
    AND?: poliza_aseguradosWhereInput | poliza_aseguradosWhereInput[]
    OR?: poliza_aseguradosWhereInput[]
    NOT?: poliza_aseguradosWhereInput | poliza_aseguradosWhereInput[]
    poliza_id?: BigIntFilter<"poliza_asegurados"> | bigint | number
    cliente_id?: BigIntNullableFilter<"poliza_asegurados"> | bigint | number | null
    nombre?: StringFilter<"poliza_asegurados"> | string
    fechaNacimiento?: DateTimeFilter<"poliza_asegurados"> | Date | string
    direccion?: StringFilter<"poliza_asegurados"> | string
    colonia?: StringFilter<"poliza_asegurados"> | string
    codigoPostal?: StringFilter<"poliza_asegurados"> | string
    estado_id?: BigIntFilter<"poliza_asegurados"> | bigint | number
    ciudad?: StringFilter<"poliza_asegurados"> | string
    correo?: StringNullableFilter<"poliza_asegurados"> | string | null
    telefono?: StringNullableFilter<"poliza_asegurados"> | string | null
    celular?: StringNullableFilter<"poliza_asegurados"> | string | null
    oficina?: StringNullableFilter<"poliza_asegurados"> | string | null
    casa?: StringNullableFilter<"poliza_asegurados"> | string | null
    observaciones?: StringNullableFilter<"poliza_asegurados"> | string | null
    created_at?: DateTimeNullableFilter<"poliza_asegurados"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"poliza_asegurados"> | Date | string | null
  }, "id" | "rfc">

  export type poliza_aseguradosOrderByWithAggregationInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    cliente_id?: SortOrderInput | SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    colonia?: SortOrder
    codigoPostal?: SortOrder
    estado_id?: SortOrder
    ciudad?: SortOrder
    correo?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    oficina?: SortOrderInput | SortOrder
    casa?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: poliza_aseguradosCountOrderByAggregateInput
    _avg?: poliza_aseguradosAvgOrderByAggregateInput
    _max?: poliza_aseguradosMaxOrderByAggregateInput
    _min?: poliza_aseguradosMinOrderByAggregateInput
    _sum?: poliza_aseguradosSumOrderByAggregateInput
  }

  export type poliza_aseguradosScalarWhereWithAggregatesInput = {
    AND?: poliza_aseguradosScalarWhereWithAggregatesInput | poliza_aseguradosScalarWhereWithAggregatesInput[]
    OR?: poliza_aseguradosScalarWhereWithAggregatesInput[]
    NOT?: poliza_aseguradosScalarWhereWithAggregatesInput | poliza_aseguradosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"poliza_asegurados"> | bigint | number
    poliza_id?: BigIntWithAggregatesFilter<"poliza_asegurados"> | bigint | number
    cliente_id?: BigIntNullableWithAggregatesFilter<"poliza_asegurados"> | bigint | number | null
    rfc?: StringWithAggregatesFilter<"poliza_asegurados"> | string
    nombre?: StringWithAggregatesFilter<"poliza_asegurados"> | string
    fechaNacimiento?: DateTimeWithAggregatesFilter<"poliza_asegurados"> | Date | string
    direccion?: StringWithAggregatesFilter<"poliza_asegurados"> | string
    colonia?: StringWithAggregatesFilter<"poliza_asegurados"> | string
    codigoPostal?: StringWithAggregatesFilter<"poliza_asegurados"> | string
    estado_id?: BigIntWithAggregatesFilter<"poliza_asegurados"> | bigint | number
    ciudad?: StringWithAggregatesFilter<"poliza_asegurados"> | string
    correo?: StringNullableWithAggregatesFilter<"poliza_asegurados"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"poliza_asegurados"> | string | null
    celular?: StringNullableWithAggregatesFilter<"poliza_asegurados"> | string | null
    oficina?: StringNullableWithAggregatesFilter<"poliza_asegurados"> | string | null
    casa?: StringNullableWithAggregatesFilter<"poliza_asegurados"> | string | null
    observaciones?: StringNullableWithAggregatesFilter<"poliza_asegurados"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"poliza_asegurados"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"poliza_asegurados"> | Date | string | null
  }

  export type poliza_historialWhereInput = {
    AND?: poliza_historialWhereInput | poliza_historialWhereInput[]
    OR?: poliza_historialWhereInput[]
    NOT?: poliza_historialWhereInput | poliza_historialWhereInput[]
    id?: BigIntFilter<"poliza_historial"> | bigint | number
    poliza_id?: BigIntNullableFilter<"poliza_historial"> | bigint | number | null
    accion?: StringFilter<"poliza_historial"> | string
    created_at?: DateTimeNullableFilter<"poliza_historial"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"poliza_historial"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"poliza_historial"> | Date | string | null
  }

  export type poliza_historialOrderByWithRelationInput = {
    id?: SortOrder
    poliza_id?: SortOrderInput | SortOrder
    accion?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _relevance?: poliza_historialOrderByRelevanceInput
  }

  export type poliza_historialWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: poliza_historialWhereInput | poliza_historialWhereInput[]
    OR?: poliza_historialWhereInput[]
    NOT?: poliza_historialWhereInput | poliza_historialWhereInput[]
    poliza_id?: BigIntNullableFilter<"poliza_historial"> | bigint | number | null
    accion?: StringFilter<"poliza_historial"> | string
    created_at?: DateTimeNullableFilter<"poliza_historial"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"poliza_historial"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"poliza_historial"> | Date | string | null
  }, "id">

  export type poliza_historialOrderByWithAggregationInput = {
    id?: SortOrder
    poliza_id?: SortOrderInput | SortOrder
    accion?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: poliza_historialCountOrderByAggregateInput
    _avg?: poliza_historialAvgOrderByAggregateInput
    _max?: poliza_historialMaxOrderByAggregateInput
    _min?: poliza_historialMinOrderByAggregateInput
    _sum?: poliza_historialSumOrderByAggregateInput
  }

  export type poliza_historialScalarWhereWithAggregatesInput = {
    AND?: poliza_historialScalarWhereWithAggregatesInput | poliza_historialScalarWhereWithAggregatesInput[]
    OR?: poliza_historialScalarWhereWithAggregatesInput[]
    NOT?: poliza_historialScalarWhereWithAggregatesInput | poliza_historialScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"poliza_historial"> | bigint | number
    poliza_id?: BigIntNullableWithAggregatesFilter<"poliza_historial"> | bigint | number | null
    accion?: StringWithAggregatesFilter<"poliza_historial"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"poliza_historial"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"poliza_historial"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"poliza_historial"> | Date | string | null
  }

  export type poliza_recibosWhereInput = {
    AND?: poliza_recibosWhereInput | poliza_recibosWhereInput[]
    OR?: poliza_recibosWhereInput[]
    NOT?: poliza_recibosWhereInput | poliza_recibosWhereInput[]
    id?: BigIntFilter<"poliza_recibos"> | bigint | number
    poliza_id?: BigIntFilter<"poliza_recibos"> | bigint | number
    numeroRecibo?: StringFilter<"poliza_recibos"> | string
    vencimiento?: DateTimeFilter<"poliza_recibos"> | Date | string
    importe?: DecimalFilter<"poliza_recibos"> | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusFilter<"poliza_recibos"> | $Enums.poliza_recibos_estatus
    fechaPago?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    fechaCancelado?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    evidencia?: StringNullableFilter<"poliza_recibos"> | string | null
    created_at?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    polizas?: XOR<PolizasScalarRelationFilter, polizasWhereInput>
  }

  export type poliza_recibosOrderByWithRelationInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    numeroRecibo?: SortOrder
    vencimiento?: SortOrder
    importe?: SortOrder
    estatus?: SortOrder
    fechaPago?: SortOrderInput | SortOrder
    fechaCancelado?: SortOrderInput | SortOrder
    evidencia?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    polizas?: polizasOrderByWithRelationInput
    _relevance?: poliza_recibosOrderByRelevanceInput
  }

  export type poliza_recibosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    numeroRecibo?: string
    AND?: poliza_recibosWhereInput | poliza_recibosWhereInput[]
    OR?: poliza_recibosWhereInput[]
    NOT?: poliza_recibosWhereInput | poliza_recibosWhereInput[]
    poliza_id?: BigIntFilter<"poliza_recibos"> | bigint | number
    vencimiento?: DateTimeFilter<"poliza_recibos"> | Date | string
    importe?: DecimalFilter<"poliza_recibos"> | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusFilter<"poliza_recibos"> | $Enums.poliza_recibos_estatus
    fechaPago?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    fechaCancelado?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    evidencia?: StringNullableFilter<"poliza_recibos"> | string | null
    created_at?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    polizas?: XOR<PolizasScalarRelationFilter, polizasWhereInput>
  }, "id" | "numeroRecibo">

  export type poliza_recibosOrderByWithAggregationInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    numeroRecibo?: SortOrder
    vencimiento?: SortOrder
    importe?: SortOrder
    estatus?: SortOrder
    fechaPago?: SortOrderInput | SortOrder
    fechaCancelado?: SortOrderInput | SortOrder
    evidencia?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: poliza_recibosCountOrderByAggregateInput
    _avg?: poliza_recibosAvgOrderByAggregateInput
    _max?: poliza_recibosMaxOrderByAggregateInput
    _min?: poliza_recibosMinOrderByAggregateInput
    _sum?: poliza_recibosSumOrderByAggregateInput
  }

  export type poliza_recibosScalarWhereWithAggregatesInput = {
    AND?: poliza_recibosScalarWhereWithAggregatesInput | poliza_recibosScalarWhereWithAggregatesInput[]
    OR?: poliza_recibosScalarWhereWithAggregatesInput[]
    NOT?: poliza_recibosScalarWhereWithAggregatesInput | poliza_recibosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"poliza_recibos"> | bigint | number
    poliza_id?: BigIntWithAggregatesFilter<"poliza_recibos"> | bigint | number
    numeroRecibo?: StringWithAggregatesFilter<"poliza_recibos"> | string
    vencimiento?: DateTimeWithAggregatesFilter<"poliza_recibos"> | Date | string
    importe?: DecimalWithAggregatesFilter<"poliza_recibos"> | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusWithAggregatesFilter<"poliza_recibos"> | $Enums.poliza_recibos_estatus
    fechaPago?: DateTimeNullableWithAggregatesFilter<"poliza_recibos"> | Date | string | null
    fechaCancelado?: DateTimeNullableWithAggregatesFilter<"poliza_recibos"> | Date | string | null
    evidencia?: StringNullableWithAggregatesFilter<"poliza_recibos"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"poliza_recibos"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"poliza_recibos"> | Date | string | null
  }

  export type polizasWhereInput = {
    AND?: polizasWhereInput | polizasWhereInput[]
    OR?: polizasWhereInput[]
    NOT?: polizasWhereInput | polizasWhereInput[]
    id?: BigIntFilter<"polizas"> | bigint | number
    numeroPoliza?: StringNullableFilter<"polizas"> | string | null
    numeroCliente?: StringNullableFilter<"polizas"> | string | null
    inicioVigencia?: DateTimeFilter<"polizas"> | Date | string
    finVigencia?: DateTimeFilter<"polizas"> | Date | string
    antiguedad?: IntFilter<"polizas"> | number
    primaNeta?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    financiamiento?: DecimalNullableFilter<"polizas"> | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFilter<"polizas"> | bigint | number
    comisionAgente?: DecimalNullableFilter<"polizas"> | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFilter<"polizas"> | bigint | number
    formaPago_id?: BigIntFilter<"polizas"> | bigint | number
    tipoVencimiento_id?: BigIntFilter<"polizas"> | bigint | number
    compania_id?: BigIntFilter<"polizas"> | bigint | number
    subAgente_id?: BigIntNullableFilter<"polizas"> | bigint | number | null
    ramo_id?: BigIntFilter<"polizas"> | bigint | number
    metodoPago_id?: BigIntFilter<"polizas"> | bigint | number
    moneda_id?: BigIntFilter<"polizas"> | bigint | number
    producto_id?: BigIntFilter<"polizas"> | bigint | number
    created_at?: DateTimeNullableFilter<"polizas"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"polizas"> | Date | string | null
    poliza_recibos?: Poliza_recibosListRelationFilter
    clientes?: XOR<ClientesScalarRelationFilter, clientesWhereInput>
    compania?: XOR<CompaniaScalarRelationFilter, companiaWhereInput>
    formas_de_pago?: XOR<Formas_de_pagoScalarRelationFilter, formas_de_pagoWhereInput>
    metodos_de_pago?: XOR<Metodos_de_pagoScalarRelationFilter, metodos_de_pagoWhereInput>
    monedas?: XOR<MonedasScalarRelationFilter, monedasWhereInput>
    companias_productos?: XOR<Companias_productosScalarRelationFilter, companias_productosWhereInput>
    ramos?: XOR<RamosScalarRelationFilter, ramosWhereInput>
    usuarios?: XOR<UsuariosNullableScalarRelationFilter, usuariosWhereInput> | null
    tipos_de_vencimiento?: XOR<Tipos_de_vencimientoScalarRelationFilter, tipos_de_vencimientoWhereInput>
  }

  export type polizasOrderByWithRelationInput = {
    id?: SortOrder
    numeroPoliza?: SortOrderInput | SortOrder
    numeroCliente?: SortOrderInput | SortOrder
    inicioVigencia?: SortOrder
    finVigencia?: SortOrder
    antiguedad?: SortOrder
    primaNeta?: SortOrder
    financiamiento?: SortOrderInput | SortOrder
    primaTotal?: SortOrder
    estatus_id?: SortOrder
    comisionAgente?: SortOrderInput | SortOrder
    pagoInicial?: SortOrder
    pagoSubsecuente?: SortOrder
    cliente_id?: SortOrder
    formaPago_id?: SortOrder
    tipoVencimiento_id?: SortOrder
    compania_id?: SortOrder
    subAgente_id?: SortOrderInput | SortOrder
    ramo_id?: SortOrder
    metodoPago_id?: SortOrder
    moneda_id?: SortOrder
    producto_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    poliza_recibos?: poliza_recibosOrderByRelationAggregateInput
    clientes?: clientesOrderByWithRelationInput
    compania?: companiaOrderByWithRelationInput
    formas_de_pago?: formas_de_pagoOrderByWithRelationInput
    metodos_de_pago?: metodos_de_pagoOrderByWithRelationInput
    monedas?: monedasOrderByWithRelationInput
    companias_productos?: companias_productosOrderByWithRelationInput
    ramos?: ramosOrderByWithRelationInput
    usuarios?: usuariosOrderByWithRelationInput
    tipos_de_vencimiento?: tipos_de_vencimientoOrderByWithRelationInput
    _relevance?: polizasOrderByRelevanceInput
  }

  export type polizasWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    numeroPoliza?: string
    AND?: polizasWhereInput | polizasWhereInput[]
    OR?: polizasWhereInput[]
    NOT?: polizasWhereInput | polizasWhereInput[]
    numeroCliente?: StringNullableFilter<"polizas"> | string | null
    inicioVigencia?: DateTimeFilter<"polizas"> | Date | string
    finVigencia?: DateTimeFilter<"polizas"> | Date | string
    antiguedad?: IntFilter<"polizas"> | number
    primaNeta?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    financiamiento?: DecimalNullableFilter<"polizas"> | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFilter<"polizas"> | bigint | number
    comisionAgente?: DecimalNullableFilter<"polizas"> | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFilter<"polizas"> | bigint | number
    formaPago_id?: BigIntFilter<"polizas"> | bigint | number
    tipoVencimiento_id?: BigIntFilter<"polizas"> | bigint | number
    compania_id?: BigIntFilter<"polizas"> | bigint | number
    subAgente_id?: BigIntNullableFilter<"polizas"> | bigint | number | null
    ramo_id?: BigIntFilter<"polizas"> | bigint | number
    metodoPago_id?: BigIntFilter<"polizas"> | bigint | number
    moneda_id?: BigIntFilter<"polizas"> | bigint | number
    producto_id?: BigIntFilter<"polizas"> | bigint | number
    created_at?: DateTimeNullableFilter<"polizas"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"polizas"> | Date | string | null
    poliza_recibos?: Poliza_recibosListRelationFilter
    clientes?: XOR<ClientesScalarRelationFilter, clientesWhereInput>
    compania?: XOR<CompaniaScalarRelationFilter, companiaWhereInput>
    formas_de_pago?: XOR<Formas_de_pagoScalarRelationFilter, formas_de_pagoWhereInput>
    metodos_de_pago?: XOR<Metodos_de_pagoScalarRelationFilter, metodos_de_pagoWhereInput>
    monedas?: XOR<MonedasScalarRelationFilter, monedasWhereInput>
    companias_productos?: XOR<Companias_productosScalarRelationFilter, companias_productosWhereInput>
    ramos?: XOR<RamosScalarRelationFilter, ramosWhereInput>
    usuarios?: XOR<UsuariosNullableScalarRelationFilter, usuariosWhereInput> | null
    tipos_de_vencimiento?: XOR<Tipos_de_vencimientoScalarRelationFilter, tipos_de_vencimientoWhereInput>
  }, "id" | "numeroPoliza">

  export type polizasOrderByWithAggregationInput = {
    id?: SortOrder
    numeroPoliza?: SortOrderInput | SortOrder
    numeroCliente?: SortOrderInput | SortOrder
    inicioVigencia?: SortOrder
    finVigencia?: SortOrder
    antiguedad?: SortOrder
    primaNeta?: SortOrder
    financiamiento?: SortOrderInput | SortOrder
    primaTotal?: SortOrder
    estatus_id?: SortOrder
    comisionAgente?: SortOrderInput | SortOrder
    pagoInicial?: SortOrder
    pagoSubsecuente?: SortOrder
    cliente_id?: SortOrder
    formaPago_id?: SortOrder
    tipoVencimiento_id?: SortOrder
    compania_id?: SortOrder
    subAgente_id?: SortOrderInput | SortOrder
    ramo_id?: SortOrder
    metodoPago_id?: SortOrder
    moneda_id?: SortOrder
    producto_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: polizasCountOrderByAggregateInput
    _avg?: polizasAvgOrderByAggregateInput
    _max?: polizasMaxOrderByAggregateInput
    _min?: polizasMinOrderByAggregateInput
    _sum?: polizasSumOrderByAggregateInput
  }

  export type polizasScalarWhereWithAggregatesInput = {
    AND?: polizasScalarWhereWithAggregatesInput | polizasScalarWhereWithAggregatesInput[]
    OR?: polizasScalarWhereWithAggregatesInput[]
    NOT?: polizasScalarWhereWithAggregatesInput | polizasScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"polizas"> | bigint | number
    numeroPoliza?: StringNullableWithAggregatesFilter<"polizas"> | string | null
    numeroCliente?: StringNullableWithAggregatesFilter<"polizas"> | string | null
    inicioVigencia?: DateTimeWithAggregatesFilter<"polizas"> | Date | string
    finVigencia?: DateTimeWithAggregatesFilter<"polizas"> | Date | string
    antiguedad?: IntWithAggregatesFilter<"polizas"> | number
    primaNeta?: DecimalWithAggregatesFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    financiamiento?: DecimalNullableWithAggregatesFilter<"polizas"> | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalWithAggregatesFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntWithAggregatesFilter<"polizas"> | bigint | number
    comisionAgente?: DecimalNullableWithAggregatesFilter<"polizas"> | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalWithAggregatesFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalWithAggregatesFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntWithAggregatesFilter<"polizas"> | bigint | number
    formaPago_id?: BigIntWithAggregatesFilter<"polizas"> | bigint | number
    tipoVencimiento_id?: BigIntWithAggregatesFilter<"polizas"> | bigint | number
    compania_id?: BigIntWithAggregatesFilter<"polizas"> | bigint | number
    subAgente_id?: BigIntNullableWithAggregatesFilter<"polizas"> | bigint | number | null
    ramo_id?: BigIntWithAggregatesFilter<"polizas"> | bigint | number
    metodoPago_id?: BigIntWithAggregatesFilter<"polizas"> | bigint | number
    moneda_id?: BigIntWithAggregatesFilter<"polizas"> | bigint | number
    producto_id?: BigIntWithAggregatesFilter<"polizas"> | bigint | number
    created_at?: DateTimeNullableWithAggregatesFilter<"polizas"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"polizas"> | Date | string | null
  }

  export type ramosWhereInput = {
    AND?: ramosWhereInput | ramosWhereInput[]
    OR?: ramosWhereInput[]
    NOT?: ramosWhereInput | ramosWhereInput[]
    id?: BigIntFilter<"ramos"> | bigint | number
    label?: StringFilter<"ramos"> | string
    estatus?: BoolFilter<"ramos"> | boolean
    created_at?: DateTimeNullableFilter<"ramos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ramos"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"ramos"> | Date | string | null
    companias_productos?: Companias_productosListRelationFilter
    companias_ramos?: Companias_ramosListRelationFilter
    polizas?: PolizasListRelationFilter
  }

  export type ramosOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    companias_productos?: companias_productosOrderByRelationAggregateInput
    companias_ramos?: companias_ramosOrderByRelationAggregateInput
    polizas?: polizasOrderByRelationAggregateInput
    _relevance?: ramosOrderByRelevanceInput
  }

  export type ramosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ramosWhereInput | ramosWhereInput[]
    OR?: ramosWhereInput[]
    NOT?: ramosWhereInput | ramosWhereInput[]
    label?: StringFilter<"ramos"> | string
    estatus?: BoolFilter<"ramos"> | boolean
    created_at?: DateTimeNullableFilter<"ramos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ramos"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"ramos"> | Date | string | null
    companias_productos?: Companias_productosListRelationFilter
    companias_ramos?: Companias_ramosListRelationFilter
    polizas?: PolizasListRelationFilter
  }, "id">

  export type ramosOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: ramosCountOrderByAggregateInput
    _avg?: ramosAvgOrderByAggregateInput
    _max?: ramosMaxOrderByAggregateInput
    _min?: ramosMinOrderByAggregateInput
    _sum?: ramosSumOrderByAggregateInput
  }

  export type ramosScalarWhereWithAggregatesInput = {
    AND?: ramosScalarWhereWithAggregatesInput | ramosScalarWhereWithAggregatesInput[]
    OR?: ramosScalarWhereWithAggregatesInput[]
    NOT?: ramosScalarWhereWithAggregatesInput | ramosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ramos"> | bigint | number
    label?: StringWithAggregatesFilter<"ramos"> | string
    estatus?: BoolWithAggregatesFilter<"ramos"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"ramos"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ramos"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"ramos"> | Date | string | null
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: StringFilter<"sessions"> | string
    user_id?: BigIntNullableFilter<"sessions"> | bigint | number | null
    ip_address?: StringNullableFilter<"sessions"> | string | null
    user_agent?: StringNullableFilter<"sessions"> | string | null
    payload?: StringFilter<"sessions"> | string
    last_activity?: IntFilter<"sessions"> | number
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
    _relevance?: sessionsOrderByRelevanceInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    user_id?: BigIntNullableFilter<"sessions"> | bigint | number | null
    ip_address?: StringNullableFilter<"sessions"> | string | null
    user_agent?: StringNullableFilter<"sessions"> | string | null
    payload?: StringFilter<"sessions"> | string
    last_activity?: IntFilter<"sessions"> | number
  }, "id">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _avg?: sessionsAvgOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
    _sum?: sessionsSumOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sessions"> | string
    user_id?: BigIntNullableWithAggregatesFilter<"sessions"> | bigint | number | null
    ip_address?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    payload?: StringWithAggregatesFilter<"sessions"> | string
    last_activity?: IntWithAggregatesFilter<"sessions"> | number
  }

  export type tipos_de_usuariosWhereInput = {
    AND?: tipos_de_usuariosWhereInput | tipos_de_usuariosWhereInput[]
    OR?: tipos_de_usuariosWhereInput[]
    NOT?: tipos_de_usuariosWhereInput | tipos_de_usuariosWhereInput[]
    id?: BigIntFilter<"tipos_de_usuarios"> | bigint | number
    label?: StringFilter<"tipos_de_usuarios"> | string
    estatus?: BoolFilter<"tipos_de_usuarios"> | boolean
    created_at?: DateTimeNullableFilter<"tipos_de_usuarios"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"tipos_de_usuarios"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"tipos_de_usuarios"> | Date | string | null
    usuario_team?: Usuario_teamListRelationFilter
  }

  export type tipos_de_usuariosOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    usuario_team?: usuario_teamOrderByRelationAggregateInput
    _relevance?: tipos_de_usuariosOrderByRelevanceInput
  }

  export type tipos_de_usuariosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: tipos_de_usuariosWhereInput | tipos_de_usuariosWhereInput[]
    OR?: tipos_de_usuariosWhereInput[]
    NOT?: tipos_de_usuariosWhereInput | tipos_de_usuariosWhereInput[]
    label?: StringFilter<"tipos_de_usuarios"> | string
    estatus?: BoolFilter<"tipos_de_usuarios"> | boolean
    created_at?: DateTimeNullableFilter<"tipos_de_usuarios"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"tipos_de_usuarios"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"tipos_de_usuarios"> | Date | string | null
    usuario_team?: Usuario_teamListRelationFilter
  }, "id">

  export type tipos_de_usuariosOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: tipos_de_usuariosCountOrderByAggregateInput
    _avg?: tipos_de_usuariosAvgOrderByAggregateInput
    _max?: tipos_de_usuariosMaxOrderByAggregateInput
    _min?: tipos_de_usuariosMinOrderByAggregateInput
    _sum?: tipos_de_usuariosSumOrderByAggregateInput
  }

  export type tipos_de_usuariosScalarWhereWithAggregatesInput = {
    AND?: tipos_de_usuariosScalarWhereWithAggregatesInput | tipos_de_usuariosScalarWhereWithAggregatesInput[]
    OR?: tipos_de_usuariosScalarWhereWithAggregatesInput[]
    NOT?: tipos_de_usuariosScalarWhereWithAggregatesInput | tipos_de_usuariosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"tipos_de_usuarios"> | bigint | number
    label?: StringWithAggregatesFilter<"tipos_de_usuarios"> | string
    estatus?: BoolWithAggregatesFilter<"tipos_de_usuarios"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"tipos_de_usuarios"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"tipos_de_usuarios"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"tipos_de_usuarios"> | Date | string | null
  }

  export type tipos_de_vencimientoWhereInput = {
    AND?: tipos_de_vencimientoWhereInput | tipos_de_vencimientoWhereInput[]
    OR?: tipos_de_vencimientoWhereInput[]
    NOT?: tipos_de_vencimientoWhereInput | tipos_de_vencimientoWhereInput[]
    id?: BigIntFilter<"tipos_de_vencimiento"> | bigint | number
    label?: StringFilter<"tipos_de_vencimiento"> | string
    estatus?: BoolFilter<"tipos_de_vencimiento"> | boolean
    created_at?: DateTimeNullableFilter<"tipos_de_vencimiento"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"tipos_de_vencimiento"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"tipos_de_vencimiento"> | Date | string | null
    polizas?: PolizasListRelationFilter
  }

  export type tipos_de_vencimientoOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    polizas?: polizasOrderByRelationAggregateInput
    _relevance?: tipos_de_vencimientoOrderByRelevanceInput
  }

  export type tipos_de_vencimientoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: tipos_de_vencimientoWhereInput | tipos_de_vencimientoWhereInput[]
    OR?: tipos_de_vencimientoWhereInput[]
    NOT?: tipos_de_vencimientoWhereInput | tipos_de_vencimientoWhereInput[]
    label?: StringFilter<"tipos_de_vencimiento"> | string
    estatus?: BoolFilter<"tipos_de_vencimiento"> | boolean
    created_at?: DateTimeNullableFilter<"tipos_de_vencimiento"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"tipos_de_vencimiento"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"tipos_de_vencimiento"> | Date | string | null
    polizas?: PolizasListRelationFilter
  }, "id">

  export type tipos_de_vencimientoOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: tipos_de_vencimientoCountOrderByAggregateInput
    _avg?: tipos_de_vencimientoAvgOrderByAggregateInput
    _max?: tipos_de_vencimientoMaxOrderByAggregateInput
    _min?: tipos_de_vencimientoMinOrderByAggregateInput
    _sum?: tipos_de_vencimientoSumOrderByAggregateInput
  }

  export type tipos_de_vencimientoScalarWhereWithAggregatesInput = {
    AND?: tipos_de_vencimientoScalarWhereWithAggregatesInput | tipos_de_vencimientoScalarWhereWithAggregatesInput[]
    OR?: tipos_de_vencimientoScalarWhereWithAggregatesInput[]
    NOT?: tipos_de_vencimientoScalarWhereWithAggregatesInput | tipos_de_vencimientoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"tipos_de_vencimiento"> | bigint | number
    label?: StringWithAggregatesFilter<"tipos_de_vencimiento"> | string
    estatus?: BoolWithAggregatesFilter<"tipos_de_vencimiento"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"tipos_de_vencimiento"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"tipos_de_vencimiento"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"tipos_de_vencimiento"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: BigIntFilter<"users"> | bigint | number
    name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    email_verified_at?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    remember_token?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    password?: SortOrder
    remember_token?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    email_verified_at?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    remember_token?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    password?: SortOrder
    remember_token?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"users"> | bigint | number
    name?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    email_verified_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    password?: StringWithAggregatesFilter<"users"> | string
    remember_token?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type usuario_clavesWhereInput = {
    AND?: usuario_clavesWhereInput | usuario_clavesWhereInput[]
    OR?: usuario_clavesWhereInput[]
    NOT?: usuario_clavesWhereInput | usuario_clavesWhereInput[]
    id?: BigIntFilter<"usuario_claves"> | bigint | number
    compania_id?: BigIntFilter<"usuario_claves"> | bigint | number
    clave?: StringFilter<"usuario_claves"> | string
    estatus?: BoolFilter<"usuario_claves"> | boolean
    created_at?: DateTimeNullableFilter<"usuario_claves"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"usuario_claves"> | Date | string | null
    usuario_id?: BigIntFilter<"usuario_claves"> | bigint | number
    compania?: XOR<CompaniaScalarRelationFilter, companiaWhereInput>
  }

  export type usuario_clavesOrderByWithRelationInput = {
    id?: SortOrder
    compania_id?: SortOrder
    clave?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    usuario_id?: SortOrder
    compania?: companiaOrderByWithRelationInput
    _relevance?: usuario_clavesOrderByRelevanceInput
  }

  export type usuario_clavesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: usuario_clavesWhereInput | usuario_clavesWhereInput[]
    OR?: usuario_clavesWhereInput[]
    NOT?: usuario_clavesWhereInput | usuario_clavesWhereInput[]
    compania_id?: BigIntFilter<"usuario_claves"> | bigint | number
    clave?: StringFilter<"usuario_claves"> | string
    estatus?: BoolFilter<"usuario_claves"> | boolean
    created_at?: DateTimeNullableFilter<"usuario_claves"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"usuario_claves"> | Date | string | null
    usuario_id?: BigIntFilter<"usuario_claves"> | bigint | number
    compania?: XOR<CompaniaScalarRelationFilter, companiaWhereInput>
  }, "id">

  export type usuario_clavesOrderByWithAggregationInput = {
    id?: SortOrder
    compania_id?: SortOrder
    clave?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    usuario_id?: SortOrder
    _count?: usuario_clavesCountOrderByAggregateInput
    _avg?: usuario_clavesAvgOrderByAggregateInput
    _max?: usuario_clavesMaxOrderByAggregateInput
    _min?: usuario_clavesMinOrderByAggregateInput
    _sum?: usuario_clavesSumOrderByAggregateInput
  }

  export type usuario_clavesScalarWhereWithAggregatesInput = {
    AND?: usuario_clavesScalarWhereWithAggregatesInput | usuario_clavesScalarWhereWithAggregatesInput[]
    OR?: usuario_clavesScalarWhereWithAggregatesInput[]
    NOT?: usuario_clavesScalarWhereWithAggregatesInput | usuario_clavesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"usuario_claves"> | bigint | number
    compania_id?: BigIntWithAggregatesFilter<"usuario_claves"> | bigint | number
    clave?: StringWithAggregatesFilter<"usuario_claves"> | string
    estatus?: BoolWithAggregatesFilter<"usuario_claves"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"usuario_claves"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"usuario_claves"> | Date | string | null
    usuario_id?: BigIntWithAggregatesFilter<"usuario_claves"> | bigint | number
  }

  export type usuario_teamWhereInput = {
    AND?: usuario_teamWhereInput | usuario_teamWhereInput[]
    OR?: usuario_teamWhereInput[]
    NOT?: usuario_teamWhereInput | usuario_teamWhereInput[]
    id?: BigIntFilter<"usuario_team"> | bigint | number
    principal_id?: BigIntFilter<"usuario_team"> | bigint | number
    tipo_id?: BigIntFilter<"usuario_team"> | bigint | number
    usuario_id?: BigIntFilter<"usuario_team"> | bigint | number
    estatus?: BoolFilter<"usuario_team"> | boolean
    created_at?: DateTimeNullableFilter<"usuario_team"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"usuario_team"> | Date | string | null
    tipos_de_usuarios?: XOR<Tipos_de_usuariosScalarRelationFilter, tipos_de_usuariosWhereInput>
    usuarios?: XOR<UsuariosScalarRelationFilter, usuariosWhereInput>
  }

  export type usuario_teamOrderByWithRelationInput = {
    id?: SortOrder
    principal_id?: SortOrder
    tipo_id?: SortOrder
    usuario_id?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    tipos_de_usuarios?: tipos_de_usuariosOrderByWithRelationInput
    usuarios?: usuariosOrderByWithRelationInput
  }

  export type usuario_teamWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: usuario_teamWhereInput | usuario_teamWhereInput[]
    OR?: usuario_teamWhereInput[]
    NOT?: usuario_teamWhereInput | usuario_teamWhereInput[]
    principal_id?: BigIntFilter<"usuario_team"> | bigint | number
    tipo_id?: BigIntFilter<"usuario_team"> | bigint | number
    usuario_id?: BigIntFilter<"usuario_team"> | bigint | number
    estatus?: BoolFilter<"usuario_team"> | boolean
    created_at?: DateTimeNullableFilter<"usuario_team"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"usuario_team"> | Date | string | null
    tipos_de_usuarios?: XOR<Tipos_de_usuariosScalarRelationFilter, tipos_de_usuariosWhereInput>
    usuarios?: XOR<UsuariosScalarRelationFilter, usuariosWhereInput>
  }, "id">

  export type usuario_teamOrderByWithAggregationInput = {
    id?: SortOrder
    principal_id?: SortOrder
    tipo_id?: SortOrder
    usuario_id?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: usuario_teamCountOrderByAggregateInput
    _avg?: usuario_teamAvgOrderByAggregateInput
    _max?: usuario_teamMaxOrderByAggregateInput
    _min?: usuario_teamMinOrderByAggregateInput
    _sum?: usuario_teamSumOrderByAggregateInput
  }

  export type usuario_teamScalarWhereWithAggregatesInput = {
    AND?: usuario_teamScalarWhereWithAggregatesInput | usuario_teamScalarWhereWithAggregatesInput[]
    OR?: usuario_teamScalarWhereWithAggregatesInput[]
    NOT?: usuario_teamScalarWhereWithAggregatesInput | usuario_teamScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"usuario_team"> | bigint | number
    principal_id?: BigIntWithAggregatesFilter<"usuario_team"> | bigint | number
    tipo_id?: BigIntWithAggregatesFilter<"usuario_team"> | bigint | number
    usuario_id?: BigIntWithAggregatesFilter<"usuario_team"> | bigint | number
    estatus?: BoolWithAggregatesFilter<"usuario_team"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"usuario_team"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"usuario_team"> | Date | string | null
  }

  export type usuariosWhereInput = {
    AND?: usuariosWhereInput | usuariosWhereInput[]
    OR?: usuariosWhereInput[]
    NOT?: usuariosWhereInput | usuariosWhereInput[]
    id?: BigIntFilter<"usuarios"> | bigint | number
    nombre?: StringFilter<"usuarios"> | string
    correo?: StringFilter<"usuarios"> | string
    password?: StringFilter<"usuarios"> | string
    tipo_id?: BigIntFilter<"usuarios"> | bigint | number
    estatus?: BoolFilter<"usuarios"> | boolean
    created_at?: DateTimeNullableFilter<"usuarios"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"usuarios"> | Date | string | null
    polizas?: PolizasListRelationFilter
    usuario_team?: Usuario_teamListRelationFilter
  }

  export type usuariosOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    tipo_id?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    polizas?: polizasOrderByRelationAggregateInput
    usuario_team?: usuario_teamOrderByRelationAggregateInput
    _relevance?: usuariosOrderByRelevanceInput
  }

  export type usuariosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    correo?: string
    AND?: usuariosWhereInput | usuariosWhereInput[]
    OR?: usuariosWhereInput[]
    NOT?: usuariosWhereInput | usuariosWhereInput[]
    nombre?: StringFilter<"usuarios"> | string
    password?: StringFilter<"usuarios"> | string
    tipo_id?: BigIntFilter<"usuarios"> | bigint | number
    estatus?: BoolFilter<"usuarios"> | boolean
    created_at?: DateTimeNullableFilter<"usuarios"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"usuarios"> | Date | string | null
    polizas?: PolizasListRelationFilter
    usuario_team?: Usuario_teamListRelationFilter
  }, "id" | "correo">

  export type usuariosOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    tipo_id?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: usuariosCountOrderByAggregateInput
    _avg?: usuariosAvgOrderByAggregateInput
    _max?: usuariosMaxOrderByAggregateInput
    _min?: usuariosMinOrderByAggregateInput
    _sum?: usuariosSumOrderByAggregateInput
  }

  export type usuariosScalarWhereWithAggregatesInput = {
    AND?: usuariosScalarWhereWithAggregatesInput | usuariosScalarWhereWithAggregatesInput[]
    OR?: usuariosScalarWhereWithAggregatesInput[]
    NOT?: usuariosScalarWhereWithAggregatesInput | usuariosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"usuarios"> | bigint | number
    nombre?: StringWithAggregatesFilter<"usuarios"> | string
    correo?: StringWithAggregatesFilter<"usuarios"> | string
    password?: StringWithAggregatesFilter<"usuarios"> | string
    tipo_id?: BigIntWithAggregatesFilter<"usuarios"> | bigint | number
    estatus?: BoolWithAggregatesFilter<"usuarios"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"usuarios"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"usuarios"> | Date | string | null
  }

  export type actividadesCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type actividadesUncheckedCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type actividadesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type actividadesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type actividadesCreateManyInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type actividadesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type actividadesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cacheCreateInput = {
    key: string
    value: string
    expiration: number
  }

  export type cacheUncheckedCreateInput = {
    key: string
    value: string
    expiration: number
  }

  export type cacheUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cacheUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cacheCreateManyInput = {
    key: string
    value: string
    expiration: number
  }

  export type cacheUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cacheUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksCreateInput = {
    key: string
    owner: string
    expiration: number
  }

  export type cache_locksUncheckedCreateInput = {
    key: string
    owner: string
    expiration: number
  }

  export type cache_locksUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksCreateManyInput = {
    key: string
    owner: string
    expiration: number
  }

  export type cache_locksUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type clientesCreateInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    fechaNacimiento: Date | string
    direccion: string
    colonia: string
    codigoPostal: string
    estado_id: bigint | number
    ciudad: string
    correo?: string | null
    telefono?: string | null
    celular?: string | null
    oficina?: string | null
    casa?: string | null
    observaciones?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    polizas?: polizasCreateNestedManyWithoutClientesInput
  }

  export type clientesUncheckedCreateInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    fechaNacimiento: Date | string
    direccion: string
    colonia: string
    codigoPostal: string
    estado_id: bigint | number
    ciudad: string
    correo?: string | null
    telefono?: string | null
    celular?: string | null
    oficina?: string | null
    casa?: string | null
    observaciones?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    polizas?: polizasUncheckedCreateNestedManyWithoutClientesInput
  }

  export type clientesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    colonia?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    estado_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ciudad?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    oficina?: NullableStringFieldUpdateOperationsInput | string | null
    casa?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUpdateManyWithoutClientesNestedInput
  }

  export type clientesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    colonia?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    estado_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ciudad?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    oficina?: NullableStringFieldUpdateOperationsInput | string | null
    casa?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUncheckedUpdateManyWithoutClientesNestedInput
  }

  export type clientesCreateManyInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    fechaNacimiento: Date | string
    direccion: string
    colonia: string
    codigoPostal: string
    estado_id: bigint | number
    ciudad: string
    correo?: string | null
    telefono?: string | null
    celular?: string | null
    oficina?: string | null
    casa?: string | null
    observaciones?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type clientesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    colonia?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    estado_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ciudad?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    oficina?: NullableStringFieldUpdateOperationsInput | string | null
    casa?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clientesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    colonia?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    estado_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ciudad?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    oficina?: NullableStringFieldUpdateOperationsInput | string | null
    casa?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companiaCreateInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania_representantes?: compania_representantesCreateNestedManyWithoutCompaniaInput
    companias_productos?: companias_productosCreateNestedManyWithoutCompaniaInput
    companias_ramos?: companias_ramosCreateNestedManyWithoutCompaniaInput
    polizas?: polizasCreateNestedManyWithoutCompaniaInput
    usuario_claves?: usuario_clavesCreateNestedManyWithoutCompaniaInput
  }

  export type companiaUncheckedCreateInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania_representantes?: compania_representantesUncheckedCreateNestedManyWithoutCompaniaInput
    companias_productos?: companias_productosUncheckedCreateNestedManyWithoutCompaniaInput
    companias_ramos?: companias_ramosUncheckedCreateNestedManyWithoutCompaniaInput
    polizas?: polizasUncheckedCreateNestedManyWithoutCompaniaInput
    usuario_claves?: usuario_clavesUncheckedCreateNestedManyWithoutCompaniaInput
  }

  export type companiaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania_representantes?: compania_representantesUpdateManyWithoutCompaniaNestedInput
    companias_productos?: companias_productosUpdateManyWithoutCompaniaNestedInput
    companias_ramos?: companias_ramosUpdateManyWithoutCompaniaNestedInput
    polizas?: polizasUpdateManyWithoutCompaniaNestedInput
    usuario_claves?: usuario_clavesUpdateManyWithoutCompaniaNestedInput
  }

  export type companiaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania_representantes?: compania_representantesUncheckedUpdateManyWithoutCompaniaNestedInput
    companias_productos?: companias_productosUncheckedUpdateManyWithoutCompaniaNestedInput
    companias_ramos?: companias_ramosUncheckedUpdateManyWithoutCompaniaNestedInput
    polizas?: polizasUncheckedUpdateManyWithoutCompaniaNestedInput
    usuario_claves?: usuario_clavesUncheckedUpdateManyWithoutCompaniaNestedInput
  }

  export type companiaCreateManyInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type companiaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companiaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type compania_representantesCreateInput = {
    id?: bigint | number
    nombre: string
    telefono: string
    correo: string
    cargo: string
    estatus?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania: companiaCreateNestedOneWithoutCompania_representantesInput
  }

  export type compania_representantesUncheckedCreateInput = {
    id?: bigint | number
    compania_id: bigint | number
    nombre: string
    telefono: string
    correo: string
    cargo: string
    estatus?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type compania_representantesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania?: companiaUpdateOneRequiredWithoutCompania_representantesNestedInput
  }

  export type compania_representantesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type compania_representantesCreateManyInput = {
    id?: bigint | number
    compania_id: bigint | number
    nombre: string
    telefono: string
    correo: string
    cargo: string
    estatus?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type compania_representantesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type compania_representantesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companias_productosCreateInput = {
    id?: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
    compania: companiaCreateNestedOneWithoutCompanias_productosInput
    ramos: ramosCreateNestedOneWithoutCompanias_productosInput
    polizas?: polizasCreateNestedManyWithoutCompanias_productosInput
  }

  export type companias_productosUncheckedCreateInput = {
    id?: bigint | number
    compania_id: bigint | number
    ramo_id: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
    polizas?: polizasUncheckedCreateNestedManyWithoutCompanias_productosInput
  }

  export type companias_productosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    compania?: companiaUpdateOneRequiredWithoutCompanias_productosNestedInput
    ramos?: ramosUpdateOneRequiredWithoutCompanias_productosNestedInput
    polizas?: polizasUpdateManyWithoutCompanias_productosNestedInput
  }

  export type companias_productosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    polizas?: polizasUncheckedUpdateManyWithoutCompanias_productosNestedInput
  }

  export type companias_productosCreateManyInput = {
    id?: bigint | number
    compania_id: bigint | number
    ramo_id: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
  }

  export type companias_productosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companias_productosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companias_ramosCreateInput = {
    id?: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
    compania: companiaCreateNestedOneWithoutCompanias_ramosInput
    ramos: ramosCreateNestedOneWithoutCompanias_ramosInput
  }

  export type companias_ramosUncheckedCreateInput = {
    id?: bigint | number
    compania_id: bigint | number
    ramo_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
  }

  export type companias_ramosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    compania?: companiaUpdateOneRequiredWithoutCompanias_ramosNestedInput
    ramos?: ramosUpdateOneRequiredWithoutCompanias_ramosNestedInput
  }

  export type companias_ramosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companias_ramosCreateManyInput = {
    id?: bigint | number
    compania_id: bigint | number
    ramo_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
  }

  export type companias_ramosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companias_ramosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type estadosCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type estadosUncheckedCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type estadosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estadosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estadosCreateManyInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type estadosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estadosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estatus_clienteCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type estatus_clienteUncheckedCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type estatus_clienteUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estatus_clienteUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estatus_clienteCreateManyInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type estatus_clienteUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estatus_clienteUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estatus_polizasCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type estatus_polizasUncheckedCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type estatus_polizasUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estatus_polizasUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estatus_polizasCreateManyInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type estatus_polizasUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estatus_polizasUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type failed_jobsCreateInput = {
    id?: bigint | number
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failed_at?: Date | string
  }

  export type failed_jobsUncheckedCreateInput = {
    id?: bigint | number
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failed_at?: Date | string
  }

  export type failed_jobsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type failed_jobsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type failed_jobsCreateManyInput = {
    id?: bigint | number
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failed_at?: Date | string
  }

  export type failed_jobsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type failed_jobsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formas_de_pagoCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    polizas?: polizasCreateNestedManyWithoutFormas_de_pagoInput
  }

  export type formas_de_pagoUncheckedCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    polizas?: polizasUncheckedCreateNestedManyWithoutFormas_de_pagoInput
  }

  export type formas_de_pagoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUpdateManyWithoutFormas_de_pagoNestedInput
  }

  export type formas_de_pagoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUncheckedUpdateManyWithoutFormas_de_pagoNestedInput
  }

  export type formas_de_pagoCreateManyInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type formas_de_pagoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type formas_de_pagoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type job_batchesCreateInput = {
    id: string
    name: string
    total_jobs: number
    pending_jobs: number
    failed_jobs: number
    failed_job_ids: string
    options?: string | null
    cancelled_at?: number | null
    created_at: number
    finished_at?: number | null
  }

  export type job_batchesUncheckedCreateInput = {
    id: string
    name: string
    total_jobs: number
    pending_jobs: number
    failed_jobs: number
    failed_job_ids: string
    options?: string | null
    cancelled_at?: number | null
    created_at: number
    finished_at?: number | null
  }

  export type job_batchesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    total_jobs?: IntFieldUpdateOperationsInput | number
    pending_jobs?: IntFieldUpdateOperationsInput | number
    failed_jobs?: IntFieldUpdateOperationsInput | number
    failed_job_ids?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: IntFieldUpdateOperationsInput | number
    finished_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type job_batchesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    total_jobs?: IntFieldUpdateOperationsInput | number
    pending_jobs?: IntFieldUpdateOperationsInput | number
    failed_jobs?: IntFieldUpdateOperationsInput | number
    failed_job_ids?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: IntFieldUpdateOperationsInput | number
    finished_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type job_batchesCreateManyInput = {
    id: string
    name: string
    total_jobs: number
    pending_jobs: number
    failed_jobs: number
    failed_job_ids: string
    options?: string | null
    cancelled_at?: number | null
    created_at: number
    finished_at?: number | null
  }

  export type job_batchesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    total_jobs?: IntFieldUpdateOperationsInput | number
    pending_jobs?: IntFieldUpdateOperationsInput | number
    failed_jobs?: IntFieldUpdateOperationsInput | number
    failed_job_ids?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: IntFieldUpdateOperationsInput | number
    finished_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type job_batchesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    total_jobs?: IntFieldUpdateOperationsInput | number
    pending_jobs?: IntFieldUpdateOperationsInput | number
    failed_jobs?: IntFieldUpdateOperationsInput | number
    failed_job_ids?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: IntFieldUpdateOperationsInput | number
    finished_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type jobsCreateInput = {
    id?: bigint | number
    queue: string
    payload: string
    attempts: number
    reserved_at?: number | null
    available_at: number
    created_at: number
  }

  export type jobsUncheckedCreateInput = {
    id?: bigint | number
    queue: string
    payload: string
    attempts: number
    reserved_at?: number | null
    available_at: number
    created_at: number
  }

  export type jobsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    reserved_at?: NullableIntFieldUpdateOperationsInput | number | null
    available_at?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
  }

  export type jobsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    reserved_at?: NullableIntFieldUpdateOperationsInput | number | null
    available_at?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
  }

  export type jobsCreateManyInput = {
    id?: bigint | number
    queue: string
    payload: string
    attempts: number
    reserved_at?: number | null
    available_at: number
    created_at: number
  }

  export type jobsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    reserved_at?: NullableIntFieldUpdateOperationsInput | number | null
    available_at?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
  }

  export type jobsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    reserved_at?: NullableIntFieldUpdateOperationsInput | number | null
    available_at?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
  }

  export type metodos_de_pagoCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    polizas?: polizasCreateNestedManyWithoutMetodos_de_pagoInput
  }

  export type metodos_de_pagoUncheckedCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    polizas?: polizasUncheckedCreateNestedManyWithoutMetodos_de_pagoInput
  }

  export type metodos_de_pagoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUpdateManyWithoutMetodos_de_pagoNestedInput
  }

  export type metodos_de_pagoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUncheckedUpdateManyWithoutMetodos_de_pagoNestedInput
  }

  export type metodos_de_pagoCreateManyInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type metodos_de_pagoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type metodos_de_pagoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsCreateInput = {
    migration: string
    batch: number
  }

  export type migrationsUncheckedCreateInput = {
    id?: number
    migration: string
    batch: number
  }

  export type migrationsUpdateInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsCreateManyInput = {
    id?: number
    migration: string
    batch: number
  }

  export type migrationsUpdateManyMutationInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type monedasCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    polizas?: polizasCreateNestedManyWithoutMonedasInput
  }

  export type monedasUncheckedCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    polizas?: polizasUncheckedCreateNestedManyWithoutMonedasInput
  }

  export type monedasUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUpdateManyWithoutMonedasNestedInput
  }

  export type monedasUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUncheckedUpdateManyWithoutMonedasNestedInput
  }

  export type monedasCreateManyInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type monedasUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type monedasUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensCreateInput = {
    email: string
    token: string
    created_at?: Date | string | null
  }

  export type password_reset_tokensUncheckedCreateInput = {
    email: string
    token: string
    created_at?: Date | string | null
  }

  export type password_reset_tokensUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensCreateManyInput = {
    email: string
    token: string
    created_at?: Date | string | null
  }

  export type password_reset_tokensUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensCreateInput = {
    id?: bigint | number
    tokenable_type: string
    tokenable_id: bigint | number
    name: string
    token: string
    abilities?: string | null
    last_used_at?: Date | string | null
    expires_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type personal_access_tokensUncheckedCreateInput = {
    id?: bigint | number
    tokenable_type: string
    tokenable_id: bigint | number
    name: string
    token: string
    abilities?: string | null
    last_used_at?: Date | string | null
    expires_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type personal_access_tokensUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenable_type?: StringFieldUpdateOperationsInput | string
    tokenable_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenable_type?: StringFieldUpdateOperationsInput | string
    tokenable_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensCreateManyInput = {
    id?: bigint | number
    tokenable_type: string
    tokenable_id: bigint | number
    name: string
    token: string
    abilities?: string | null
    last_used_at?: Date | string | null
    expires_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type personal_access_tokensUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenable_type?: StringFieldUpdateOperationsInput | string
    tokenable_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personal_access_tokensUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenable_type?: StringFieldUpdateOperationsInput | string
    tokenable_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    abilities?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_aseguradosCreateInput = {
    id?: bigint | number
    poliza_id: bigint | number
    cliente_id?: bigint | number | null
    rfc: string
    nombre: string
    fechaNacimiento: Date | string
    direccion: string
    colonia: string
    codigoPostal: string
    estado_id: bigint | number
    ciudad: string
    correo?: string | null
    telefono?: string | null
    celular?: string | null
    oficina?: string | null
    casa?: string | null
    observaciones?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type poliza_aseguradosUncheckedCreateInput = {
    id?: bigint | number
    poliza_id: bigint | number
    cliente_id?: bigint | number | null
    rfc: string
    nombre: string
    fechaNacimiento: Date | string
    direccion: string
    colonia: string
    codigoPostal: string
    estado_id: bigint | number
    ciudad: string
    correo?: string | null
    telefono?: string | null
    celular?: string | null
    oficina?: string | null
    casa?: string | null
    observaciones?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type poliza_aseguradosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    poliza_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cliente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    colonia?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    estado_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ciudad?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    oficina?: NullableStringFieldUpdateOperationsInput | string | null
    casa?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_aseguradosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    poliza_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cliente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    colonia?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    estado_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ciudad?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    oficina?: NullableStringFieldUpdateOperationsInput | string | null
    casa?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_aseguradosCreateManyInput = {
    id?: bigint | number
    poliza_id: bigint | number
    cliente_id?: bigint | number | null
    rfc: string
    nombre: string
    fechaNacimiento: Date | string
    direccion: string
    colonia: string
    codigoPostal: string
    estado_id: bigint | number
    ciudad: string
    correo?: string | null
    telefono?: string | null
    celular?: string | null
    oficina?: string | null
    casa?: string | null
    observaciones?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type poliza_aseguradosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    poliza_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cliente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    colonia?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    estado_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ciudad?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    oficina?: NullableStringFieldUpdateOperationsInput | string | null
    casa?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_aseguradosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    poliza_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cliente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    colonia?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    estado_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ciudad?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    oficina?: NullableStringFieldUpdateOperationsInput | string | null
    casa?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_historialCreateInput = {
    id?: bigint | number
    poliza_id?: bigint | number | null
    accion: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type poliza_historialUncheckedCreateInput = {
    id?: bigint | number
    poliza_id?: bigint | number | null
    accion: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type poliza_historialUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    poliza_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    accion?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_historialUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    poliza_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    accion?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_historialCreateManyInput = {
    id?: bigint | number
    poliza_id?: bigint | number | null
    accion: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type poliza_historialUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    poliza_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    accion?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_historialUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    poliza_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    accion?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_recibosCreateInput = {
    id?: bigint | number
    numeroRecibo: string
    vencimiento: Date | string
    importe: Decimal | DecimalJsLike | number | string
    estatus?: $Enums.poliza_recibos_estatus
    fechaPago?: Date | string | null
    fechaCancelado?: Date | string | null
    evidencia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    polizas: polizasCreateNestedOneWithoutPoliza_recibosInput
  }

  export type poliza_recibosUncheckedCreateInput = {
    id?: bigint | number
    poliza_id: bigint | number
    numeroRecibo: string
    vencimiento: Date | string
    importe: Decimal | DecimalJsLike | number | string
    estatus?: $Enums.poliza_recibos_estatus
    fechaPago?: Date | string | null
    fechaCancelado?: Date | string | null
    evidencia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type poliza_recibosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroRecibo?: StringFieldUpdateOperationsInput | string
    vencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    importe?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusFieldUpdateOperationsInput | $Enums.poliza_recibos_estatus
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCancelado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUpdateOneRequiredWithoutPoliza_recibosNestedInput
  }

  export type poliza_recibosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    poliza_id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroRecibo?: StringFieldUpdateOperationsInput | string
    vencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    importe?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusFieldUpdateOperationsInput | $Enums.poliza_recibos_estatus
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCancelado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_recibosCreateManyInput = {
    id?: bigint | number
    poliza_id: bigint | number
    numeroRecibo: string
    vencimiento: Date | string
    importe: Decimal | DecimalJsLike | number | string
    estatus?: $Enums.poliza_recibos_estatus
    fechaPago?: Date | string | null
    fechaCancelado?: Date | string | null
    evidencia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type poliza_recibosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroRecibo?: StringFieldUpdateOperationsInput | string
    vencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    importe?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusFieldUpdateOperationsInput | $Enums.poliza_recibos_estatus
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCancelado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_recibosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    poliza_id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroRecibo?: StringFieldUpdateOperationsInput | string
    vencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    importe?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusFieldUpdateOperationsInput | $Enums.poliza_recibos_estatus
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCancelado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type polizasCreateInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosCreateNestedManyWithoutPolizasInput
    clientes: clientesCreateNestedOneWithoutPolizasInput
    compania: companiaCreateNestedOneWithoutPolizasInput
    formas_de_pago: formas_de_pagoCreateNestedOneWithoutPolizasInput
    metodos_de_pago: metodos_de_pagoCreateNestedOneWithoutPolizasInput
    monedas: monedasCreateNestedOneWithoutPolizasInput
    companias_productos: companias_productosCreateNestedOneWithoutPolizasInput
    ramos: ramosCreateNestedOneWithoutPolizasInput
    usuarios?: usuariosCreateNestedOneWithoutPolizasInput
    tipos_de_vencimiento: tipos_de_vencimientoCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput
  }

  export type polizasUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUpdateManyWithoutPolizasNestedInput
    clientes?: clientesUpdateOneRequiredWithoutPolizasNestedInput
    compania?: companiaUpdateOneRequiredWithoutPolizasNestedInput
    formas_de_pago?: formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    metodos_de_pago?: metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutPolizasNestedInput
    companias_productos?: companias_productosUpdateOneRequiredWithoutPolizasNestedInput
    ramos?: ramosUpdateOneRequiredWithoutPolizasNestedInput
    usuarios?: usuariosUpdateOneWithoutPolizasNestedInput
    tipos_de_vencimiento?: tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput
  }

  export type polizasCreateManyInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type polizasUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type polizasUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ramosCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companias_productos?: companias_productosCreateNestedManyWithoutRamosInput
    companias_ramos?: companias_ramosCreateNestedManyWithoutRamosInput
    polizas?: polizasCreateNestedManyWithoutRamosInput
  }

  export type ramosUncheckedCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companias_productos?: companias_productosUncheckedCreateNestedManyWithoutRamosInput
    companias_ramos?: companias_ramosUncheckedCreateNestedManyWithoutRamosInput
    polizas?: polizasUncheckedCreateNestedManyWithoutRamosInput
  }

  export type ramosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companias_productos?: companias_productosUpdateManyWithoutRamosNestedInput
    companias_ramos?: companias_ramosUpdateManyWithoutRamosNestedInput
    polizas?: polizasUpdateManyWithoutRamosNestedInput
  }

  export type ramosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companias_productos?: companias_productosUncheckedUpdateManyWithoutRamosNestedInput
    companias_ramos?: companias_ramosUncheckedUpdateManyWithoutRamosNestedInput
    polizas?: polizasUncheckedUpdateManyWithoutRamosNestedInput
  }

  export type ramosCreateManyInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ramosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ramosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsCreateInput = {
    id: string
    user_id?: bigint | number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type sessionsUncheckedCreateInput = {
    id: string
    user_id?: bigint | number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsCreateManyInput = {
    id: string
    user_id?: bigint | number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type tipos_de_usuariosCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    usuario_team?: usuario_teamCreateNestedManyWithoutTipos_de_usuariosInput
  }

  export type tipos_de_usuariosUncheckedCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    usuario_team?: usuario_teamUncheckedCreateNestedManyWithoutTipos_de_usuariosInput
  }

  export type tipos_de_usuariosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_team?: usuario_teamUpdateManyWithoutTipos_de_usuariosNestedInput
  }

  export type tipos_de_usuariosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_team?: usuario_teamUncheckedUpdateManyWithoutTipos_de_usuariosNestedInput
  }

  export type tipos_de_usuariosCreateManyInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type tipos_de_usuariosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tipos_de_usuariosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tipos_de_vencimientoCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    polizas?: polizasCreateNestedManyWithoutTipos_de_vencimientoInput
  }

  export type tipos_de_vencimientoUncheckedCreateInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    polizas?: polizasUncheckedCreateNestedManyWithoutTipos_de_vencimientoInput
  }

  export type tipos_de_vencimientoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUpdateManyWithoutTipos_de_vencimientoNestedInput
  }

  export type tipos_de_vencimientoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUncheckedUpdateManyWithoutTipos_de_vencimientoNestedInput
  }

  export type tipos_de_vencimientoCreateManyInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type tipos_de_vencimientoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tipos_de_vencimientoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUncheckedCreateInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateManyInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuario_clavesCreateInput = {
    id?: bigint | number
    clave: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    usuario_id: bigint | number
    compania: companiaCreateNestedOneWithoutUsuario_clavesInput
  }

  export type usuario_clavesUncheckedCreateInput = {
    id?: bigint | number
    compania_id: bigint | number
    clave: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    usuario_id: bigint | number
  }

  export type usuario_clavesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    clave?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania?: companiaUpdateOneRequiredWithoutUsuario_clavesNestedInput
  }

  export type usuario_clavesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    clave?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type usuario_clavesCreateManyInput = {
    id?: bigint | number
    compania_id: bigint | number
    clave: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    usuario_id: bigint | number
  }

  export type usuario_clavesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    clave?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type usuario_clavesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    clave?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type usuario_teamCreateInput = {
    id?: bigint | number
    principal_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    tipos_de_usuarios: tipos_de_usuariosCreateNestedOneWithoutUsuario_teamInput
    usuarios: usuariosCreateNestedOneWithoutUsuario_teamInput
  }

  export type usuario_teamUncheckedCreateInput = {
    id?: bigint | number
    principal_id: bigint | number
    tipo_id: bigint | number
    usuario_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usuario_teamUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    principal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipos_de_usuarios?: tipos_de_usuariosUpdateOneRequiredWithoutUsuario_teamNestedInput
    usuarios?: usuariosUpdateOneRequiredWithoutUsuario_teamNestedInput
  }

  export type usuario_teamUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    principal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuario_teamCreateManyInput = {
    id?: bigint | number
    principal_id: bigint | number
    tipo_id: bigint | number
    usuario_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usuario_teamUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    principal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuario_teamUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    principal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuariosCreateInput = {
    id?: bigint | number
    nombre: string
    correo: string
    password: string
    tipo_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    polizas?: polizasCreateNestedManyWithoutUsuariosInput
    usuario_team?: usuario_teamCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosUncheckedCreateInput = {
    id?: bigint | number
    nombre: string
    correo: string
    password: string
    tipo_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    polizas?: polizasUncheckedCreateNestedManyWithoutUsuariosInput
    usuario_team?: usuario_teamUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUpdateManyWithoutUsuariosNestedInput
    usuario_team?: usuario_teamUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUncheckedUpdateManyWithoutUsuariosNestedInput
    usuario_team?: usuario_teamUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosCreateManyInput = {
    id?: bigint | number
    nombre: string
    correo: string
    password: string
    tipo_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usuariosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuariosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type actividadesOrderByRelevanceInput = {
    fields: actividadesOrderByRelevanceFieldEnum | actividadesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type actividadesCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type actividadesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type actividadesMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type actividadesMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type actividadesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type cacheOrderByRelevanceInput = {
    fields: cacheOrderByRelevanceFieldEnum | cacheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cacheCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
  }

  export type cacheAvgOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type cacheMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
  }

  export type cacheMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
  }

  export type cacheSumOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type cache_locksOrderByRelevanceInput = {
    fields: cache_locksOrderByRelevanceFieldEnum | cache_locksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cache_locksCountOrderByAggregateInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
  }

  export type cache_locksAvgOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type cache_locksMaxOrderByAggregateInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
  }

  export type cache_locksMinOrderByAggregateInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
  }

  export type cache_locksSumOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type PolizasListRelationFilter = {
    every?: polizasWhereInput
    some?: polizasWhereInput
    none?: polizasWhereInput
  }

  export type polizasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientesOrderByRelevanceInput = {
    fields: clientesOrderByRelevanceFieldEnum | clientesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type clientesCountOrderByAggregateInput = {
    id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    colonia?: SortOrder
    codigoPostal?: SortOrder
    estado_id?: SortOrder
    ciudad?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    oficina?: SortOrder
    casa?: SortOrder
    observaciones?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type clientesAvgOrderByAggregateInput = {
    id?: SortOrder
    estado_id?: SortOrder
  }

  export type clientesMaxOrderByAggregateInput = {
    id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    colonia?: SortOrder
    codigoPostal?: SortOrder
    estado_id?: SortOrder
    ciudad?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    oficina?: SortOrder
    casa?: SortOrder
    observaciones?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type clientesMinOrderByAggregateInput = {
    id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    colonia?: SortOrder
    codigoPostal?: SortOrder
    estado_id?: SortOrder
    ciudad?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    oficina?: SortOrder
    casa?: SortOrder
    observaciones?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type clientesSumOrderByAggregateInput = {
    id?: SortOrder
    estado_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Compania_representantesListRelationFilter = {
    every?: compania_representantesWhereInput
    some?: compania_representantesWhereInput
    none?: compania_representantesWhereInput
  }

  export type Companias_productosListRelationFilter = {
    every?: companias_productosWhereInput
    some?: companias_productosWhereInput
    none?: companias_productosWhereInput
  }

  export type Companias_ramosListRelationFilter = {
    every?: companias_ramosWhereInput
    some?: companias_ramosWhereInput
    none?: companias_ramosWhereInput
  }

  export type Usuario_clavesListRelationFilter = {
    every?: usuario_clavesWhereInput
    some?: usuario_clavesWhereInput
    none?: usuario_clavesWhereInput
  }

  export type compania_representantesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companias_productosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companias_ramosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuario_clavesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companiaOrderByRelevanceInput = {
    fields: companiaOrderByRelevanceFieldEnum | companiaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type companiaCountOrderByAggregateInput = {
    id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    nombreCorto?: SortOrder
    direccion?: SortOrder
    estado?: SortOrder
    codigoPostal?: SortOrder
    ciudad?: SortOrder
    limitePrimerPago?: SortOrder
    limitePrimerSubsecuente?: SortOrder
    estatus?: SortOrder
    colonia?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiaAvgOrderByAggregateInput = {
    id?: SortOrder
    limitePrimerPago?: SortOrder
    limitePrimerSubsecuente?: SortOrder
  }

  export type companiaMaxOrderByAggregateInput = {
    id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    nombreCorto?: SortOrder
    direccion?: SortOrder
    estado?: SortOrder
    codigoPostal?: SortOrder
    ciudad?: SortOrder
    limitePrimerPago?: SortOrder
    limitePrimerSubsecuente?: SortOrder
    estatus?: SortOrder
    colonia?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiaMinOrderByAggregateInput = {
    id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    nombreCorto?: SortOrder
    direccion?: SortOrder
    estado?: SortOrder
    codigoPostal?: SortOrder
    ciudad?: SortOrder
    limitePrimerPago?: SortOrder
    limitePrimerSubsecuente?: SortOrder
    estatus?: SortOrder
    colonia?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiaSumOrderByAggregateInput = {
    id?: SortOrder
    limitePrimerPago?: SortOrder
    limitePrimerSubsecuente?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type CompaniaScalarRelationFilter = {
    is?: companiaWhereInput
    isNot?: companiaWhereInput
  }

  export type compania_representantesOrderByRelevanceInput = {
    fields: compania_representantesOrderByRelevanceFieldEnum | compania_representantesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type compania_representantesCountOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    cargo?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type compania_representantesAvgOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
  }

  export type compania_representantesMaxOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    cargo?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type compania_representantesMinOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    cargo?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type compania_representantesSumOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
  }

  export type RamosScalarRelationFilter = {
    is?: ramosWhereInput
    isNot?: ramosWhereInput
  }

  export type companias_productosOrderByRelevanceInput = {
    fields: companias_productosOrderByRelevanceFieldEnum | companias_productosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type companias_productosCountOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
    nombre?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    estatus?: SortOrder
  }

  export type companias_productosAvgOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
  }

  export type companias_productosMaxOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
    nombre?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    estatus?: SortOrder
  }

  export type companias_productosMinOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
    nombre?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    estatus?: SortOrder
  }

  export type companias_productosSumOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
  }

  export type companias_ramosCountOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    estatus?: SortOrder
  }

  export type companias_ramosAvgOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
  }

  export type companias_ramosMaxOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    estatus?: SortOrder
  }

  export type companias_ramosMinOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    estatus?: SortOrder
  }

  export type companias_ramosSumOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    ramo_id?: SortOrder
  }

  export type estadosOrderByRelevanceInput = {
    fields: estadosOrderByRelevanceFieldEnum | estadosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type estadosCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type estadosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type estadosMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type estadosMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type estadosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type estatus_clienteOrderByRelevanceInput = {
    fields: estatus_clienteOrderByRelevanceFieldEnum | estatus_clienteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type estatus_clienteCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type estatus_clienteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type estatus_clienteMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type estatus_clienteMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type estatus_clienteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type estatus_polizasOrderByRelevanceInput = {
    fields: estatus_polizasOrderByRelevanceFieldEnum | estatus_polizasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type estatus_polizasCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type estatus_polizasAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type estatus_polizasMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type estatus_polizasMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type estatus_polizasSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type failed_jobsOrderByRelevanceInput = {
    fields: failed_jobsOrderByRelevanceFieldEnum | failed_jobsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type failed_jobsCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failed_at?: SortOrder
  }

  export type failed_jobsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type failed_jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failed_at?: SortOrder
  }

  export type failed_jobsMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failed_at?: SortOrder
  }

  export type failed_jobsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type formas_de_pagoOrderByRelevanceInput = {
    fields: formas_de_pagoOrderByRelevanceFieldEnum | formas_de_pagoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type formas_de_pagoCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type formas_de_pagoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type formas_de_pagoMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type formas_de_pagoMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type formas_de_pagoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type job_batchesOrderByRelevanceInput = {
    fields: job_batchesOrderByRelevanceFieldEnum | job_batchesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type job_batchesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    failed_job_ids?: SortOrder
    options?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    finished_at?: SortOrder
  }

  export type job_batchesAvgOrderByAggregateInput = {
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    finished_at?: SortOrder
  }

  export type job_batchesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    failed_job_ids?: SortOrder
    options?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    finished_at?: SortOrder
  }

  export type job_batchesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    failed_job_ids?: SortOrder
    options?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    finished_at?: SortOrder
  }

  export type job_batchesSumOrderByAggregateInput = {
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    finished_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type jobsOrderByRelevanceInput = {
    fields: jobsOrderByRelevanceFieldEnum | jobsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type jobsCountOrderByAggregateInput = {
    id?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
  }

  export type jobsAvgOrderByAggregateInput = {
    id?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
  }

  export type jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
  }

  export type jobsMinOrderByAggregateInput = {
    id?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
  }

  export type jobsSumOrderByAggregateInput = {
    id?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
  }

  export type metodos_de_pagoOrderByRelevanceInput = {
    fields: metodos_de_pagoOrderByRelevanceFieldEnum | metodos_de_pagoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type metodos_de_pagoCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type metodos_de_pagoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type metodos_de_pagoMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type metodos_de_pagoMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type metodos_de_pagoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type migrationsOrderByRelevanceInput = {
    fields: migrationsOrderByRelevanceFieldEnum | migrationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type monedasOrderByRelevanceInput = {
    fields: monedasOrderByRelevanceFieldEnum | monedasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type monedasCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type monedasAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type monedasMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type monedasMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type monedasSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type password_reset_tokensOrderByRelevanceInput = {
    fields: password_reset_tokensOrderByRelevanceFieldEnum | password_reset_tokensOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type password_reset_tokensCountOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
  }

  export type password_reset_tokensMaxOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
  }

  export type password_reset_tokensMinOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
  }

  export type personal_access_tokensOrderByRelevanceInput = {
    fields: personal_access_tokensOrderByRelevanceFieldEnum | personal_access_tokensOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type personal_access_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    tokenable_type?: SortOrder
    tokenable_id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrder
    last_used_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type personal_access_tokensAvgOrderByAggregateInput = {
    id?: SortOrder
    tokenable_id?: SortOrder
  }

  export type personal_access_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenable_type?: SortOrder
    tokenable_id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrder
    last_used_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type personal_access_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    tokenable_type?: SortOrder
    tokenable_id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    abilities?: SortOrder
    last_used_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type personal_access_tokensSumOrderByAggregateInput = {
    id?: SortOrder
    tokenable_id?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type poliza_aseguradosOrderByRelevanceInput = {
    fields: poliza_aseguradosOrderByRelevanceFieldEnum | poliza_aseguradosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type poliza_aseguradosCountOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    cliente_id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    colonia?: SortOrder
    codigoPostal?: SortOrder
    estado_id?: SortOrder
    ciudad?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    oficina?: SortOrder
    casa?: SortOrder
    observaciones?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type poliza_aseguradosAvgOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    cliente_id?: SortOrder
    estado_id?: SortOrder
  }

  export type poliza_aseguradosMaxOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    cliente_id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    colonia?: SortOrder
    codigoPostal?: SortOrder
    estado_id?: SortOrder
    ciudad?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    oficina?: SortOrder
    casa?: SortOrder
    observaciones?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type poliza_aseguradosMinOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    cliente_id?: SortOrder
    rfc?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    direccion?: SortOrder
    colonia?: SortOrder
    codigoPostal?: SortOrder
    estado_id?: SortOrder
    ciudad?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    oficina?: SortOrder
    casa?: SortOrder
    observaciones?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type poliza_aseguradosSumOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    cliente_id?: SortOrder
    estado_id?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type poliza_historialOrderByRelevanceInput = {
    fields: poliza_historialOrderByRelevanceFieldEnum | poliza_historialOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type poliza_historialCountOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    accion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type poliza_historialAvgOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
  }

  export type poliza_historialMaxOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    accion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type poliza_historialMinOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    accion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type poliza_historialSumOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Enumpoliza_recibos_estatusFilter<$PrismaModel = never> = {
    equals?: $Enums.poliza_recibos_estatus | Enumpoliza_recibos_estatusFieldRefInput<$PrismaModel>
    in?: $Enums.poliza_recibos_estatus[]
    notIn?: $Enums.poliza_recibos_estatus[]
    not?: NestedEnumpoliza_recibos_estatusFilter<$PrismaModel> | $Enums.poliza_recibos_estatus
  }

  export type PolizasScalarRelationFilter = {
    is?: polizasWhereInput
    isNot?: polizasWhereInput
  }

  export type poliza_recibosOrderByRelevanceInput = {
    fields: poliza_recibosOrderByRelevanceFieldEnum | poliza_recibosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type poliza_recibosCountOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    numeroRecibo?: SortOrder
    vencimiento?: SortOrder
    importe?: SortOrder
    estatus?: SortOrder
    fechaPago?: SortOrder
    fechaCancelado?: SortOrder
    evidencia?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type poliza_recibosAvgOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    importe?: SortOrder
  }

  export type poliza_recibosMaxOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    numeroRecibo?: SortOrder
    vencimiento?: SortOrder
    importe?: SortOrder
    estatus?: SortOrder
    fechaPago?: SortOrder
    fechaCancelado?: SortOrder
    evidencia?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type poliza_recibosMinOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    numeroRecibo?: SortOrder
    vencimiento?: SortOrder
    importe?: SortOrder
    estatus?: SortOrder
    fechaPago?: SortOrder
    fechaCancelado?: SortOrder
    evidencia?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type poliza_recibosSumOrderByAggregateInput = {
    id?: SortOrder
    poliza_id?: SortOrder
    importe?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Enumpoliza_recibos_estatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.poliza_recibos_estatus | Enumpoliza_recibos_estatusFieldRefInput<$PrismaModel>
    in?: $Enums.poliza_recibos_estatus[]
    notIn?: $Enums.poliza_recibos_estatus[]
    not?: NestedEnumpoliza_recibos_estatusWithAggregatesFilter<$PrismaModel> | $Enums.poliza_recibos_estatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpoliza_recibos_estatusFilter<$PrismaModel>
    _max?: NestedEnumpoliza_recibos_estatusFilter<$PrismaModel>
  }

  export type Poliza_recibosListRelationFilter = {
    every?: poliza_recibosWhereInput
    some?: poliza_recibosWhereInput
    none?: poliza_recibosWhereInput
  }

  export type ClientesScalarRelationFilter = {
    is?: clientesWhereInput
    isNot?: clientesWhereInput
  }

  export type Formas_de_pagoScalarRelationFilter = {
    is?: formas_de_pagoWhereInput
    isNot?: formas_de_pagoWhereInput
  }

  export type Metodos_de_pagoScalarRelationFilter = {
    is?: metodos_de_pagoWhereInput
    isNot?: metodos_de_pagoWhereInput
  }

  export type MonedasScalarRelationFilter = {
    is?: monedasWhereInput
    isNot?: monedasWhereInput
  }

  export type Companias_productosScalarRelationFilter = {
    is?: companias_productosWhereInput
    isNot?: companias_productosWhereInput
  }

  export type UsuariosNullableScalarRelationFilter = {
    is?: usuariosWhereInput | null
    isNot?: usuariosWhereInput | null
  }

  export type Tipos_de_vencimientoScalarRelationFilter = {
    is?: tipos_de_vencimientoWhereInput
    isNot?: tipos_de_vencimientoWhereInput
  }

  export type poliza_recibosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type polizasOrderByRelevanceInput = {
    fields: polizasOrderByRelevanceFieldEnum | polizasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type polizasCountOrderByAggregateInput = {
    id?: SortOrder
    numeroPoliza?: SortOrder
    numeroCliente?: SortOrder
    inicioVigencia?: SortOrder
    finVigencia?: SortOrder
    antiguedad?: SortOrder
    primaNeta?: SortOrder
    financiamiento?: SortOrder
    primaTotal?: SortOrder
    estatus_id?: SortOrder
    comisionAgente?: SortOrder
    pagoInicial?: SortOrder
    pagoSubsecuente?: SortOrder
    cliente_id?: SortOrder
    formaPago_id?: SortOrder
    tipoVencimiento_id?: SortOrder
    compania_id?: SortOrder
    subAgente_id?: SortOrder
    ramo_id?: SortOrder
    metodoPago_id?: SortOrder
    moneda_id?: SortOrder
    producto_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type polizasAvgOrderByAggregateInput = {
    id?: SortOrder
    antiguedad?: SortOrder
    primaNeta?: SortOrder
    financiamiento?: SortOrder
    primaTotal?: SortOrder
    estatus_id?: SortOrder
    comisionAgente?: SortOrder
    pagoInicial?: SortOrder
    pagoSubsecuente?: SortOrder
    cliente_id?: SortOrder
    formaPago_id?: SortOrder
    tipoVencimiento_id?: SortOrder
    compania_id?: SortOrder
    subAgente_id?: SortOrder
    ramo_id?: SortOrder
    metodoPago_id?: SortOrder
    moneda_id?: SortOrder
    producto_id?: SortOrder
  }

  export type polizasMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroPoliza?: SortOrder
    numeroCliente?: SortOrder
    inicioVigencia?: SortOrder
    finVigencia?: SortOrder
    antiguedad?: SortOrder
    primaNeta?: SortOrder
    financiamiento?: SortOrder
    primaTotal?: SortOrder
    estatus_id?: SortOrder
    comisionAgente?: SortOrder
    pagoInicial?: SortOrder
    pagoSubsecuente?: SortOrder
    cliente_id?: SortOrder
    formaPago_id?: SortOrder
    tipoVencimiento_id?: SortOrder
    compania_id?: SortOrder
    subAgente_id?: SortOrder
    ramo_id?: SortOrder
    metodoPago_id?: SortOrder
    moneda_id?: SortOrder
    producto_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type polizasMinOrderByAggregateInput = {
    id?: SortOrder
    numeroPoliza?: SortOrder
    numeroCliente?: SortOrder
    inicioVigencia?: SortOrder
    finVigencia?: SortOrder
    antiguedad?: SortOrder
    primaNeta?: SortOrder
    financiamiento?: SortOrder
    primaTotal?: SortOrder
    estatus_id?: SortOrder
    comisionAgente?: SortOrder
    pagoInicial?: SortOrder
    pagoSubsecuente?: SortOrder
    cliente_id?: SortOrder
    formaPago_id?: SortOrder
    tipoVencimiento_id?: SortOrder
    compania_id?: SortOrder
    subAgente_id?: SortOrder
    ramo_id?: SortOrder
    metodoPago_id?: SortOrder
    moneda_id?: SortOrder
    producto_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type polizasSumOrderByAggregateInput = {
    id?: SortOrder
    antiguedad?: SortOrder
    primaNeta?: SortOrder
    financiamiento?: SortOrder
    primaTotal?: SortOrder
    estatus_id?: SortOrder
    comisionAgente?: SortOrder
    pagoInicial?: SortOrder
    pagoSubsecuente?: SortOrder
    cliente_id?: SortOrder
    formaPago_id?: SortOrder
    tipoVencimiento_id?: SortOrder
    compania_id?: SortOrder
    subAgente_id?: SortOrder
    ramo_id?: SortOrder
    metodoPago_id?: SortOrder
    moneda_id?: SortOrder
    producto_id?: SortOrder
  }

  export type ramosOrderByRelevanceInput = {
    fields: ramosOrderByRelevanceFieldEnum | ramosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ramosCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ramosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ramosMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ramosMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ramosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sessionsOrderByRelevanceInput = {
    fields: sessionsOrderByRelevanceFieldEnum | sessionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type sessionsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    last_activity?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type sessionsSumOrderByAggregateInput = {
    user_id?: SortOrder
    last_activity?: SortOrder
  }

  export type Usuario_teamListRelationFilter = {
    every?: usuario_teamWhereInput
    some?: usuario_teamWhereInput
    none?: usuario_teamWhereInput
  }

  export type usuario_teamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tipos_de_usuariosOrderByRelevanceInput = {
    fields: tipos_de_usuariosOrderByRelevanceFieldEnum | tipos_de_usuariosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tipos_de_usuariosCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type tipos_de_usuariosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipos_de_usuariosMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type tipos_de_usuariosMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type tipos_de_usuariosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipos_de_vencimientoOrderByRelevanceInput = {
    fields: tipos_de_vencimientoOrderByRelevanceFieldEnum | tipos_de_vencimientoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tipos_de_vencimientoCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type tipos_de_vencimientoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipos_de_vencimientoMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type tipos_de_vencimientoMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type tipos_de_vencimientoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersOrderByRelevanceInput = {
    fields: usersOrderByRelevanceFieldEnum | usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    remember_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    remember_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    remember_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario_clavesOrderByRelevanceInput = {
    fields: usuario_clavesOrderByRelevanceFieldEnum | usuario_clavesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usuario_clavesCountOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    clave?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    usuario_id?: SortOrder
  }

  export type usuario_clavesAvgOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type usuario_clavesMaxOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    clave?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    usuario_id?: SortOrder
  }

  export type usuario_clavesMinOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    clave?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    usuario_id?: SortOrder
  }

  export type usuario_clavesSumOrderByAggregateInput = {
    id?: SortOrder
    compania_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type Tipos_de_usuariosScalarRelationFilter = {
    is?: tipos_de_usuariosWhereInput
    isNot?: tipos_de_usuariosWhereInput
  }

  export type UsuariosScalarRelationFilter = {
    is?: usuariosWhereInput
    isNot?: usuariosWhereInput
  }

  export type usuario_teamCountOrderByAggregateInput = {
    id?: SortOrder
    principal_id?: SortOrder
    tipo_id?: SortOrder
    usuario_id?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuario_teamAvgOrderByAggregateInput = {
    id?: SortOrder
    principal_id?: SortOrder
    tipo_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type usuario_teamMaxOrderByAggregateInput = {
    id?: SortOrder
    principal_id?: SortOrder
    tipo_id?: SortOrder
    usuario_id?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuario_teamMinOrderByAggregateInput = {
    id?: SortOrder
    principal_id?: SortOrder
    tipo_id?: SortOrder
    usuario_id?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuario_teamSumOrderByAggregateInput = {
    id?: SortOrder
    principal_id?: SortOrder
    tipo_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type usuariosOrderByRelevanceInput = {
    fields: usuariosOrderByRelevanceFieldEnum | usuariosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usuariosCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    tipo_id?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuariosAvgOrderByAggregateInput = {
    id?: SortOrder
    tipo_id?: SortOrder
  }

  export type usuariosMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    tipo_id?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuariosMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    tipo_id?: SortOrder
    estatus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuariosSumOrderByAggregateInput = {
    id?: SortOrder
    tipo_id?: SortOrder
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type polizasCreateNestedManyWithoutClientesInput = {
    create?: XOR<polizasCreateWithoutClientesInput, polizasUncheckedCreateWithoutClientesInput> | polizasCreateWithoutClientesInput[] | polizasUncheckedCreateWithoutClientesInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutClientesInput | polizasCreateOrConnectWithoutClientesInput[]
    createMany?: polizasCreateManyClientesInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type polizasUncheckedCreateNestedManyWithoutClientesInput = {
    create?: XOR<polizasCreateWithoutClientesInput, polizasUncheckedCreateWithoutClientesInput> | polizasCreateWithoutClientesInput[] | polizasUncheckedCreateWithoutClientesInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutClientesInput | polizasCreateOrConnectWithoutClientesInput[]
    createMany?: polizasCreateManyClientesInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type polizasUpdateManyWithoutClientesNestedInput = {
    create?: XOR<polizasCreateWithoutClientesInput, polizasUncheckedCreateWithoutClientesInput> | polizasCreateWithoutClientesInput[] | polizasUncheckedCreateWithoutClientesInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutClientesInput | polizasCreateOrConnectWithoutClientesInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutClientesInput | polizasUpsertWithWhereUniqueWithoutClientesInput[]
    createMany?: polizasCreateManyClientesInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutClientesInput | polizasUpdateWithWhereUniqueWithoutClientesInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutClientesInput | polizasUpdateManyWithWhereWithoutClientesInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type polizasUncheckedUpdateManyWithoutClientesNestedInput = {
    create?: XOR<polizasCreateWithoutClientesInput, polizasUncheckedCreateWithoutClientesInput> | polizasCreateWithoutClientesInput[] | polizasUncheckedCreateWithoutClientesInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutClientesInput | polizasCreateOrConnectWithoutClientesInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutClientesInput | polizasUpsertWithWhereUniqueWithoutClientesInput[]
    createMany?: polizasCreateManyClientesInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutClientesInput | polizasUpdateWithWhereUniqueWithoutClientesInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutClientesInput | polizasUpdateManyWithWhereWithoutClientesInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type compania_representantesCreateNestedManyWithoutCompaniaInput = {
    create?: XOR<compania_representantesCreateWithoutCompaniaInput, compania_representantesUncheckedCreateWithoutCompaniaInput> | compania_representantesCreateWithoutCompaniaInput[] | compania_representantesUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: compania_representantesCreateOrConnectWithoutCompaniaInput | compania_representantesCreateOrConnectWithoutCompaniaInput[]
    createMany?: compania_representantesCreateManyCompaniaInputEnvelope
    connect?: compania_representantesWhereUniqueInput | compania_representantesWhereUniqueInput[]
  }

  export type companias_productosCreateNestedManyWithoutCompaniaInput = {
    create?: XOR<companias_productosCreateWithoutCompaniaInput, companias_productosUncheckedCreateWithoutCompaniaInput> | companias_productosCreateWithoutCompaniaInput[] | companias_productosUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: companias_productosCreateOrConnectWithoutCompaniaInput | companias_productosCreateOrConnectWithoutCompaniaInput[]
    createMany?: companias_productosCreateManyCompaniaInputEnvelope
    connect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
  }

  export type companias_ramosCreateNestedManyWithoutCompaniaInput = {
    create?: XOR<companias_ramosCreateWithoutCompaniaInput, companias_ramosUncheckedCreateWithoutCompaniaInput> | companias_ramosCreateWithoutCompaniaInput[] | companias_ramosUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: companias_ramosCreateOrConnectWithoutCompaniaInput | companias_ramosCreateOrConnectWithoutCompaniaInput[]
    createMany?: companias_ramosCreateManyCompaniaInputEnvelope
    connect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
  }

  export type polizasCreateNestedManyWithoutCompaniaInput = {
    create?: XOR<polizasCreateWithoutCompaniaInput, polizasUncheckedCreateWithoutCompaniaInput> | polizasCreateWithoutCompaniaInput[] | polizasUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutCompaniaInput | polizasCreateOrConnectWithoutCompaniaInput[]
    createMany?: polizasCreateManyCompaniaInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type usuario_clavesCreateNestedManyWithoutCompaniaInput = {
    create?: XOR<usuario_clavesCreateWithoutCompaniaInput, usuario_clavesUncheckedCreateWithoutCompaniaInput> | usuario_clavesCreateWithoutCompaniaInput[] | usuario_clavesUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: usuario_clavesCreateOrConnectWithoutCompaniaInput | usuario_clavesCreateOrConnectWithoutCompaniaInput[]
    createMany?: usuario_clavesCreateManyCompaniaInputEnvelope
    connect?: usuario_clavesWhereUniqueInput | usuario_clavesWhereUniqueInput[]
  }

  export type compania_representantesUncheckedCreateNestedManyWithoutCompaniaInput = {
    create?: XOR<compania_representantesCreateWithoutCompaniaInput, compania_representantesUncheckedCreateWithoutCompaniaInput> | compania_representantesCreateWithoutCompaniaInput[] | compania_representantesUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: compania_representantesCreateOrConnectWithoutCompaniaInput | compania_representantesCreateOrConnectWithoutCompaniaInput[]
    createMany?: compania_representantesCreateManyCompaniaInputEnvelope
    connect?: compania_representantesWhereUniqueInput | compania_representantesWhereUniqueInput[]
  }

  export type companias_productosUncheckedCreateNestedManyWithoutCompaniaInput = {
    create?: XOR<companias_productosCreateWithoutCompaniaInput, companias_productosUncheckedCreateWithoutCompaniaInput> | companias_productosCreateWithoutCompaniaInput[] | companias_productosUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: companias_productosCreateOrConnectWithoutCompaniaInput | companias_productosCreateOrConnectWithoutCompaniaInput[]
    createMany?: companias_productosCreateManyCompaniaInputEnvelope
    connect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
  }

  export type companias_ramosUncheckedCreateNestedManyWithoutCompaniaInput = {
    create?: XOR<companias_ramosCreateWithoutCompaniaInput, companias_ramosUncheckedCreateWithoutCompaniaInput> | companias_ramosCreateWithoutCompaniaInput[] | companias_ramosUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: companias_ramosCreateOrConnectWithoutCompaniaInput | companias_ramosCreateOrConnectWithoutCompaniaInput[]
    createMany?: companias_ramosCreateManyCompaniaInputEnvelope
    connect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
  }

  export type polizasUncheckedCreateNestedManyWithoutCompaniaInput = {
    create?: XOR<polizasCreateWithoutCompaniaInput, polizasUncheckedCreateWithoutCompaniaInput> | polizasCreateWithoutCompaniaInput[] | polizasUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutCompaniaInput | polizasCreateOrConnectWithoutCompaniaInput[]
    createMany?: polizasCreateManyCompaniaInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type usuario_clavesUncheckedCreateNestedManyWithoutCompaniaInput = {
    create?: XOR<usuario_clavesCreateWithoutCompaniaInput, usuario_clavesUncheckedCreateWithoutCompaniaInput> | usuario_clavesCreateWithoutCompaniaInput[] | usuario_clavesUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: usuario_clavesCreateOrConnectWithoutCompaniaInput | usuario_clavesCreateOrConnectWithoutCompaniaInput[]
    createMany?: usuario_clavesCreateManyCompaniaInputEnvelope
    connect?: usuario_clavesWhereUniqueInput | usuario_clavesWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type compania_representantesUpdateManyWithoutCompaniaNestedInput = {
    create?: XOR<compania_representantesCreateWithoutCompaniaInput, compania_representantesUncheckedCreateWithoutCompaniaInput> | compania_representantesCreateWithoutCompaniaInput[] | compania_representantesUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: compania_representantesCreateOrConnectWithoutCompaniaInput | compania_representantesCreateOrConnectWithoutCompaniaInput[]
    upsert?: compania_representantesUpsertWithWhereUniqueWithoutCompaniaInput | compania_representantesUpsertWithWhereUniqueWithoutCompaniaInput[]
    createMany?: compania_representantesCreateManyCompaniaInputEnvelope
    set?: compania_representantesWhereUniqueInput | compania_representantesWhereUniqueInput[]
    disconnect?: compania_representantesWhereUniqueInput | compania_representantesWhereUniqueInput[]
    delete?: compania_representantesWhereUniqueInput | compania_representantesWhereUniqueInput[]
    connect?: compania_representantesWhereUniqueInput | compania_representantesWhereUniqueInput[]
    update?: compania_representantesUpdateWithWhereUniqueWithoutCompaniaInput | compania_representantesUpdateWithWhereUniqueWithoutCompaniaInput[]
    updateMany?: compania_representantesUpdateManyWithWhereWithoutCompaniaInput | compania_representantesUpdateManyWithWhereWithoutCompaniaInput[]
    deleteMany?: compania_representantesScalarWhereInput | compania_representantesScalarWhereInput[]
  }

  export type companias_productosUpdateManyWithoutCompaniaNestedInput = {
    create?: XOR<companias_productosCreateWithoutCompaniaInput, companias_productosUncheckedCreateWithoutCompaniaInput> | companias_productosCreateWithoutCompaniaInput[] | companias_productosUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: companias_productosCreateOrConnectWithoutCompaniaInput | companias_productosCreateOrConnectWithoutCompaniaInput[]
    upsert?: companias_productosUpsertWithWhereUniqueWithoutCompaniaInput | companias_productosUpsertWithWhereUniqueWithoutCompaniaInput[]
    createMany?: companias_productosCreateManyCompaniaInputEnvelope
    set?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    disconnect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    delete?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    connect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    update?: companias_productosUpdateWithWhereUniqueWithoutCompaniaInput | companias_productosUpdateWithWhereUniqueWithoutCompaniaInput[]
    updateMany?: companias_productosUpdateManyWithWhereWithoutCompaniaInput | companias_productosUpdateManyWithWhereWithoutCompaniaInput[]
    deleteMany?: companias_productosScalarWhereInput | companias_productosScalarWhereInput[]
  }

  export type companias_ramosUpdateManyWithoutCompaniaNestedInput = {
    create?: XOR<companias_ramosCreateWithoutCompaniaInput, companias_ramosUncheckedCreateWithoutCompaniaInput> | companias_ramosCreateWithoutCompaniaInput[] | companias_ramosUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: companias_ramosCreateOrConnectWithoutCompaniaInput | companias_ramosCreateOrConnectWithoutCompaniaInput[]
    upsert?: companias_ramosUpsertWithWhereUniqueWithoutCompaniaInput | companias_ramosUpsertWithWhereUniqueWithoutCompaniaInput[]
    createMany?: companias_ramosCreateManyCompaniaInputEnvelope
    set?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    disconnect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    delete?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    connect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    update?: companias_ramosUpdateWithWhereUniqueWithoutCompaniaInput | companias_ramosUpdateWithWhereUniqueWithoutCompaniaInput[]
    updateMany?: companias_ramosUpdateManyWithWhereWithoutCompaniaInput | companias_ramosUpdateManyWithWhereWithoutCompaniaInput[]
    deleteMany?: companias_ramosScalarWhereInput | companias_ramosScalarWhereInput[]
  }

  export type polizasUpdateManyWithoutCompaniaNestedInput = {
    create?: XOR<polizasCreateWithoutCompaniaInput, polizasUncheckedCreateWithoutCompaniaInput> | polizasCreateWithoutCompaniaInput[] | polizasUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutCompaniaInput | polizasCreateOrConnectWithoutCompaniaInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutCompaniaInput | polizasUpsertWithWhereUniqueWithoutCompaniaInput[]
    createMany?: polizasCreateManyCompaniaInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutCompaniaInput | polizasUpdateWithWhereUniqueWithoutCompaniaInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutCompaniaInput | polizasUpdateManyWithWhereWithoutCompaniaInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type usuario_clavesUpdateManyWithoutCompaniaNestedInput = {
    create?: XOR<usuario_clavesCreateWithoutCompaniaInput, usuario_clavesUncheckedCreateWithoutCompaniaInput> | usuario_clavesCreateWithoutCompaniaInput[] | usuario_clavesUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: usuario_clavesCreateOrConnectWithoutCompaniaInput | usuario_clavesCreateOrConnectWithoutCompaniaInput[]
    upsert?: usuario_clavesUpsertWithWhereUniqueWithoutCompaniaInput | usuario_clavesUpsertWithWhereUniqueWithoutCompaniaInput[]
    createMany?: usuario_clavesCreateManyCompaniaInputEnvelope
    set?: usuario_clavesWhereUniqueInput | usuario_clavesWhereUniqueInput[]
    disconnect?: usuario_clavesWhereUniqueInput | usuario_clavesWhereUniqueInput[]
    delete?: usuario_clavesWhereUniqueInput | usuario_clavesWhereUniqueInput[]
    connect?: usuario_clavesWhereUniqueInput | usuario_clavesWhereUniqueInput[]
    update?: usuario_clavesUpdateWithWhereUniqueWithoutCompaniaInput | usuario_clavesUpdateWithWhereUniqueWithoutCompaniaInput[]
    updateMany?: usuario_clavesUpdateManyWithWhereWithoutCompaniaInput | usuario_clavesUpdateManyWithWhereWithoutCompaniaInput[]
    deleteMany?: usuario_clavesScalarWhereInput | usuario_clavesScalarWhereInput[]
  }

  export type compania_representantesUncheckedUpdateManyWithoutCompaniaNestedInput = {
    create?: XOR<compania_representantesCreateWithoutCompaniaInput, compania_representantesUncheckedCreateWithoutCompaniaInput> | compania_representantesCreateWithoutCompaniaInput[] | compania_representantesUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: compania_representantesCreateOrConnectWithoutCompaniaInput | compania_representantesCreateOrConnectWithoutCompaniaInput[]
    upsert?: compania_representantesUpsertWithWhereUniqueWithoutCompaniaInput | compania_representantesUpsertWithWhereUniqueWithoutCompaniaInput[]
    createMany?: compania_representantesCreateManyCompaniaInputEnvelope
    set?: compania_representantesWhereUniqueInput | compania_representantesWhereUniqueInput[]
    disconnect?: compania_representantesWhereUniqueInput | compania_representantesWhereUniqueInput[]
    delete?: compania_representantesWhereUniqueInput | compania_representantesWhereUniqueInput[]
    connect?: compania_representantesWhereUniqueInput | compania_representantesWhereUniqueInput[]
    update?: compania_representantesUpdateWithWhereUniqueWithoutCompaniaInput | compania_representantesUpdateWithWhereUniqueWithoutCompaniaInput[]
    updateMany?: compania_representantesUpdateManyWithWhereWithoutCompaniaInput | compania_representantesUpdateManyWithWhereWithoutCompaniaInput[]
    deleteMany?: compania_representantesScalarWhereInput | compania_representantesScalarWhereInput[]
  }

  export type companias_productosUncheckedUpdateManyWithoutCompaniaNestedInput = {
    create?: XOR<companias_productosCreateWithoutCompaniaInput, companias_productosUncheckedCreateWithoutCompaniaInput> | companias_productosCreateWithoutCompaniaInput[] | companias_productosUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: companias_productosCreateOrConnectWithoutCompaniaInput | companias_productosCreateOrConnectWithoutCompaniaInput[]
    upsert?: companias_productosUpsertWithWhereUniqueWithoutCompaniaInput | companias_productosUpsertWithWhereUniqueWithoutCompaniaInput[]
    createMany?: companias_productosCreateManyCompaniaInputEnvelope
    set?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    disconnect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    delete?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    connect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    update?: companias_productosUpdateWithWhereUniqueWithoutCompaniaInput | companias_productosUpdateWithWhereUniqueWithoutCompaniaInput[]
    updateMany?: companias_productosUpdateManyWithWhereWithoutCompaniaInput | companias_productosUpdateManyWithWhereWithoutCompaniaInput[]
    deleteMany?: companias_productosScalarWhereInput | companias_productosScalarWhereInput[]
  }

  export type companias_ramosUncheckedUpdateManyWithoutCompaniaNestedInput = {
    create?: XOR<companias_ramosCreateWithoutCompaniaInput, companias_ramosUncheckedCreateWithoutCompaniaInput> | companias_ramosCreateWithoutCompaniaInput[] | companias_ramosUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: companias_ramosCreateOrConnectWithoutCompaniaInput | companias_ramosCreateOrConnectWithoutCompaniaInput[]
    upsert?: companias_ramosUpsertWithWhereUniqueWithoutCompaniaInput | companias_ramosUpsertWithWhereUniqueWithoutCompaniaInput[]
    createMany?: companias_ramosCreateManyCompaniaInputEnvelope
    set?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    disconnect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    delete?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    connect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    update?: companias_ramosUpdateWithWhereUniqueWithoutCompaniaInput | companias_ramosUpdateWithWhereUniqueWithoutCompaniaInput[]
    updateMany?: companias_ramosUpdateManyWithWhereWithoutCompaniaInput | companias_ramosUpdateManyWithWhereWithoutCompaniaInput[]
    deleteMany?: companias_ramosScalarWhereInput | companias_ramosScalarWhereInput[]
  }

  export type polizasUncheckedUpdateManyWithoutCompaniaNestedInput = {
    create?: XOR<polizasCreateWithoutCompaniaInput, polizasUncheckedCreateWithoutCompaniaInput> | polizasCreateWithoutCompaniaInput[] | polizasUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutCompaniaInput | polizasCreateOrConnectWithoutCompaniaInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutCompaniaInput | polizasUpsertWithWhereUniqueWithoutCompaniaInput[]
    createMany?: polizasCreateManyCompaniaInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutCompaniaInput | polizasUpdateWithWhereUniqueWithoutCompaniaInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutCompaniaInput | polizasUpdateManyWithWhereWithoutCompaniaInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type usuario_clavesUncheckedUpdateManyWithoutCompaniaNestedInput = {
    create?: XOR<usuario_clavesCreateWithoutCompaniaInput, usuario_clavesUncheckedCreateWithoutCompaniaInput> | usuario_clavesCreateWithoutCompaniaInput[] | usuario_clavesUncheckedCreateWithoutCompaniaInput[]
    connectOrCreate?: usuario_clavesCreateOrConnectWithoutCompaniaInput | usuario_clavesCreateOrConnectWithoutCompaniaInput[]
    upsert?: usuario_clavesUpsertWithWhereUniqueWithoutCompaniaInput | usuario_clavesUpsertWithWhereUniqueWithoutCompaniaInput[]
    createMany?: usuario_clavesCreateManyCompaniaInputEnvelope
    set?: usuario_clavesWhereUniqueInput | usuario_clavesWhereUniqueInput[]
    disconnect?: usuario_clavesWhereUniqueInput | usuario_clavesWhereUniqueInput[]
    delete?: usuario_clavesWhereUniqueInput | usuario_clavesWhereUniqueInput[]
    connect?: usuario_clavesWhereUniqueInput | usuario_clavesWhereUniqueInput[]
    update?: usuario_clavesUpdateWithWhereUniqueWithoutCompaniaInput | usuario_clavesUpdateWithWhereUniqueWithoutCompaniaInput[]
    updateMany?: usuario_clavesUpdateManyWithWhereWithoutCompaniaInput | usuario_clavesUpdateManyWithWhereWithoutCompaniaInput[]
    deleteMany?: usuario_clavesScalarWhereInput | usuario_clavesScalarWhereInput[]
  }

  export type companiaCreateNestedOneWithoutCompania_representantesInput = {
    create?: XOR<companiaCreateWithoutCompania_representantesInput, companiaUncheckedCreateWithoutCompania_representantesInput>
    connectOrCreate?: companiaCreateOrConnectWithoutCompania_representantesInput
    connect?: companiaWhereUniqueInput
  }

  export type companiaUpdateOneRequiredWithoutCompania_representantesNestedInput = {
    create?: XOR<companiaCreateWithoutCompania_representantesInput, companiaUncheckedCreateWithoutCompania_representantesInput>
    connectOrCreate?: companiaCreateOrConnectWithoutCompania_representantesInput
    upsert?: companiaUpsertWithoutCompania_representantesInput
    connect?: companiaWhereUniqueInput
    update?: XOR<XOR<companiaUpdateToOneWithWhereWithoutCompania_representantesInput, companiaUpdateWithoutCompania_representantesInput>, companiaUncheckedUpdateWithoutCompania_representantesInput>
  }

  export type companiaCreateNestedOneWithoutCompanias_productosInput = {
    create?: XOR<companiaCreateWithoutCompanias_productosInput, companiaUncheckedCreateWithoutCompanias_productosInput>
    connectOrCreate?: companiaCreateOrConnectWithoutCompanias_productosInput
    connect?: companiaWhereUniqueInput
  }

  export type ramosCreateNestedOneWithoutCompanias_productosInput = {
    create?: XOR<ramosCreateWithoutCompanias_productosInput, ramosUncheckedCreateWithoutCompanias_productosInput>
    connectOrCreate?: ramosCreateOrConnectWithoutCompanias_productosInput
    connect?: ramosWhereUniqueInput
  }

  export type polizasCreateNestedManyWithoutCompanias_productosInput = {
    create?: XOR<polizasCreateWithoutCompanias_productosInput, polizasUncheckedCreateWithoutCompanias_productosInput> | polizasCreateWithoutCompanias_productosInput[] | polizasUncheckedCreateWithoutCompanias_productosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutCompanias_productosInput | polizasCreateOrConnectWithoutCompanias_productosInput[]
    createMany?: polizasCreateManyCompanias_productosInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type polizasUncheckedCreateNestedManyWithoutCompanias_productosInput = {
    create?: XOR<polizasCreateWithoutCompanias_productosInput, polizasUncheckedCreateWithoutCompanias_productosInput> | polizasCreateWithoutCompanias_productosInput[] | polizasUncheckedCreateWithoutCompanias_productosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutCompanias_productosInput | polizasCreateOrConnectWithoutCompanias_productosInput[]
    createMany?: polizasCreateManyCompanias_productosInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type companiaUpdateOneRequiredWithoutCompanias_productosNestedInput = {
    create?: XOR<companiaCreateWithoutCompanias_productosInput, companiaUncheckedCreateWithoutCompanias_productosInput>
    connectOrCreate?: companiaCreateOrConnectWithoutCompanias_productosInput
    upsert?: companiaUpsertWithoutCompanias_productosInput
    connect?: companiaWhereUniqueInput
    update?: XOR<XOR<companiaUpdateToOneWithWhereWithoutCompanias_productosInput, companiaUpdateWithoutCompanias_productosInput>, companiaUncheckedUpdateWithoutCompanias_productosInput>
  }

  export type ramosUpdateOneRequiredWithoutCompanias_productosNestedInput = {
    create?: XOR<ramosCreateWithoutCompanias_productosInput, ramosUncheckedCreateWithoutCompanias_productosInput>
    connectOrCreate?: ramosCreateOrConnectWithoutCompanias_productosInput
    upsert?: ramosUpsertWithoutCompanias_productosInput
    connect?: ramosWhereUniqueInput
    update?: XOR<XOR<ramosUpdateToOneWithWhereWithoutCompanias_productosInput, ramosUpdateWithoutCompanias_productosInput>, ramosUncheckedUpdateWithoutCompanias_productosInput>
  }

  export type polizasUpdateManyWithoutCompanias_productosNestedInput = {
    create?: XOR<polizasCreateWithoutCompanias_productosInput, polizasUncheckedCreateWithoutCompanias_productosInput> | polizasCreateWithoutCompanias_productosInput[] | polizasUncheckedCreateWithoutCompanias_productosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutCompanias_productosInput | polizasCreateOrConnectWithoutCompanias_productosInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutCompanias_productosInput | polizasUpsertWithWhereUniqueWithoutCompanias_productosInput[]
    createMany?: polizasCreateManyCompanias_productosInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutCompanias_productosInput | polizasUpdateWithWhereUniqueWithoutCompanias_productosInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutCompanias_productosInput | polizasUpdateManyWithWhereWithoutCompanias_productosInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type polizasUncheckedUpdateManyWithoutCompanias_productosNestedInput = {
    create?: XOR<polizasCreateWithoutCompanias_productosInput, polizasUncheckedCreateWithoutCompanias_productosInput> | polizasCreateWithoutCompanias_productosInput[] | polizasUncheckedCreateWithoutCompanias_productosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutCompanias_productosInput | polizasCreateOrConnectWithoutCompanias_productosInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutCompanias_productosInput | polizasUpsertWithWhereUniqueWithoutCompanias_productosInput[]
    createMany?: polizasCreateManyCompanias_productosInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutCompanias_productosInput | polizasUpdateWithWhereUniqueWithoutCompanias_productosInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutCompanias_productosInput | polizasUpdateManyWithWhereWithoutCompanias_productosInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type companiaCreateNestedOneWithoutCompanias_ramosInput = {
    create?: XOR<companiaCreateWithoutCompanias_ramosInput, companiaUncheckedCreateWithoutCompanias_ramosInput>
    connectOrCreate?: companiaCreateOrConnectWithoutCompanias_ramosInput
    connect?: companiaWhereUniqueInput
  }

  export type ramosCreateNestedOneWithoutCompanias_ramosInput = {
    create?: XOR<ramosCreateWithoutCompanias_ramosInput, ramosUncheckedCreateWithoutCompanias_ramosInput>
    connectOrCreate?: ramosCreateOrConnectWithoutCompanias_ramosInput
    connect?: ramosWhereUniqueInput
  }

  export type companiaUpdateOneRequiredWithoutCompanias_ramosNestedInput = {
    create?: XOR<companiaCreateWithoutCompanias_ramosInput, companiaUncheckedCreateWithoutCompanias_ramosInput>
    connectOrCreate?: companiaCreateOrConnectWithoutCompanias_ramosInput
    upsert?: companiaUpsertWithoutCompanias_ramosInput
    connect?: companiaWhereUniqueInput
    update?: XOR<XOR<companiaUpdateToOneWithWhereWithoutCompanias_ramosInput, companiaUpdateWithoutCompanias_ramosInput>, companiaUncheckedUpdateWithoutCompanias_ramosInput>
  }

  export type ramosUpdateOneRequiredWithoutCompanias_ramosNestedInput = {
    create?: XOR<ramosCreateWithoutCompanias_ramosInput, ramosUncheckedCreateWithoutCompanias_ramosInput>
    connectOrCreate?: ramosCreateOrConnectWithoutCompanias_ramosInput
    upsert?: ramosUpsertWithoutCompanias_ramosInput
    connect?: ramosWhereUniqueInput
    update?: XOR<XOR<ramosUpdateToOneWithWhereWithoutCompanias_ramosInput, ramosUpdateWithoutCompanias_ramosInput>, ramosUncheckedUpdateWithoutCompanias_ramosInput>
  }

  export type polizasCreateNestedManyWithoutFormas_de_pagoInput = {
    create?: XOR<polizasCreateWithoutFormas_de_pagoInput, polizasUncheckedCreateWithoutFormas_de_pagoInput> | polizasCreateWithoutFormas_de_pagoInput[] | polizasUncheckedCreateWithoutFormas_de_pagoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutFormas_de_pagoInput | polizasCreateOrConnectWithoutFormas_de_pagoInput[]
    createMany?: polizasCreateManyFormas_de_pagoInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type polizasUncheckedCreateNestedManyWithoutFormas_de_pagoInput = {
    create?: XOR<polizasCreateWithoutFormas_de_pagoInput, polizasUncheckedCreateWithoutFormas_de_pagoInput> | polizasCreateWithoutFormas_de_pagoInput[] | polizasUncheckedCreateWithoutFormas_de_pagoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutFormas_de_pagoInput | polizasCreateOrConnectWithoutFormas_de_pagoInput[]
    createMany?: polizasCreateManyFormas_de_pagoInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type polizasUpdateManyWithoutFormas_de_pagoNestedInput = {
    create?: XOR<polizasCreateWithoutFormas_de_pagoInput, polizasUncheckedCreateWithoutFormas_de_pagoInput> | polizasCreateWithoutFormas_de_pagoInput[] | polizasUncheckedCreateWithoutFormas_de_pagoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutFormas_de_pagoInput | polizasCreateOrConnectWithoutFormas_de_pagoInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutFormas_de_pagoInput | polizasUpsertWithWhereUniqueWithoutFormas_de_pagoInput[]
    createMany?: polizasCreateManyFormas_de_pagoInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutFormas_de_pagoInput | polizasUpdateWithWhereUniqueWithoutFormas_de_pagoInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutFormas_de_pagoInput | polizasUpdateManyWithWhereWithoutFormas_de_pagoInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type polizasUncheckedUpdateManyWithoutFormas_de_pagoNestedInput = {
    create?: XOR<polizasCreateWithoutFormas_de_pagoInput, polizasUncheckedCreateWithoutFormas_de_pagoInput> | polizasCreateWithoutFormas_de_pagoInput[] | polizasUncheckedCreateWithoutFormas_de_pagoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutFormas_de_pagoInput | polizasCreateOrConnectWithoutFormas_de_pagoInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutFormas_de_pagoInput | polizasUpsertWithWhereUniqueWithoutFormas_de_pagoInput[]
    createMany?: polizasCreateManyFormas_de_pagoInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutFormas_de_pagoInput | polizasUpdateWithWhereUniqueWithoutFormas_de_pagoInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutFormas_de_pagoInput | polizasUpdateManyWithWhereWithoutFormas_de_pagoInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type polizasCreateNestedManyWithoutMetodos_de_pagoInput = {
    create?: XOR<polizasCreateWithoutMetodos_de_pagoInput, polizasUncheckedCreateWithoutMetodos_de_pagoInput> | polizasCreateWithoutMetodos_de_pagoInput[] | polizasUncheckedCreateWithoutMetodos_de_pagoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutMetodos_de_pagoInput | polizasCreateOrConnectWithoutMetodos_de_pagoInput[]
    createMany?: polizasCreateManyMetodos_de_pagoInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type polizasUncheckedCreateNestedManyWithoutMetodos_de_pagoInput = {
    create?: XOR<polizasCreateWithoutMetodos_de_pagoInput, polizasUncheckedCreateWithoutMetodos_de_pagoInput> | polizasCreateWithoutMetodos_de_pagoInput[] | polizasUncheckedCreateWithoutMetodos_de_pagoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutMetodos_de_pagoInput | polizasCreateOrConnectWithoutMetodos_de_pagoInput[]
    createMany?: polizasCreateManyMetodos_de_pagoInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type polizasUpdateManyWithoutMetodos_de_pagoNestedInput = {
    create?: XOR<polizasCreateWithoutMetodos_de_pagoInput, polizasUncheckedCreateWithoutMetodos_de_pagoInput> | polizasCreateWithoutMetodos_de_pagoInput[] | polizasUncheckedCreateWithoutMetodos_de_pagoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutMetodos_de_pagoInput | polizasCreateOrConnectWithoutMetodos_de_pagoInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutMetodos_de_pagoInput | polizasUpsertWithWhereUniqueWithoutMetodos_de_pagoInput[]
    createMany?: polizasCreateManyMetodos_de_pagoInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutMetodos_de_pagoInput | polizasUpdateWithWhereUniqueWithoutMetodos_de_pagoInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutMetodos_de_pagoInput | polizasUpdateManyWithWhereWithoutMetodos_de_pagoInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type polizasUncheckedUpdateManyWithoutMetodos_de_pagoNestedInput = {
    create?: XOR<polizasCreateWithoutMetodos_de_pagoInput, polizasUncheckedCreateWithoutMetodos_de_pagoInput> | polizasCreateWithoutMetodos_de_pagoInput[] | polizasUncheckedCreateWithoutMetodos_de_pagoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutMetodos_de_pagoInput | polizasCreateOrConnectWithoutMetodos_de_pagoInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutMetodos_de_pagoInput | polizasUpsertWithWhereUniqueWithoutMetodos_de_pagoInput[]
    createMany?: polizasCreateManyMetodos_de_pagoInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutMetodos_de_pagoInput | polizasUpdateWithWhereUniqueWithoutMetodos_de_pagoInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutMetodos_de_pagoInput | polizasUpdateManyWithWhereWithoutMetodos_de_pagoInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type polizasCreateNestedManyWithoutMonedasInput = {
    create?: XOR<polizasCreateWithoutMonedasInput, polizasUncheckedCreateWithoutMonedasInput> | polizasCreateWithoutMonedasInput[] | polizasUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutMonedasInput | polizasCreateOrConnectWithoutMonedasInput[]
    createMany?: polizasCreateManyMonedasInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type polizasUncheckedCreateNestedManyWithoutMonedasInput = {
    create?: XOR<polizasCreateWithoutMonedasInput, polizasUncheckedCreateWithoutMonedasInput> | polizasCreateWithoutMonedasInput[] | polizasUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutMonedasInput | polizasCreateOrConnectWithoutMonedasInput[]
    createMany?: polizasCreateManyMonedasInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type polizasUpdateManyWithoutMonedasNestedInput = {
    create?: XOR<polizasCreateWithoutMonedasInput, polizasUncheckedCreateWithoutMonedasInput> | polizasCreateWithoutMonedasInput[] | polizasUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutMonedasInput | polizasCreateOrConnectWithoutMonedasInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutMonedasInput | polizasUpsertWithWhereUniqueWithoutMonedasInput[]
    createMany?: polizasCreateManyMonedasInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutMonedasInput | polizasUpdateWithWhereUniqueWithoutMonedasInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutMonedasInput | polizasUpdateManyWithWhereWithoutMonedasInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type polizasUncheckedUpdateManyWithoutMonedasNestedInput = {
    create?: XOR<polizasCreateWithoutMonedasInput, polizasUncheckedCreateWithoutMonedasInput> | polizasCreateWithoutMonedasInput[] | polizasUncheckedCreateWithoutMonedasInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutMonedasInput | polizasCreateOrConnectWithoutMonedasInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutMonedasInput | polizasUpsertWithWhereUniqueWithoutMonedasInput[]
    createMany?: polizasCreateManyMonedasInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutMonedasInput | polizasUpdateWithWhereUniqueWithoutMonedasInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutMonedasInput | polizasUpdateManyWithWhereWithoutMonedasInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type polizasCreateNestedOneWithoutPoliza_recibosInput = {
    create?: XOR<polizasCreateWithoutPoliza_recibosInput, polizasUncheckedCreateWithoutPoliza_recibosInput>
    connectOrCreate?: polizasCreateOrConnectWithoutPoliza_recibosInput
    connect?: polizasWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type Enumpoliza_recibos_estatusFieldUpdateOperationsInput = {
    set?: $Enums.poliza_recibos_estatus
  }

  export type polizasUpdateOneRequiredWithoutPoliza_recibosNestedInput = {
    create?: XOR<polizasCreateWithoutPoliza_recibosInput, polizasUncheckedCreateWithoutPoliza_recibosInput>
    connectOrCreate?: polizasCreateOrConnectWithoutPoliza_recibosInput
    upsert?: polizasUpsertWithoutPoliza_recibosInput
    connect?: polizasWhereUniqueInput
    update?: XOR<XOR<polizasUpdateToOneWithWhereWithoutPoliza_recibosInput, polizasUpdateWithoutPoliza_recibosInput>, polizasUncheckedUpdateWithoutPoliza_recibosInput>
  }

  export type poliza_recibosCreateNestedManyWithoutPolizasInput = {
    create?: XOR<poliza_recibosCreateWithoutPolizasInput, poliza_recibosUncheckedCreateWithoutPolizasInput> | poliza_recibosCreateWithoutPolizasInput[] | poliza_recibosUncheckedCreateWithoutPolizasInput[]
    connectOrCreate?: poliza_recibosCreateOrConnectWithoutPolizasInput | poliza_recibosCreateOrConnectWithoutPolizasInput[]
    createMany?: poliza_recibosCreateManyPolizasInputEnvelope
    connect?: poliza_recibosWhereUniqueInput | poliza_recibosWhereUniqueInput[]
  }

  export type clientesCreateNestedOneWithoutPolizasInput = {
    create?: XOR<clientesCreateWithoutPolizasInput, clientesUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: clientesCreateOrConnectWithoutPolizasInput
    connect?: clientesWhereUniqueInput
  }

  export type companiaCreateNestedOneWithoutPolizasInput = {
    create?: XOR<companiaCreateWithoutPolizasInput, companiaUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: companiaCreateOrConnectWithoutPolizasInput
    connect?: companiaWhereUniqueInput
  }

  export type formas_de_pagoCreateNestedOneWithoutPolizasInput = {
    create?: XOR<formas_de_pagoCreateWithoutPolizasInput, formas_de_pagoUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: formas_de_pagoCreateOrConnectWithoutPolizasInput
    connect?: formas_de_pagoWhereUniqueInput
  }

  export type metodos_de_pagoCreateNestedOneWithoutPolizasInput = {
    create?: XOR<metodos_de_pagoCreateWithoutPolizasInput, metodos_de_pagoUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: metodos_de_pagoCreateOrConnectWithoutPolizasInput
    connect?: metodos_de_pagoWhereUniqueInput
  }

  export type monedasCreateNestedOneWithoutPolizasInput = {
    create?: XOR<monedasCreateWithoutPolizasInput, monedasUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: monedasCreateOrConnectWithoutPolizasInput
    connect?: monedasWhereUniqueInput
  }

  export type companias_productosCreateNestedOneWithoutPolizasInput = {
    create?: XOR<companias_productosCreateWithoutPolizasInput, companias_productosUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: companias_productosCreateOrConnectWithoutPolizasInput
    connect?: companias_productosWhereUniqueInput
  }

  export type ramosCreateNestedOneWithoutPolizasInput = {
    create?: XOR<ramosCreateWithoutPolizasInput, ramosUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: ramosCreateOrConnectWithoutPolizasInput
    connect?: ramosWhereUniqueInput
  }

  export type usuariosCreateNestedOneWithoutPolizasInput = {
    create?: XOR<usuariosCreateWithoutPolizasInput, usuariosUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutPolizasInput
    connect?: usuariosWhereUniqueInput
  }

  export type tipos_de_vencimientoCreateNestedOneWithoutPolizasInput = {
    create?: XOR<tipos_de_vencimientoCreateWithoutPolizasInput, tipos_de_vencimientoUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: tipos_de_vencimientoCreateOrConnectWithoutPolizasInput
    connect?: tipos_de_vencimientoWhereUniqueInput
  }

  export type poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput = {
    create?: XOR<poliza_recibosCreateWithoutPolizasInput, poliza_recibosUncheckedCreateWithoutPolizasInput> | poliza_recibosCreateWithoutPolizasInput[] | poliza_recibosUncheckedCreateWithoutPolizasInput[]
    connectOrCreate?: poliza_recibosCreateOrConnectWithoutPolizasInput | poliza_recibosCreateOrConnectWithoutPolizasInput[]
    createMany?: poliza_recibosCreateManyPolizasInputEnvelope
    connect?: poliza_recibosWhereUniqueInput | poliza_recibosWhereUniqueInput[]
  }

  export type poliza_recibosUpdateManyWithoutPolizasNestedInput = {
    create?: XOR<poliza_recibosCreateWithoutPolizasInput, poliza_recibosUncheckedCreateWithoutPolizasInput> | poliza_recibosCreateWithoutPolizasInput[] | poliza_recibosUncheckedCreateWithoutPolizasInput[]
    connectOrCreate?: poliza_recibosCreateOrConnectWithoutPolizasInput | poliza_recibosCreateOrConnectWithoutPolizasInput[]
    upsert?: poliza_recibosUpsertWithWhereUniqueWithoutPolizasInput | poliza_recibosUpsertWithWhereUniqueWithoutPolizasInput[]
    createMany?: poliza_recibosCreateManyPolizasInputEnvelope
    set?: poliza_recibosWhereUniqueInput | poliza_recibosWhereUniqueInput[]
    disconnect?: poliza_recibosWhereUniqueInput | poliza_recibosWhereUniqueInput[]
    delete?: poliza_recibosWhereUniqueInput | poliza_recibosWhereUniqueInput[]
    connect?: poliza_recibosWhereUniqueInput | poliza_recibosWhereUniqueInput[]
    update?: poliza_recibosUpdateWithWhereUniqueWithoutPolizasInput | poliza_recibosUpdateWithWhereUniqueWithoutPolizasInput[]
    updateMany?: poliza_recibosUpdateManyWithWhereWithoutPolizasInput | poliza_recibosUpdateManyWithWhereWithoutPolizasInput[]
    deleteMany?: poliza_recibosScalarWhereInput | poliza_recibosScalarWhereInput[]
  }

  export type clientesUpdateOneRequiredWithoutPolizasNestedInput = {
    create?: XOR<clientesCreateWithoutPolizasInput, clientesUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: clientesCreateOrConnectWithoutPolizasInput
    upsert?: clientesUpsertWithoutPolizasInput
    connect?: clientesWhereUniqueInput
    update?: XOR<XOR<clientesUpdateToOneWithWhereWithoutPolizasInput, clientesUpdateWithoutPolizasInput>, clientesUncheckedUpdateWithoutPolizasInput>
  }

  export type companiaUpdateOneRequiredWithoutPolizasNestedInput = {
    create?: XOR<companiaCreateWithoutPolizasInput, companiaUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: companiaCreateOrConnectWithoutPolizasInput
    upsert?: companiaUpsertWithoutPolizasInput
    connect?: companiaWhereUniqueInput
    update?: XOR<XOR<companiaUpdateToOneWithWhereWithoutPolizasInput, companiaUpdateWithoutPolizasInput>, companiaUncheckedUpdateWithoutPolizasInput>
  }

  export type formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput = {
    create?: XOR<formas_de_pagoCreateWithoutPolizasInput, formas_de_pagoUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: formas_de_pagoCreateOrConnectWithoutPolizasInput
    upsert?: formas_de_pagoUpsertWithoutPolizasInput
    connect?: formas_de_pagoWhereUniqueInput
    update?: XOR<XOR<formas_de_pagoUpdateToOneWithWhereWithoutPolizasInput, formas_de_pagoUpdateWithoutPolizasInput>, formas_de_pagoUncheckedUpdateWithoutPolizasInput>
  }

  export type metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput = {
    create?: XOR<metodos_de_pagoCreateWithoutPolizasInput, metodos_de_pagoUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: metodos_de_pagoCreateOrConnectWithoutPolizasInput
    upsert?: metodos_de_pagoUpsertWithoutPolizasInput
    connect?: metodos_de_pagoWhereUniqueInput
    update?: XOR<XOR<metodos_de_pagoUpdateToOneWithWhereWithoutPolizasInput, metodos_de_pagoUpdateWithoutPolizasInput>, metodos_de_pagoUncheckedUpdateWithoutPolizasInput>
  }

  export type monedasUpdateOneRequiredWithoutPolizasNestedInput = {
    create?: XOR<monedasCreateWithoutPolizasInput, monedasUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: monedasCreateOrConnectWithoutPolizasInput
    upsert?: monedasUpsertWithoutPolizasInput
    connect?: monedasWhereUniqueInput
    update?: XOR<XOR<monedasUpdateToOneWithWhereWithoutPolizasInput, monedasUpdateWithoutPolizasInput>, monedasUncheckedUpdateWithoutPolizasInput>
  }

  export type companias_productosUpdateOneRequiredWithoutPolizasNestedInput = {
    create?: XOR<companias_productosCreateWithoutPolizasInput, companias_productosUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: companias_productosCreateOrConnectWithoutPolizasInput
    upsert?: companias_productosUpsertWithoutPolizasInput
    connect?: companias_productosWhereUniqueInput
    update?: XOR<XOR<companias_productosUpdateToOneWithWhereWithoutPolizasInput, companias_productosUpdateWithoutPolizasInput>, companias_productosUncheckedUpdateWithoutPolizasInput>
  }

  export type ramosUpdateOneRequiredWithoutPolizasNestedInput = {
    create?: XOR<ramosCreateWithoutPolizasInput, ramosUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: ramosCreateOrConnectWithoutPolizasInput
    upsert?: ramosUpsertWithoutPolizasInput
    connect?: ramosWhereUniqueInput
    update?: XOR<XOR<ramosUpdateToOneWithWhereWithoutPolizasInput, ramosUpdateWithoutPolizasInput>, ramosUncheckedUpdateWithoutPolizasInput>
  }

  export type usuariosUpdateOneWithoutPolizasNestedInput = {
    create?: XOR<usuariosCreateWithoutPolizasInput, usuariosUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutPolizasInput
    upsert?: usuariosUpsertWithoutPolizasInput
    disconnect?: usuariosWhereInput | boolean
    delete?: usuariosWhereInput | boolean
    connect?: usuariosWhereUniqueInput
    update?: XOR<XOR<usuariosUpdateToOneWithWhereWithoutPolizasInput, usuariosUpdateWithoutPolizasInput>, usuariosUncheckedUpdateWithoutPolizasInput>
  }

  export type tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput = {
    create?: XOR<tipos_de_vencimientoCreateWithoutPolizasInput, tipos_de_vencimientoUncheckedCreateWithoutPolizasInput>
    connectOrCreate?: tipos_de_vencimientoCreateOrConnectWithoutPolizasInput
    upsert?: tipos_de_vencimientoUpsertWithoutPolizasInput
    connect?: tipos_de_vencimientoWhereUniqueInput
    update?: XOR<XOR<tipos_de_vencimientoUpdateToOneWithWhereWithoutPolizasInput, tipos_de_vencimientoUpdateWithoutPolizasInput>, tipos_de_vencimientoUncheckedUpdateWithoutPolizasInput>
  }

  export type poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput = {
    create?: XOR<poliza_recibosCreateWithoutPolizasInput, poliza_recibosUncheckedCreateWithoutPolizasInput> | poliza_recibosCreateWithoutPolizasInput[] | poliza_recibosUncheckedCreateWithoutPolizasInput[]
    connectOrCreate?: poliza_recibosCreateOrConnectWithoutPolizasInput | poliza_recibosCreateOrConnectWithoutPolizasInput[]
    upsert?: poliza_recibosUpsertWithWhereUniqueWithoutPolizasInput | poliza_recibosUpsertWithWhereUniqueWithoutPolizasInput[]
    createMany?: poliza_recibosCreateManyPolizasInputEnvelope
    set?: poliza_recibosWhereUniqueInput | poliza_recibosWhereUniqueInput[]
    disconnect?: poliza_recibosWhereUniqueInput | poliza_recibosWhereUniqueInput[]
    delete?: poliza_recibosWhereUniqueInput | poliza_recibosWhereUniqueInput[]
    connect?: poliza_recibosWhereUniqueInput | poliza_recibosWhereUniqueInput[]
    update?: poliza_recibosUpdateWithWhereUniqueWithoutPolizasInput | poliza_recibosUpdateWithWhereUniqueWithoutPolizasInput[]
    updateMany?: poliza_recibosUpdateManyWithWhereWithoutPolizasInput | poliza_recibosUpdateManyWithWhereWithoutPolizasInput[]
    deleteMany?: poliza_recibosScalarWhereInput | poliza_recibosScalarWhereInput[]
  }

  export type companias_productosCreateNestedManyWithoutRamosInput = {
    create?: XOR<companias_productosCreateWithoutRamosInput, companias_productosUncheckedCreateWithoutRamosInput> | companias_productosCreateWithoutRamosInput[] | companias_productosUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: companias_productosCreateOrConnectWithoutRamosInput | companias_productosCreateOrConnectWithoutRamosInput[]
    createMany?: companias_productosCreateManyRamosInputEnvelope
    connect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
  }

  export type companias_ramosCreateNestedManyWithoutRamosInput = {
    create?: XOR<companias_ramosCreateWithoutRamosInput, companias_ramosUncheckedCreateWithoutRamosInput> | companias_ramosCreateWithoutRamosInput[] | companias_ramosUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: companias_ramosCreateOrConnectWithoutRamosInput | companias_ramosCreateOrConnectWithoutRamosInput[]
    createMany?: companias_ramosCreateManyRamosInputEnvelope
    connect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
  }

  export type polizasCreateNestedManyWithoutRamosInput = {
    create?: XOR<polizasCreateWithoutRamosInput, polizasUncheckedCreateWithoutRamosInput> | polizasCreateWithoutRamosInput[] | polizasUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutRamosInput | polizasCreateOrConnectWithoutRamosInput[]
    createMany?: polizasCreateManyRamosInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type companias_productosUncheckedCreateNestedManyWithoutRamosInput = {
    create?: XOR<companias_productosCreateWithoutRamosInput, companias_productosUncheckedCreateWithoutRamosInput> | companias_productosCreateWithoutRamosInput[] | companias_productosUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: companias_productosCreateOrConnectWithoutRamosInput | companias_productosCreateOrConnectWithoutRamosInput[]
    createMany?: companias_productosCreateManyRamosInputEnvelope
    connect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
  }

  export type companias_ramosUncheckedCreateNestedManyWithoutRamosInput = {
    create?: XOR<companias_ramosCreateWithoutRamosInput, companias_ramosUncheckedCreateWithoutRamosInput> | companias_ramosCreateWithoutRamosInput[] | companias_ramosUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: companias_ramosCreateOrConnectWithoutRamosInput | companias_ramosCreateOrConnectWithoutRamosInput[]
    createMany?: companias_ramosCreateManyRamosInputEnvelope
    connect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
  }

  export type polizasUncheckedCreateNestedManyWithoutRamosInput = {
    create?: XOR<polizasCreateWithoutRamosInput, polizasUncheckedCreateWithoutRamosInput> | polizasCreateWithoutRamosInput[] | polizasUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutRamosInput | polizasCreateOrConnectWithoutRamosInput[]
    createMany?: polizasCreateManyRamosInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type companias_productosUpdateManyWithoutRamosNestedInput = {
    create?: XOR<companias_productosCreateWithoutRamosInput, companias_productosUncheckedCreateWithoutRamosInput> | companias_productosCreateWithoutRamosInput[] | companias_productosUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: companias_productosCreateOrConnectWithoutRamosInput | companias_productosCreateOrConnectWithoutRamosInput[]
    upsert?: companias_productosUpsertWithWhereUniqueWithoutRamosInput | companias_productosUpsertWithWhereUniqueWithoutRamosInput[]
    createMany?: companias_productosCreateManyRamosInputEnvelope
    set?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    disconnect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    delete?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    connect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    update?: companias_productosUpdateWithWhereUniqueWithoutRamosInput | companias_productosUpdateWithWhereUniqueWithoutRamosInput[]
    updateMany?: companias_productosUpdateManyWithWhereWithoutRamosInput | companias_productosUpdateManyWithWhereWithoutRamosInput[]
    deleteMany?: companias_productosScalarWhereInput | companias_productosScalarWhereInput[]
  }

  export type companias_ramosUpdateManyWithoutRamosNestedInput = {
    create?: XOR<companias_ramosCreateWithoutRamosInput, companias_ramosUncheckedCreateWithoutRamosInput> | companias_ramosCreateWithoutRamosInput[] | companias_ramosUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: companias_ramosCreateOrConnectWithoutRamosInput | companias_ramosCreateOrConnectWithoutRamosInput[]
    upsert?: companias_ramosUpsertWithWhereUniqueWithoutRamosInput | companias_ramosUpsertWithWhereUniqueWithoutRamosInput[]
    createMany?: companias_ramosCreateManyRamosInputEnvelope
    set?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    disconnect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    delete?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    connect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    update?: companias_ramosUpdateWithWhereUniqueWithoutRamosInput | companias_ramosUpdateWithWhereUniqueWithoutRamosInput[]
    updateMany?: companias_ramosUpdateManyWithWhereWithoutRamosInput | companias_ramosUpdateManyWithWhereWithoutRamosInput[]
    deleteMany?: companias_ramosScalarWhereInput | companias_ramosScalarWhereInput[]
  }

  export type polizasUpdateManyWithoutRamosNestedInput = {
    create?: XOR<polizasCreateWithoutRamosInput, polizasUncheckedCreateWithoutRamosInput> | polizasCreateWithoutRamosInput[] | polizasUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutRamosInput | polizasCreateOrConnectWithoutRamosInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutRamosInput | polizasUpsertWithWhereUniqueWithoutRamosInput[]
    createMany?: polizasCreateManyRamosInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutRamosInput | polizasUpdateWithWhereUniqueWithoutRamosInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutRamosInput | polizasUpdateManyWithWhereWithoutRamosInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type companias_productosUncheckedUpdateManyWithoutRamosNestedInput = {
    create?: XOR<companias_productosCreateWithoutRamosInput, companias_productosUncheckedCreateWithoutRamosInput> | companias_productosCreateWithoutRamosInput[] | companias_productosUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: companias_productosCreateOrConnectWithoutRamosInput | companias_productosCreateOrConnectWithoutRamosInput[]
    upsert?: companias_productosUpsertWithWhereUniqueWithoutRamosInput | companias_productosUpsertWithWhereUniqueWithoutRamosInput[]
    createMany?: companias_productosCreateManyRamosInputEnvelope
    set?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    disconnect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    delete?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    connect?: companias_productosWhereUniqueInput | companias_productosWhereUniqueInput[]
    update?: companias_productosUpdateWithWhereUniqueWithoutRamosInput | companias_productosUpdateWithWhereUniqueWithoutRamosInput[]
    updateMany?: companias_productosUpdateManyWithWhereWithoutRamosInput | companias_productosUpdateManyWithWhereWithoutRamosInput[]
    deleteMany?: companias_productosScalarWhereInput | companias_productosScalarWhereInput[]
  }

  export type companias_ramosUncheckedUpdateManyWithoutRamosNestedInput = {
    create?: XOR<companias_ramosCreateWithoutRamosInput, companias_ramosUncheckedCreateWithoutRamosInput> | companias_ramosCreateWithoutRamosInput[] | companias_ramosUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: companias_ramosCreateOrConnectWithoutRamosInput | companias_ramosCreateOrConnectWithoutRamosInput[]
    upsert?: companias_ramosUpsertWithWhereUniqueWithoutRamosInput | companias_ramosUpsertWithWhereUniqueWithoutRamosInput[]
    createMany?: companias_ramosCreateManyRamosInputEnvelope
    set?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    disconnect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    delete?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    connect?: companias_ramosWhereUniqueInput | companias_ramosWhereUniqueInput[]
    update?: companias_ramosUpdateWithWhereUniqueWithoutRamosInput | companias_ramosUpdateWithWhereUniqueWithoutRamosInput[]
    updateMany?: companias_ramosUpdateManyWithWhereWithoutRamosInput | companias_ramosUpdateManyWithWhereWithoutRamosInput[]
    deleteMany?: companias_ramosScalarWhereInput | companias_ramosScalarWhereInput[]
  }

  export type polizasUncheckedUpdateManyWithoutRamosNestedInput = {
    create?: XOR<polizasCreateWithoutRamosInput, polizasUncheckedCreateWithoutRamosInput> | polizasCreateWithoutRamosInput[] | polizasUncheckedCreateWithoutRamosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutRamosInput | polizasCreateOrConnectWithoutRamosInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutRamosInput | polizasUpsertWithWhereUniqueWithoutRamosInput[]
    createMany?: polizasCreateManyRamosInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutRamosInput | polizasUpdateWithWhereUniqueWithoutRamosInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutRamosInput | polizasUpdateManyWithWhereWithoutRamosInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type usuario_teamCreateNestedManyWithoutTipos_de_usuariosInput = {
    create?: XOR<usuario_teamCreateWithoutTipos_de_usuariosInput, usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput> | usuario_teamCreateWithoutTipos_de_usuariosInput[] | usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput[]
    connectOrCreate?: usuario_teamCreateOrConnectWithoutTipos_de_usuariosInput | usuario_teamCreateOrConnectWithoutTipos_de_usuariosInput[]
    createMany?: usuario_teamCreateManyTipos_de_usuariosInputEnvelope
    connect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
  }

  export type usuario_teamUncheckedCreateNestedManyWithoutTipos_de_usuariosInput = {
    create?: XOR<usuario_teamCreateWithoutTipos_de_usuariosInput, usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput> | usuario_teamCreateWithoutTipos_de_usuariosInput[] | usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput[]
    connectOrCreate?: usuario_teamCreateOrConnectWithoutTipos_de_usuariosInput | usuario_teamCreateOrConnectWithoutTipos_de_usuariosInput[]
    createMany?: usuario_teamCreateManyTipos_de_usuariosInputEnvelope
    connect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
  }

  export type usuario_teamUpdateManyWithoutTipos_de_usuariosNestedInput = {
    create?: XOR<usuario_teamCreateWithoutTipos_de_usuariosInput, usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput> | usuario_teamCreateWithoutTipos_de_usuariosInput[] | usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput[]
    connectOrCreate?: usuario_teamCreateOrConnectWithoutTipos_de_usuariosInput | usuario_teamCreateOrConnectWithoutTipos_de_usuariosInput[]
    upsert?: usuario_teamUpsertWithWhereUniqueWithoutTipos_de_usuariosInput | usuario_teamUpsertWithWhereUniqueWithoutTipos_de_usuariosInput[]
    createMany?: usuario_teamCreateManyTipos_de_usuariosInputEnvelope
    set?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    disconnect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    delete?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    connect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    update?: usuario_teamUpdateWithWhereUniqueWithoutTipos_de_usuariosInput | usuario_teamUpdateWithWhereUniqueWithoutTipos_de_usuariosInput[]
    updateMany?: usuario_teamUpdateManyWithWhereWithoutTipos_de_usuariosInput | usuario_teamUpdateManyWithWhereWithoutTipos_de_usuariosInput[]
    deleteMany?: usuario_teamScalarWhereInput | usuario_teamScalarWhereInput[]
  }

  export type usuario_teamUncheckedUpdateManyWithoutTipos_de_usuariosNestedInput = {
    create?: XOR<usuario_teamCreateWithoutTipos_de_usuariosInput, usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput> | usuario_teamCreateWithoutTipos_de_usuariosInput[] | usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput[]
    connectOrCreate?: usuario_teamCreateOrConnectWithoutTipos_de_usuariosInput | usuario_teamCreateOrConnectWithoutTipos_de_usuariosInput[]
    upsert?: usuario_teamUpsertWithWhereUniqueWithoutTipos_de_usuariosInput | usuario_teamUpsertWithWhereUniqueWithoutTipos_de_usuariosInput[]
    createMany?: usuario_teamCreateManyTipos_de_usuariosInputEnvelope
    set?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    disconnect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    delete?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    connect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    update?: usuario_teamUpdateWithWhereUniqueWithoutTipos_de_usuariosInput | usuario_teamUpdateWithWhereUniqueWithoutTipos_de_usuariosInput[]
    updateMany?: usuario_teamUpdateManyWithWhereWithoutTipos_de_usuariosInput | usuario_teamUpdateManyWithWhereWithoutTipos_de_usuariosInput[]
    deleteMany?: usuario_teamScalarWhereInput | usuario_teamScalarWhereInput[]
  }

  export type polizasCreateNestedManyWithoutTipos_de_vencimientoInput = {
    create?: XOR<polizasCreateWithoutTipos_de_vencimientoInput, polizasUncheckedCreateWithoutTipos_de_vencimientoInput> | polizasCreateWithoutTipos_de_vencimientoInput[] | polizasUncheckedCreateWithoutTipos_de_vencimientoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutTipos_de_vencimientoInput | polizasCreateOrConnectWithoutTipos_de_vencimientoInput[]
    createMany?: polizasCreateManyTipos_de_vencimientoInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type polizasUncheckedCreateNestedManyWithoutTipos_de_vencimientoInput = {
    create?: XOR<polizasCreateWithoutTipos_de_vencimientoInput, polizasUncheckedCreateWithoutTipos_de_vencimientoInput> | polizasCreateWithoutTipos_de_vencimientoInput[] | polizasUncheckedCreateWithoutTipos_de_vencimientoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutTipos_de_vencimientoInput | polizasCreateOrConnectWithoutTipos_de_vencimientoInput[]
    createMany?: polizasCreateManyTipos_de_vencimientoInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type polizasUpdateManyWithoutTipos_de_vencimientoNestedInput = {
    create?: XOR<polizasCreateWithoutTipos_de_vencimientoInput, polizasUncheckedCreateWithoutTipos_de_vencimientoInput> | polizasCreateWithoutTipos_de_vencimientoInput[] | polizasUncheckedCreateWithoutTipos_de_vencimientoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutTipos_de_vencimientoInput | polizasCreateOrConnectWithoutTipos_de_vencimientoInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutTipos_de_vencimientoInput | polizasUpsertWithWhereUniqueWithoutTipos_de_vencimientoInput[]
    createMany?: polizasCreateManyTipos_de_vencimientoInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutTipos_de_vencimientoInput | polizasUpdateWithWhereUniqueWithoutTipos_de_vencimientoInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutTipos_de_vencimientoInput | polizasUpdateManyWithWhereWithoutTipos_de_vencimientoInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type polizasUncheckedUpdateManyWithoutTipos_de_vencimientoNestedInput = {
    create?: XOR<polizasCreateWithoutTipos_de_vencimientoInput, polizasUncheckedCreateWithoutTipos_de_vencimientoInput> | polizasCreateWithoutTipos_de_vencimientoInput[] | polizasUncheckedCreateWithoutTipos_de_vencimientoInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutTipos_de_vencimientoInput | polizasCreateOrConnectWithoutTipos_de_vencimientoInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutTipos_de_vencimientoInput | polizasUpsertWithWhereUniqueWithoutTipos_de_vencimientoInput[]
    createMany?: polizasCreateManyTipos_de_vencimientoInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutTipos_de_vencimientoInput | polizasUpdateWithWhereUniqueWithoutTipos_de_vencimientoInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutTipos_de_vencimientoInput | polizasUpdateManyWithWhereWithoutTipos_de_vencimientoInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type companiaCreateNestedOneWithoutUsuario_clavesInput = {
    create?: XOR<companiaCreateWithoutUsuario_clavesInput, companiaUncheckedCreateWithoutUsuario_clavesInput>
    connectOrCreate?: companiaCreateOrConnectWithoutUsuario_clavesInput
    connect?: companiaWhereUniqueInput
  }

  export type companiaUpdateOneRequiredWithoutUsuario_clavesNestedInput = {
    create?: XOR<companiaCreateWithoutUsuario_clavesInput, companiaUncheckedCreateWithoutUsuario_clavesInput>
    connectOrCreate?: companiaCreateOrConnectWithoutUsuario_clavesInput
    upsert?: companiaUpsertWithoutUsuario_clavesInput
    connect?: companiaWhereUniqueInput
    update?: XOR<XOR<companiaUpdateToOneWithWhereWithoutUsuario_clavesInput, companiaUpdateWithoutUsuario_clavesInput>, companiaUncheckedUpdateWithoutUsuario_clavesInput>
  }

  export type tipos_de_usuariosCreateNestedOneWithoutUsuario_teamInput = {
    create?: XOR<tipos_de_usuariosCreateWithoutUsuario_teamInput, tipos_de_usuariosUncheckedCreateWithoutUsuario_teamInput>
    connectOrCreate?: tipos_de_usuariosCreateOrConnectWithoutUsuario_teamInput
    connect?: tipos_de_usuariosWhereUniqueInput
  }

  export type usuariosCreateNestedOneWithoutUsuario_teamInput = {
    create?: XOR<usuariosCreateWithoutUsuario_teamInput, usuariosUncheckedCreateWithoutUsuario_teamInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutUsuario_teamInput
    connect?: usuariosWhereUniqueInput
  }

  export type tipos_de_usuariosUpdateOneRequiredWithoutUsuario_teamNestedInput = {
    create?: XOR<tipos_de_usuariosCreateWithoutUsuario_teamInput, tipos_de_usuariosUncheckedCreateWithoutUsuario_teamInput>
    connectOrCreate?: tipos_de_usuariosCreateOrConnectWithoutUsuario_teamInput
    upsert?: tipos_de_usuariosUpsertWithoutUsuario_teamInput
    connect?: tipos_de_usuariosWhereUniqueInput
    update?: XOR<XOR<tipos_de_usuariosUpdateToOneWithWhereWithoutUsuario_teamInput, tipos_de_usuariosUpdateWithoutUsuario_teamInput>, tipos_de_usuariosUncheckedUpdateWithoutUsuario_teamInput>
  }

  export type usuariosUpdateOneRequiredWithoutUsuario_teamNestedInput = {
    create?: XOR<usuariosCreateWithoutUsuario_teamInput, usuariosUncheckedCreateWithoutUsuario_teamInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutUsuario_teamInput
    upsert?: usuariosUpsertWithoutUsuario_teamInput
    connect?: usuariosWhereUniqueInput
    update?: XOR<XOR<usuariosUpdateToOneWithWhereWithoutUsuario_teamInput, usuariosUpdateWithoutUsuario_teamInput>, usuariosUncheckedUpdateWithoutUsuario_teamInput>
  }

  export type polizasCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<polizasCreateWithoutUsuariosInput, polizasUncheckedCreateWithoutUsuariosInput> | polizasCreateWithoutUsuariosInput[] | polizasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutUsuariosInput | polizasCreateOrConnectWithoutUsuariosInput[]
    createMany?: polizasCreateManyUsuariosInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type usuario_teamCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<usuario_teamCreateWithoutUsuariosInput, usuario_teamUncheckedCreateWithoutUsuariosInput> | usuario_teamCreateWithoutUsuariosInput[] | usuario_teamUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: usuario_teamCreateOrConnectWithoutUsuariosInput | usuario_teamCreateOrConnectWithoutUsuariosInput[]
    createMany?: usuario_teamCreateManyUsuariosInputEnvelope
    connect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
  }

  export type polizasUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<polizasCreateWithoutUsuariosInput, polizasUncheckedCreateWithoutUsuariosInput> | polizasCreateWithoutUsuariosInput[] | polizasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutUsuariosInput | polizasCreateOrConnectWithoutUsuariosInput[]
    createMany?: polizasCreateManyUsuariosInputEnvelope
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
  }

  export type usuario_teamUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<usuario_teamCreateWithoutUsuariosInput, usuario_teamUncheckedCreateWithoutUsuariosInput> | usuario_teamCreateWithoutUsuariosInput[] | usuario_teamUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: usuario_teamCreateOrConnectWithoutUsuariosInput | usuario_teamCreateOrConnectWithoutUsuariosInput[]
    createMany?: usuario_teamCreateManyUsuariosInputEnvelope
    connect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
  }

  export type polizasUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<polizasCreateWithoutUsuariosInput, polizasUncheckedCreateWithoutUsuariosInput> | polizasCreateWithoutUsuariosInput[] | polizasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutUsuariosInput | polizasCreateOrConnectWithoutUsuariosInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutUsuariosInput | polizasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: polizasCreateManyUsuariosInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutUsuariosInput | polizasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutUsuariosInput | polizasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type usuario_teamUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<usuario_teamCreateWithoutUsuariosInput, usuario_teamUncheckedCreateWithoutUsuariosInput> | usuario_teamCreateWithoutUsuariosInput[] | usuario_teamUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: usuario_teamCreateOrConnectWithoutUsuariosInput | usuario_teamCreateOrConnectWithoutUsuariosInput[]
    upsert?: usuario_teamUpsertWithWhereUniqueWithoutUsuariosInput | usuario_teamUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: usuario_teamCreateManyUsuariosInputEnvelope
    set?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    disconnect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    delete?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    connect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    update?: usuario_teamUpdateWithWhereUniqueWithoutUsuariosInput | usuario_teamUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: usuario_teamUpdateManyWithWhereWithoutUsuariosInput | usuario_teamUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: usuario_teamScalarWhereInput | usuario_teamScalarWhereInput[]
  }

  export type polizasUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<polizasCreateWithoutUsuariosInput, polizasUncheckedCreateWithoutUsuariosInput> | polizasCreateWithoutUsuariosInput[] | polizasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: polizasCreateOrConnectWithoutUsuariosInput | polizasCreateOrConnectWithoutUsuariosInput[]
    upsert?: polizasUpsertWithWhereUniqueWithoutUsuariosInput | polizasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: polizasCreateManyUsuariosInputEnvelope
    set?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    disconnect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    delete?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    connect?: polizasWhereUniqueInput | polizasWhereUniqueInput[]
    update?: polizasUpdateWithWhereUniqueWithoutUsuariosInput | polizasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: polizasUpdateManyWithWhereWithoutUsuariosInput | polizasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: polizasScalarWhereInput | polizasScalarWhereInput[]
  }

  export type usuario_teamUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<usuario_teamCreateWithoutUsuariosInput, usuario_teamUncheckedCreateWithoutUsuariosInput> | usuario_teamCreateWithoutUsuariosInput[] | usuario_teamUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: usuario_teamCreateOrConnectWithoutUsuariosInput | usuario_teamCreateOrConnectWithoutUsuariosInput[]
    upsert?: usuario_teamUpsertWithWhereUniqueWithoutUsuariosInput | usuario_teamUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: usuario_teamCreateManyUsuariosInputEnvelope
    set?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    disconnect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    delete?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    connect?: usuario_teamWhereUniqueInput | usuario_teamWhereUniqueInput[]
    update?: usuario_teamUpdateWithWhereUniqueWithoutUsuariosInput | usuario_teamUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: usuario_teamUpdateManyWithWhereWithoutUsuariosInput | usuario_teamUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: usuario_teamScalarWhereInput | usuario_teamScalarWhereInput[]
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumpoliza_recibos_estatusFilter<$PrismaModel = never> = {
    equals?: $Enums.poliza_recibos_estatus | Enumpoliza_recibos_estatusFieldRefInput<$PrismaModel>
    in?: $Enums.poliza_recibos_estatus[]
    notIn?: $Enums.poliza_recibos_estatus[]
    not?: NestedEnumpoliza_recibos_estatusFilter<$PrismaModel> | $Enums.poliza_recibos_estatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumpoliza_recibos_estatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.poliza_recibos_estatus | Enumpoliza_recibos_estatusFieldRefInput<$PrismaModel>
    in?: $Enums.poliza_recibos_estatus[]
    notIn?: $Enums.poliza_recibos_estatus[]
    not?: NestedEnumpoliza_recibos_estatusWithAggregatesFilter<$PrismaModel> | $Enums.poliza_recibos_estatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpoliza_recibos_estatusFilter<$PrismaModel>
    _max?: NestedEnumpoliza_recibos_estatusFilter<$PrismaModel>
  }

  export type polizasCreateWithoutClientesInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosCreateNestedManyWithoutPolizasInput
    compania: companiaCreateNestedOneWithoutPolizasInput
    formas_de_pago: formas_de_pagoCreateNestedOneWithoutPolizasInput
    metodos_de_pago: metodos_de_pagoCreateNestedOneWithoutPolizasInput
    monedas: monedasCreateNestedOneWithoutPolizasInput
    companias_productos: companias_productosCreateNestedOneWithoutPolizasInput
    ramos: ramosCreateNestedOneWithoutPolizasInput
    usuarios?: usuariosCreateNestedOneWithoutPolizasInput
    tipos_de_vencimiento: tipos_de_vencimientoCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateWithoutClientesInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput
  }

  export type polizasCreateOrConnectWithoutClientesInput = {
    where: polizasWhereUniqueInput
    create: XOR<polizasCreateWithoutClientesInput, polizasUncheckedCreateWithoutClientesInput>
  }

  export type polizasCreateManyClientesInputEnvelope = {
    data: polizasCreateManyClientesInput | polizasCreateManyClientesInput[]
    skipDuplicates?: boolean
  }

  export type polizasUpsertWithWhereUniqueWithoutClientesInput = {
    where: polizasWhereUniqueInput
    update: XOR<polizasUpdateWithoutClientesInput, polizasUncheckedUpdateWithoutClientesInput>
    create: XOR<polizasCreateWithoutClientesInput, polizasUncheckedCreateWithoutClientesInput>
  }

  export type polizasUpdateWithWhereUniqueWithoutClientesInput = {
    where: polizasWhereUniqueInput
    data: XOR<polizasUpdateWithoutClientesInput, polizasUncheckedUpdateWithoutClientesInput>
  }

  export type polizasUpdateManyWithWhereWithoutClientesInput = {
    where: polizasScalarWhereInput
    data: XOR<polizasUpdateManyMutationInput, polizasUncheckedUpdateManyWithoutClientesInput>
  }

  export type polizasScalarWhereInput = {
    AND?: polizasScalarWhereInput | polizasScalarWhereInput[]
    OR?: polizasScalarWhereInput[]
    NOT?: polizasScalarWhereInput | polizasScalarWhereInput[]
    id?: BigIntFilter<"polizas"> | bigint | number
    numeroPoliza?: StringNullableFilter<"polizas"> | string | null
    numeroCliente?: StringNullableFilter<"polizas"> | string | null
    inicioVigencia?: DateTimeFilter<"polizas"> | Date | string
    finVigencia?: DateTimeFilter<"polizas"> | Date | string
    antiguedad?: IntFilter<"polizas"> | number
    primaNeta?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    financiamiento?: DecimalNullableFilter<"polizas"> | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFilter<"polizas"> | bigint | number
    comisionAgente?: DecimalNullableFilter<"polizas"> | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFilter<"polizas"> | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFilter<"polizas"> | bigint | number
    formaPago_id?: BigIntFilter<"polizas"> | bigint | number
    tipoVencimiento_id?: BigIntFilter<"polizas"> | bigint | number
    compania_id?: BigIntFilter<"polizas"> | bigint | number
    subAgente_id?: BigIntNullableFilter<"polizas"> | bigint | number | null
    ramo_id?: BigIntFilter<"polizas"> | bigint | number
    metodoPago_id?: BigIntFilter<"polizas"> | bigint | number
    moneda_id?: BigIntFilter<"polizas"> | bigint | number
    producto_id?: BigIntFilter<"polizas"> | bigint | number
    created_at?: DateTimeNullableFilter<"polizas"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"polizas"> | Date | string | null
  }

  export type compania_representantesCreateWithoutCompaniaInput = {
    id?: bigint | number
    nombre: string
    telefono: string
    correo: string
    cargo: string
    estatus?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type compania_representantesUncheckedCreateWithoutCompaniaInput = {
    id?: bigint | number
    nombre: string
    telefono: string
    correo: string
    cargo: string
    estatus?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type compania_representantesCreateOrConnectWithoutCompaniaInput = {
    where: compania_representantesWhereUniqueInput
    create: XOR<compania_representantesCreateWithoutCompaniaInput, compania_representantesUncheckedCreateWithoutCompaniaInput>
  }

  export type compania_representantesCreateManyCompaniaInputEnvelope = {
    data: compania_representantesCreateManyCompaniaInput | compania_representantesCreateManyCompaniaInput[]
    skipDuplicates?: boolean
  }

  export type companias_productosCreateWithoutCompaniaInput = {
    id?: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
    ramos: ramosCreateNestedOneWithoutCompanias_productosInput
    polizas?: polizasCreateNestedManyWithoutCompanias_productosInput
  }

  export type companias_productosUncheckedCreateWithoutCompaniaInput = {
    id?: bigint | number
    ramo_id: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
    polizas?: polizasUncheckedCreateNestedManyWithoutCompanias_productosInput
  }

  export type companias_productosCreateOrConnectWithoutCompaniaInput = {
    where: companias_productosWhereUniqueInput
    create: XOR<companias_productosCreateWithoutCompaniaInput, companias_productosUncheckedCreateWithoutCompaniaInput>
  }

  export type companias_productosCreateManyCompaniaInputEnvelope = {
    data: companias_productosCreateManyCompaniaInput | companias_productosCreateManyCompaniaInput[]
    skipDuplicates?: boolean
  }

  export type companias_ramosCreateWithoutCompaniaInput = {
    id?: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
    ramos: ramosCreateNestedOneWithoutCompanias_ramosInput
  }

  export type companias_ramosUncheckedCreateWithoutCompaniaInput = {
    id?: bigint | number
    ramo_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
  }

  export type companias_ramosCreateOrConnectWithoutCompaniaInput = {
    where: companias_ramosWhereUniqueInput
    create: XOR<companias_ramosCreateWithoutCompaniaInput, companias_ramosUncheckedCreateWithoutCompaniaInput>
  }

  export type companias_ramosCreateManyCompaniaInputEnvelope = {
    data: companias_ramosCreateManyCompaniaInput | companias_ramosCreateManyCompaniaInput[]
    skipDuplicates?: boolean
  }

  export type polizasCreateWithoutCompaniaInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosCreateNestedManyWithoutPolizasInput
    clientes: clientesCreateNestedOneWithoutPolizasInput
    formas_de_pago: formas_de_pagoCreateNestedOneWithoutPolizasInput
    metodos_de_pago: metodos_de_pagoCreateNestedOneWithoutPolizasInput
    monedas: monedasCreateNestedOneWithoutPolizasInput
    companias_productos: companias_productosCreateNestedOneWithoutPolizasInput
    ramos: ramosCreateNestedOneWithoutPolizasInput
    usuarios?: usuariosCreateNestedOneWithoutPolizasInput
    tipos_de_vencimiento: tipos_de_vencimientoCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateWithoutCompaniaInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput
  }

  export type polizasCreateOrConnectWithoutCompaniaInput = {
    where: polizasWhereUniqueInput
    create: XOR<polizasCreateWithoutCompaniaInput, polizasUncheckedCreateWithoutCompaniaInput>
  }

  export type polizasCreateManyCompaniaInputEnvelope = {
    data: polizasCreateManyCompaniaInput | polizasCreateManyCompaniaInput[]
    skipDuplicates?: boolean
  }

  export type usuario_clavesCreateWithoutCompaniaInput = {
    id?: bigint | number
    clave: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    usuario_id: bigint | number
  }

  export type usuario_clavesUncheckedCreateWithoutCompaniaInput = {
    id?: bigint | number
    clave: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    usuario_id: bigint | number
  }

  export type usuario_clavesCreateOrConnectWithoutCompaniaInput = {
    where: usuario_clavesWhereUniqueInput
    create: XOR<usuario_clavesCreateWithoutCompaniaInput, usuario_clavesUncheckedCreateWithoutCompaniaInput>
  }

  export type usuario_clavesCreateManyCompaniaInputEnvelope = {
    data: usuario_clavesCreateManyCompaniaInput | usuario_clavesCreateManyCompaniaInput[]
    skipDuplicates?: boolean
  }

  export type compania_representantesUpsertWithWhereUniqueWithoutCompaniaInput = {
    where: compania_representantesWhereUniqueInput
    update: XOR<compania_representantesUpdateWithoutCompaniaInput, compania_representantesUncheckedUpdateWithoutCompaniaInput>
    create: XOR<compania_representantesCreateWithoutCompaniaInput, compania_representantesUncheckedCreateWithoutCompaniaInput>
  }

  export type compania_representantesUpdateWithWhereUniqueWithoutCompaniaInput = {
    where: compania_representantesWhereUniqueInput
    data: XOR<compania_representantesUpdateWithoutCompaniaInput, compania_representantesUncheckedUpdateWithoutCompaniaInput>
  }

  export type compania_representantesUpdateManyWithWhereWithoutCompaniaInput = {
    where: compania_representantesScalarWhereInput
    data: XOR<compania_representantesUpdateManyMutationInput, compania_representantesUncheckedUpdateManyWithoutCompaniaInput>
  }

  export type compania_representantesScalarWhereInput = {
    AND?: compania_representantesScalarWhereInput | compania_representantesScalarWhereInput[]
    OR?: compania_representantesScalarWhereInput[]
    NOT?: compania_representantesScalarWhereInput | compania_representantesScalarWhereInput[]
    id?: BigIntFilter<"compania_representantes"> | bigint | number
    compania_id?: BigIntFilter<"compania_representantes"> | bigint | number
    nombre?: StringFilter<"compania_representantes"> | string
    telefono?: StringFilter<"compania_representantes"> | string
    correo?: StringFilter<"compania_representantes"> | string
    cargo?: StringFilter<"compania_representantes"> | string
    estatus?: BoolNullableFilter<"compania_representantes"> | boolean | null
    created_at?: DateTimeNullableFilter<"compania_representantes"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"compania_representantes"> | Date | string | null
  }

  export type companias_productosUpsertWithWhereUniqueWithoutCompaniaInput = {
    where: companias_productosWhereUniqueInput
    update: XOR<companias_productosUpdateWithoutCompaniaInput, companias_productosUncheckedUpdateWithoutCompaniaInput>
    create: XOR<companias_productosCreateWithoutCompaniaInput, companias_productosUncheckedCreateWithoutCompaniaInput>
  }

  export type companias_productosUpdateWithWhereUniqueWithoutCompaniaInput = {
    where: companias_productosWhereUniqueInput
    data: XOR<companias_productosUpdateWithoutCompaniaInput, companias_productosUncheckedUpdateWithoutCompaniaInput>
  }

  export type companias_productosUpdateManyWithWhereWithoutCompaniaInput = {
    where: companias_productosScalarWhereInput
    data: XOR<companias_productosUpdateManyMutationInput, companias_productosUncheckedUpdateManyWithoutCompaniaInput>
  }

  export type companias_productosScalarWhereInput = {
    AND?: companias_productosScalarWhereInput | companias_productosScalarWhereInput[]
    OR?: companias_productosScalarWhereInput[]
    NOT?: companias_productosScalarWhereInput | companias_productosScalarWhereInput[]
    id?: BigIntFilter<"companias_productos"> | bigint | number
    compania_id?: BigIntFilter<"companias_productos"> | bigint | number
    ramo_id?: BigIntFilter<"companias_productos"> | bigint | number
    nombre?: StringFilter<"companias_productos"> | string
    created_at?: DateTimeNullableFilter<"companias_productos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"companias_productos"> | Date | string | null
    estatus?: BoolNullableFilter<"companias_productos"> | boolean | null
  }

  export type companias_ramosUpsertWithWhereUniqueWithoutCompaniaInput = {
    where: companias_ramosWhereUniqueInput
    update: XOR<companias_ramosUpdateWithoutCompaniaInput, companias_ramosUncheckedUpdateWithoutCompaniaInput>
    create: XOR<companias_ramosCreateWithoutCompaniaInput, companias_ramosUncheckedCreateWithoutCompaniaInput>
  }

  export type companias_ramosUpdateWithWhereUniqueWithoutCompaniaInput = {
    where: companias_ramosWhereUniqueInput
    data: XOR<companias_ramosUpdateWithoutCompaniaInput, companias_ramosUncheckedUpdateWithoutCompaniaInput>
  }

  export type companias_ramosUpdateManyWithWhereWithoutCompaniaInput = {
    where: companias_ramosScalarWhereInput
    data: XOR<companias_ramosUpdateManyMutationInput, companias_ramosUncheckedUpdateManyWithoutCompaniaInput>
  }

  export type companias_ramosScalarWhereInput = {
    AND?: companias_ramosScalarWhereInput | companias_ramosScalarWhereInput[]
    OR?: companias_ramosScalarWhereInput[]
    NOT?: companias_ramosScalarWhereInput | companias_ramosScalarWhereInput[]
    id?: BigIntFilter<"companias_ramos"> | bigint | number
    compania_id?: BigIntFilter<"companias_ramos"> | bigint | number
    ramo_id?: BigIntFilter<"companias_ramos"> | bigint | number
    created_at?: DateTimeNullableFilter<"companias_ramos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"companias_ramos"> | Date | string | null
    estatus?: BoolNullableFilter<"companias_ramos"> | boolean | null
  }

  export type polizasUpsertWithWhereUniqueWithoutCompaniaInput = {
    where: polizasWhereUniqueInput
    update: XOR<polizasUpdateWithoutCompaniaInput, polizasUncheckedUpdateWithoutCompaniaInput>
    create: XOR<polizasCreateWithoutCompaniaInput, polizasUncheckedCreateWithoutCompaniaInput>
  }

  export type polizasUpdateWithWhereUniqueWithoutCompaniaInput = {
    where: polizasWhereUniqueInput
    data: XOR<polizasUpdateWithoutCompaniaInput, polizasUncheckedUpdateWithoutCompaniaInput>
  }

  export type polizasUpdateManyWithWhereWithoutCompaniaInput = {
    where: polizasScalarWhereInput
    data: XOR<polizasUpdateManyMutationInput, polizasUncheckedUpdateManyWithoutCompaniaInput>
  }

  export type usuario_clavesUpsertWithWhereUniqueWithoutCompaniaInput = {
    where: usuario_clavesWhereUniqueInput
    update: XOR<usuario_clavesUpdateWithoutCompaniaInput, usuario_clavesUncheckedUpdateWithoutCompaniaInput>
    create: XOR<usuario_clavesCreateWithoutCompaniaInput, usuario_clavesUncheckedCreateWithoutCompaniaInput>
  }

  export type usuario_clavesUpdateWithWhereUniqueWithoutCompaniaInput = {
    where: usuario_clavesWhereUniqueInput
    data: XOR<usuario_clavesUpdateWithoutCompaniaInput, usuario_clavesUncheckedUpdateWithoutCompaniaInput>
  }

  export type usuario_clavesUpdateManyWithWhereWithoutCompaniaInput = {
    where: usuario_clavesScalarWhereInput
    data: XOR<usuario_clavesUpdateManyMutationInput, usuario_clavesUncheckedUpdateManyWithoutCompaniaInput>
  }

  export type usuario_clavesScalarWhereInput = {
    AND?: usuario_clavesScalarWhereInput | usuario_clavesScalarWhereInput[]
    OR?: usuario_clavesScalarWhereInput[]
    NOT?: usuario_clavesScalarWhereInput | usuario_clavesScalarWhereInput[]
    id?: BigIntFilter<"usuario_claves"> | bigint | number
    compania_id?: BigIntFilter<"usuario_claves"> | bigint | number
    clave?: StringFilter<"usuario_claves"> | string
    estatus?: BoolFilter<"usuario_claves"> | boolean
    created_at?: DateTimeNullableFilter<"usuario_claves"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"usuario_claves"> | Date | string | null
    usuario_id?: BigIntFilter<"usuario_claves"> | bigint | number
  }

  export type companiaCreateWithoutCompania_representantesInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companias_productos?: companias_productosCreateNestedManyWithoutCompaniaInput
    companias_ramos?: companias_ramosCreateNestedManyWithoutCompaniaInput
    polizas?: polizasCreateNestedManyWithoutCompaniaInput
    usuario_claves?: usuario_clavesCreateNestedManyWithoutCompaniaInput
  }

  export type companiaUncheckedCreateWithoutCompania_representantesInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companias_productos?: companias_productosUncheckedCreateNestedManyWithoutCompaniaInput
    companias_ramos?: companias_ramosUncheckedCreateNestedManyWithoutCompaniaInput
    polizas?: polizasUncheckedCreateNestedManyWithoutCompaniaInput
    usuario_claves?: usuario_clavesUncheckedCreateNestedManyWithoutCompaniaInput
  }

  export type companiaCreateOrConnectWithoutCompania_representantesInput = {
    where: companiaWhereUniqueInput
    create: XOR<companiaCreateWithoutCompania_representantesInput, companiaUncheckedCreateWithoutCompania_representantesInput>
  }

  export type companiaUpsertWithoutCompania_representantesInput = {
    update: XOR<companiaUpdateWithoutCompania_representantesInput, companiaUncheckedUpdateWithoutCompania_representantesInput>
    create: XOR<companiaCreateWithoutCompania_representantesInput, companiaUncheckedCreateWithoutCompania_representantesInput>
    where?: companiaWhereInput
  }

  export type companiaUpdateToOneWithWhereWithoutCompania_representantesInput = {
    where?: companiaWhereInput
    data: XOR<companiaUpdateWithoutCompania_representantesInput, companiaUncheckedUpdateWithoutCompania_representantesInput>
  }

  export type companiaUpdateWithoutCompania_representantesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companias_productos?: companias_productosUpdateManyWithoutCompaniaNestedInput
    companias_ramos?: companias_ramosUpdateManyWithoutCompaniaNestedInput
    polizas?: polizasUpdateManyWithoutCompaniaNestedInput
    usuario_claves?: usuario_clavesUpdateManyWithoutCompaniaNestedInput
  }

  export type companiaUncheckedUpdateWithoutCompania_representantesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companias_productos?: companias_productosUncheckedUpdateManyWithoutCompaniaNestedInput
    companias_ramos?: companias_ramosUncheckedUpdateManyWithoutCompaniaNestedInput
    polizas?: polizasUncheckedUpdateManyWithoutCompaniaNestedInput
    usuario_claves?: usuario_clavesUncheckedUpdateManyWithoutCompaniaNestedInput
  }

  export type companiaCreateWithoutCompanias_productosInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania_representantes?: compania_representantesCreateNestedManyWithoutCompaniaInput
    companias_ramos?: companias_ramosCreateNestedManyWithoutCompaniaInput
    polizas?: polizasCreateNestedManyWithoutCompaniaInput
    usuario_claves?: usuario_clavesCreateNestedManyWithoutCompaniaInput
  }

  export type companiaUncheckedCreateWithoutCompanias_productosInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania_representantes?: compania_representantesUncheckedCreateNestedManyWithoutCompaniaInput
    companias_ramos?: companias_ramosUncheckedCreateNestedManyWithoutCompaniaInput
    polizas?: polizasUncheckedCreateNestedManyWithoutCompaniaInput
    usuario_claves?: usuario_clavesUncheckedCreateNestedManyWithoutCompaniaInput
  }

  export type companiaCreateOrConnectWithoutCompanias_productosInput = {
    where: companiaWhereUniqueInput
    create: XOR<companiaCreateWithoutCompanias_productosInput, companiaUncheckedCreateWithoutCompanias_productosInput>
  }

  export type ramosCreateWithoutCompanias_productosInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companias_ramos?: companias_ramosCreateNestedManyWithoutRamosInput
    polizas?: polizasCreateNestedManyWithoutRamosInput
  }

  export type ramosUncheckedCreateWithoutCompanias_productosInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companias_ramos?: companias_ramosUncheckedCreateNestedManyWithoutRamosInput
    polizas?: polizasUncheckedCreateNestedManyWithoutRamosInput
  }

  export type ramosCreateOrConnectWithoutCompanias_productosInput = {
    where: ramosWhereUniqueInput
    create: XOR<ramosCreateWithoutCompanias_productosInput, ramosUncheckedCreateWithoutCompanias_productosInput>
  }

  export type polizasCreateWithoutCompanias_productosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosCreateNestedManyWithoutPolizasInput
    clientes: clientesCreateNestedOneWithoutPolizasInput
    compania: companiaCreateNestedOneWithoutPolizasInput
    formas_de_pago: formas_de_pagoCreateNestedOneWithoutPolizasInput
    metodos_de_pago: metodos_de_pagoCreateNestedOneWithoutPolizasInput
    monedas: monedasCreateNestedOneWithoutPolizasInput
    ramos: ramosCreateNestedOneWithoutPolizasInput
    usuarios?: usuariosCreateNestedOneWithoutPolizasInput
    tipos_de_vencimiento: tipos_de_vencimientoCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateWithoutCompanias_productosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput
  }

  export type polizasCreateOrConnectWithoutCompanias_productosInput = {
    where: polizasWhereUniqueInput
    create: XOR<polizasCreateWithoutCompanias_productosInput, polizasUncheckedCreateWithoutCompanias_productosInput>
  }

  export type polizasCreateManyCompanias_productosInputEnvelope = {
    data: polizasCreateManyCompanias_productosInput | polizasCreateManyCompanias_productosInput[]
    skipDuplicates?: boolean
  }

  export type companiaUpsertWithoutCompanias_productosInput = {
    update: XOR<companiaUpdateWithoutCompanias_productosInput, companiaUncheckedUpdateWithoutCompanias_productosInput>
    create: XOR<companiaCreateWithoutCompanias_productosInput, companiaUncheckedCreateWithoutCompanias_productosInput>
    where?: companiaWhereInput
  }

  export type companiaUpdateToOneWithWhereWithoutCompanias_productosInput = {
    where?: companiaWhereInput
    data: XOR<companiaUpdateWithoutCompanias_productosInput, companiaUncheckedUpdateWithoutCompanias_productosInput>
  }

  export type companiaUpdateWithoutCompanias_productosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania_representantes?: compania_representantesUpdateManyWithoutCompaniaNestedInput
    companias_ramos?: companias_ramosUpdateManyWithoutCompaniaNestedInput
    polizas?: polizasUpdateManyWithoutCompaniaNestedInput
    usuario_claves?: usuario_clavesUpdateManyWithoutCompaniaNestedInput
  }

  export type companiaUncheckedUpdateWithoutCompanias_productosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania_representantes?: compania_representantesUncheckedUpdateManyWithoutCompaniaNestedInput
    companias_ramos?: companias_ramosUncheckedUpdateManyWithoutCompaniaNestedInput
    polizas?: polizasUncheckedUpdateManyWithoutCompaniaNestedInput
    usuario_claves?: usuario_clavesUncheckedUpdateManyWithoutCompaniaNestedInput
  }

  export type ramosUpsertWithoutCompanias_productosInput = {
    update: XOR<ramosUpdateWithoutCompanias_productosInput, ramosUncheckedUpdateWithoutCompanias_productosInput>
    create: XOR<ramosCreateWithoutCompanias_productosInput, ramosUncheckedCreateWithoutCompanias_productosInput>
    where?: ramosWhereInput
  }

  export type ramosUpdateToOneWithWhereWithoutCompanias_productosInput = {
    where?: ramosWhereInput
    data: XOR<ramosUpdateWithoutCompanias_productosInput, ramosUncheckedUpdateWithoutCompanias_productosInput>
  }

  export type ramosUpdateWithoutCompanias_productosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companias_ramos?: companias_ramosUpdateManyWithoutRamosNestedInput
    polizas?: polizasUpdateManyWithoutRamosNestedInput
  }

  export type ramosUncheckedUpdateWithoutCompanias_productosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companias_ramos?: companias_ramosUncheckedUpdateManyWithoutRamosNestedInput
    polizas?: polizasUncheckedUpdateManyWithoutRamosNestedInput
  }

  export type polizasUpsertWithWhereUniqueWithoutCompanias_productosInput = {
    where: polizasWhereUniqueInput
    update: XOR<polizasUpdateWithoutCompanias_productosInput, polizasUncheckedUpdateWithoutCompanias_productosInput>
    create: XOR<polizasCreateWithoutCompanias_productosInput, polizasUncheckedCreateWithoutCompanias_productosInput>
  }

  export type polizasUpdateWithWhereUniqueWithoutCompanias_productosInput = {
    where: polizasWhereUniqueInput
    data: XOR<polizasUpdateWithoutCompanias_productosInput, polizasUncheckedUpdateWithoutCompanias_productosInput>
  }

  export type polizasUpdateManyWithWhereWithoutCompanias_productosInput = {
    where: polizasScalarWhereInput
    data: XOR<polizasUpdateManyMutationInput, polizasUncheckedUpdateManyWithoutCompanias_productosInput>
  }

  export type companiaCreateWithoutCompanias_ramosInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania_representantes?: compania_representantesCreateNestedManyWithoutCompaniaInput
    companias_productos?: companias_productosCreateNestedManyWithoutCompaniaInput
    polizas?: polizasCreateNestedManyWithoutCompaniaInput
    usuario_claves?: usuario_clavesCreateNestedManyWithoutCompaniaInput
  }

  export type companiaUncheckedCreateWithoutCompanias_ramosInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania_representantes?: compania_representantesUncheckedCreateNestedManyWithoutCompaniaInput
    companias_productos?: companias_productosUncheckedCreateNestedManyWithoutCompaniaInput
    polizas?: polizasUncheckedCreateNestedManyWithoutCompaniaInput
    usuario_claves?: usuario_clavesUncheckedCreateNestedManyWithoutCompaniaInput
  }

  export type companiaCreateOrConnectWithoutCompanias_ramosInput = {
    where: companiaWhereUniqueInput
    create: XOR<companiaCreateWithoutCompanias_ramosInput, companiaUncheckedCreateWithoutCompanias_ramosInput>
  }

  export type ramosCreateWithoutCompanias_ramosInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companias_productos?: companias_productosCreateNestedManyWithoutRamosInput
    polizas?: polizasCreateNestedManyWithoutRamosInput
  }

  export type ramosUncheckedCreateWithoutCompanias_ramosInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companias_productos?: companias_productosUncheckedCreateNestedManyWithoutRamosInput
    polizas?: polizasUncheckedCreateNestedManyWithoutRamosInput
  }

  export type ramosCreateOrConnectWithoutCompanias_ramosInput = {
    where: ramosWhereUniqueInput
    create: XOR<ramosCreateWithoutCompanias_ramosInput, ramosUncheckedCreateWithoutCompanias_ramosInput>
  }

  export type companiaUpsertWithoutCompanias_ramosInput = {
    update: XOR<companiaUpdateWithoutCompanias_ramosInput, companiaUncheckedUpdateWithoutCompanias_ramosInput>
    create: XOR<companiaCreateWithoutCompanias_ramosInput, companiaUncheckedCreateWithoutCompanias_ramosInput>
    where?: companiaWhereInput
  }

  export type companiaUpdateToOneWithWhereWithoutCompanias_ramosInput = {
    where?: companiaWhereInput
    data: XOR<companiaUpdateWithoutCompanias_ramosInput, companiaUncheckedUpdateWithoutCompanias_ramosInput>
  }

  export type companiaUpdateWithoutCompanias_ramosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania_representantes?: compania_representantesUpdateManyWithoutCompaniaNestedInput
    companias_productos?: companias_productosUpdateManyWithoutCompaniaNestedInput
    polizas?: polizasUpdateManyWithoutCompaniaNestedInput
    usuario_claves?: usuario_clavesUpdateManyWithoutCompaniaNestedInput
  }

  export type companiaUncheckedUpdateWithoutCompanias_ramosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania_representantes?: compania_representantesUncheckedUpdateManyWithoutCompaniaNestedInput
    companias_productos?: companias_productosUncheckedUpdateManyWithoutCompaniaNestedInput
    polizas?: polizasUncheckedUpdateManyWithoutCompaniaNestedInput
    usuario_claves?: usuario_clavesUncheckedUpdateManyWithoutCompaniaNestedInput
  }

  export type ramosUpsertWithoutCompanias_ramosInput = {
    update: XOR<ramosUpdateWithoutCompanias_ramosInput, ramosUncheckedUpdateWithoutCompanias_ramosInput>
    create: XOR<ramosCreateWithoutCompanias_ramosInput, ramosUncheckedCreateWithoutCompanias_ramosInput>
    where?: ramosWhereInput
  }

  export type ramosUpdateToOneWithWhereWithoutCompanias_ramosInput = {
    where?: ramosWhereInput
    data: XOR<ramosUpdateWithoutCompanias_ramosInput, ramosUncheckedUpdateWithoutCompanias_ramosInput>
  }

  export type ramosUpdateWithoutCompanias_ramosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companias_productos?: companias_productosUpdateManyWithoutRamosNestedInput
    polizas?: polizasUpdateManyWithoutRamosNestedInput
  }

  export type ramosUncheckedUpdateWithoutCompanias_ramosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companias_productos?: companias_productosUncheckedUpdateManyWithoutRamosNestedInput
    polizas?: polizasUncheckedUpdateManyWithoutRamosNestedInput
  }

  export type polizasCreateWithoutFormas_de_pagoInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosCreateNestedManyWithoutPolizasInput
    clientes: clientesCreateNestedOneWithoutPolizasInput
    compania: companiaCreateNestedOneWithoutPolizasInput
    metodos_de_pago: metodos_de_pagoCreateNestedOneWithoutPolizasInput
    monedas: monedasCreateNestedOneWithoutPolizasInput
    companias_productos: companias_productosCreateNestedOneWithoutPolizasInput
    ramos: ramosCreateNestedOneWithoutPolizasInput
    usuarios?: usuariosCreateNestedOneWithoutPolizasInput
    tipos_de_vencimiento: tipos_de_vencimientoCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateWithoutFormas_de_pagoInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput
  }

  export type polizasCreateOrConnectWithoutFormas_de_pagoInput = {
    where: polizasWhereUniqueInput
    create: XOR<polizasCreateWithoutFormas_de_pagoInput, polizasUncheckedCreateWithoutFormas_de_pagoInput>
  }

  export type polizasCreateManyFormas_de_pagoInputEnvelope = {
    data: polizasCreateManyFormas_de_pagoInput | polizasCreateManyFormas_de_pagoInput[]
    skipDuplicates?: boolean
  }

  export type polizasUpsertWithWhereUniqueWithoutFormas_de_pagoInput = {
    where: polizasWhereUniqueInput
    update: XOR<polizasUpdateWithoutFormas_de_pagoInput, polizasUncheckedUpdateWithoutFormas_de_pagoInput>
    create: XOR<polizasCreateWithoutFormas_de_pagoInput, polizasUncheckedCreateWithoutFormas_de_pagoInput>
  }

  export type polizasUpdateWithWhereUniqueWithoutFormas_de_pagoInput = {
    where: polizasWhereUniqueInput
    data: XOR<polizasUpdateWithoutFormas_de_pagoInput, polizasUncheckedUpdateWithoutFormas_de_pagoInput>
  }

  export type polizasUpdateManyWithWhereWithoutFormas_de_pagoInput = {
    where: polizasScalarWhereInput
    data: XOR<polizasUpdateManyMutationInput, polizasUncheckedUpdateManyWithoutFormas_de_pagoInput>
  }

  export type polizasCreateWithoutMetodos_de_pagoInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosCreateNestedManyWithoutPolizasInput
    clientes: clientesCreateNestedOneWithoutPolizasInput
    compania: companiaCreateNestedOneWithoutPolizasInput
    formas_de_pago: formas_de_pagoCreateNestedOneWithoutPolizasInput
    monedas: monedasCreateNestedOneWithoutPolizasInput
    companias_productos: companias_productosCreateNestedOneWithoutPolizasInput
    ramos: ramosCreateNestedOneWithoutPolizasInput
    usuarios?: usuariosCreateNestedOneWithoutPolizasInput
    tipos_de_vencimiento: tipos_de_vencimientoCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateWithoutMetodos_de_pagoInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput
  }

  export type polizasCreateOrConnectWithoutMetodos_de_pagoInput = {
    where: polizasWhereUniqueInput
    create: XOR<polizasCreateWithoutMetodos_de_pagoInput, polizasUncheckedCreateWithoutMetodos_de_pagoInput>
  }

  export type polizasCreateManyMetodos_de_pagoInputEnvelope = {
    data: polizasCreateManyMetodos_de_pagoInput | polizasCreateManyMetodos_de_pagoInput[]
    skipDuplicates?: boolean
  }

  export type polizasUpsertWithWhereUniqueWithoutMetodos_de_pagoInput = {
    where: polizasWhereUniqueInput
    update: XOR<polizasUpdateWithoutMetodos_de_pagoInput, polizasUncheckedUpdateWithoutMetodos_de_pagoInput>
    create: XOR<polizasCreateWithoutMetodos_de_pagoInput, polizasUncheckedCreateWithoutMetodos_de_pagoInput>
  }

  export type polizasUpdateWithWhereUniqueWithoutMetodos_de_pagoInput = {
    where: polizasWhereUniqueInput
    data: XOR<polizasUpdateWithoutMetodos_de_pagoInput, polizasUncheckedUpdateWithoutMetodos_de_pagoInput>
  }

  export type polizasUpdateManyWithWhereWithoutMetodos_de_pagoInput = {
    where: polizasScalarWhereInput
    data: XOR<polizasUpdateManyMutationInput, polizasUncheckedUpdateManyWithoutMetodos_de_pagoInput>
  }

  export type polizasCreateWithoutMonedasInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosCreateNestedManyWithoutPolizasInput
    clientes: clientesCreateNestedOneWithoutPolizasInput
    compania: companiaCreateNestedOneWithoutPolizasInput
    formas_de_pago: formas_de_pagoCreateNestedOneWithoutPolizasInput
    metodos_de_pago: metodos_de_pagoCreateNestedOneWithoutPolizasInput
    companias_productos: companias_productosCreateNestedOneWithoutPolizasInput
    ramos: ramosCreateNestedOneWithoutPolizasInput
    usuarios?: usuariosCreateNestedOneWithoutPolizasInput
    tipos_de_vencimiento: tipos_de_vencimientoCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateWithoutMonedasInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput
  }

  export type polizasCreateOrConnectWithoutMonedasInput = {
    where: polizasWhereUniqueInput
    create: XOR<polizasCreateWithoutMonedasInput, polizasUncheckedCreateWithoutMonedasInput>
  }

  export type polizasCreateManyMonedasInputEnvelope = {
    data: polizasCreateManyMonedasInput | polizasCreateManyMonedasInput[]
    skipDuplicates?: boolean
  }

  export type polizasUpsertWithWhereUniqueWithoutMonedasInput = {
    where: polizasWhereUniqueInput
    update: XOR<polizasUpdateWithoutMonedasInput, polizasUncheckedUpdateWithoutMonedasInput>
    create: XOR<polizasCreateWithoutMonedasInput, polizasUncheckedCreateWithoutMonedasInput>
  }

  export type polizasUpdateWithWhereUniqueWithoutMonedasInput = {
    where: polizasWhereUniqueInput
    data: XOR<polizasUpdateWithoutMonedasInput, polizasUncheckedUpdateWithoutMonedasInput>
  }

  export type polizasUpdateManyWithWhereWithoutMonedasInput = {
    where: polizasScalarWhereInput
    data: XOR<polizasUpdateManyMutationInput, polizasUncheckedUpdateManyWithoutMonedasInput>
  }

  export type polizasCreateWithoutPoliza_recibosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    clientes: clientesCreateNestedOneWithoutPolizasInput
    compania: companiaCreateNestedOneWithoutPolizasInput
    formas_de_pago: formas_de_pagoCreateNestedOneWithoutPolizasInput
    metodos_de_pago: metodos_de_pagoCreateNestedOneWithoutPolizasInput
    monedas: monedasCreateNestedOneWithoutPolizasInput
    companias_productos: companias_productosCreateNestedOneWithoutPolizasInput
    ramos: ramosCreateNestedOneWithoutPolizasInput
    usuarios?: usuariosCreateNestedOneWithoutPolizasInput
    tipos_de_vencimiento: tipos_de_vencimientoCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateWithoutPoliza_recibosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type polizasCreateOrConnectWithoutPoliza_recibosInput = {
    where: polizasWhereUniqueInput
    create: XOR<polizasCreateWithoutPoliza_recibosInput, polizasUncheckedCreateWithoutPoliza_recibosInput>
  }

  export type polizasUpsertWithoutPoliza_recibosInput = {
    update: XOR<polizasUpdateWithoutPoliza_recibosInput, polizasUncheckedUpdateWithoutPoliza_recibosInput>
    create: XOR<polizasCreateWithoutPoliza_recibosInput, polizasUncheckedCreateWithoutPoliza_recibosInput>
    where?: polizasWhereInput
  }

  export type polizasUpdateToOneWithWhereWithoutPoliza_recibosInput = {
    where?: polizasWhereInput
    data: XOR<polizasUpdateWithoutPoliza_recibosInput, polizasUncheckedUpdateWithoutPoliza_recibosInput>
  }

  export type polizasUpdateWithoutPoliza_recibosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientes?: clientesUpdateOneRequiredWithoutPolizasNestedInput
    compania?: companiaUpdateOneRequiredWithoutPolizasNestedInput
    formas_de_pago?: formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    metodos_de_pago?: metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutPolizasNestedInput
    companias_productos?: companias_productosUpdateOneRequiredWithoutPolizasNestedInput
    ramos?: ramosUpdateOneRequiredWithoutPolizasNestedInput
    usuarios?: usuariosUpdateOneWithoutPolizasNestedInput
    tipos_de_vencimiento?: tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateWithoutPoliza_recibosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_recibosCreateWithoutPolizasInput = {
    id?: bigint | number
    numeroRecibo: string
    vencimiento: Date | string
    importe: Decimal | DecimalJsLike | number | string
    estatus?: $Enums.poliza_recibos_estatus
    fechaPago?: Date | string | null
    fechaCancelado?: Date | string | null
    evidencia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type poliza_recibosUncheckedCreateWithoutPolizasInput = {
    id?: bigint | number
    numeroRecibo: string
    vencimiento: Date | string
    importe: Decimal | DecimalJsLike | number | string
    estatus?: $Enums.poliza_recibos_estatus
    fechaPago?: Date | string | null
    fechaCancelado?: Date | string | null
    evidencia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type poliza_recibosCreateOrConnectWithoutPolizasInput = {
    where: poliza_recibosWhereUniqueInput
    create: XOR<poliza_recibosCreateWithoutPolizasInput, poliza_recibosUncheckedCreateWithoutPolizasInput>
  }

  export type poliza_recibosCreateManyPolizasInputEnvelope = {
    data: poliza_recibosCreateManyPolizasInput | poliza_recibosCreateManyPolizasInput[]
    skipDuplicates?: boolean
  }

  export type clientesCreateWithoutPolizasInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    fechaNacimiento: Date | string
    direccion: string
    colonia: string
    codigoPostal: string
    estado_id: bigint | number
    ciudad: string
    correo?: string | null
    telefono?: string | null
    celular?: string | null
    oficina?: string | null
    casa?: string | null
    observaciones?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type clientesUncheckedCreateWithoutPolizasInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    fechaNacimiento: Date | string
    direccion: string
    colonia: string
    codigoPostal: string
    estado_id: bigint | number
    ciudad: string
    correo?: string | null
    telefono?: string | null
    celular?: string | null
    oficina?: string | null
    casa?: string | null
    observaciones?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type clientesCreateOrConnectWithoutPolizasInput = {
    where: clientesWhereUniqueInput
    create: XOR<clientesCreateWithoutPolizasInput, clientesUncheckedCreateWithoutPolizasInput>
  }

  export type companiaCreateWithoutPolizasInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania_representantes?: compania_representantesCreateNestedManyWithoutCompaniaInput
    companias_productos?: companias_productosCreateNestedManyWithoutCompaniaInput
    companias_ramos?: companias_ramosCreateNestedManyWithoutCompaniaInput
    usuario_claves?: usuario_clavesCreateNestedManyWithoutCompaniaInput
  }

  export type companiaUncheckedCreateWithoutPolizasInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania_representantes?: compania_representantesUncheckedCreateNestedManyWithoutCompaniaInput
    companias_productos?: companias_productosUncheckedCreateNestedManyWithoutCompaniaInput
    companias_ramos?: companias_ramosUncheckedCreateNestedManyWithoutCompaniaInput
    usuario_claves?: usuario_clavesUncheckedCreateNestedManyWithoutCompaniaInput
  }

  export type companiaCreateOrConnectWithoutPolizasInput = {
    where: companiaWhereUniqueInput
    create: XOR<companiaCreateWithoutPolizasInput, companiaUncheckedCreateWithoutPolizasInput>
  }

  export type formas_de_pagoCreateWithoutPolizasInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type formas_de_pagoUncheckedCreateWithoutPolizasInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type formas_de_pagoCreateOrConnectWithoutPolizasInput = {
    where: formas_de_pagoWhereUniqueInput
    create: XOR<formas_de_pagoCreateWithoutPolizasInput, formas_de_pagoUncheckedCreateWithoutPolizasInput>
  }

  export type metodos_de_pagoCreateWithoutPolizasInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type metodos_de_pagoUncheckedCreateWithoutPolizasInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type metodos_de_pagoCreateOrConnectWithoutPolizasInput = {
    where: metodos_de_pagoWhereUniqueInput
    create: XOR<metodos_de_pagoCreateWithoutPolizasInput, metodos_de_pagoUncheckedCreateWithoutPolizasInput>
  }

  export type monedasCreateWithoutPolizasInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type monedasUncheckedCreateWithoutPolizasInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type monedasCreateOrConnectWithoutPolizasInput = {
    where: monedasWhereUniqueInput
    create: XOR<monedasCreateWithoutPolizasInput, monedasUncheckedCreateWithoutPolizasInput>
  }

  export type companias_productosCreateWithoutPolizasInput = {
    id?: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
    compania: companiaCreateNestedOneWithoutCompanias_productosInput
    ramos: ramosCreateNestedOneWithoutCompanias_productosInput
  }

  export type companias_productosUncheckedCreateWithoutPolizasInput = {
    id?: bigint | number
    compania_id: bigint | number
    ramo_id: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
  }

  export type companias_productosCreateOrConnectWithoutPolizasInput = {
    where: companias_productosWhereUniqueInput
    create: XOR<companias_productosCreateWithoutPolizasInput, companias_productosUncheckedCreateWithoutPolizasInput>
  }

  export type ramosCreateWithoutPolizasInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companias_productos?: companias_productosCreateNestedManyWithoutRamosInput
    companias_ramos?: companias_ramosCreateNestedManyWithoutRamosInput
  }

  export type ramosUncheckedCreateWithoutPolizasInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companias_productos?: companias_productosUncheckedCreateNestedManyWithoutRamosInput
    companias_ramos?: companias_ramosUncheckedCreateNestedManyWithoutRamosInput
  }

  export type ramosCreateOrConnectWithoutPolizasInput = {
    where: ramosWhereUniqueInput
    create: XOR<ramosCreateWithoutPolizasInput, ramosUncheckedCreateWithoutPolizasInput>
  }

  export type usuariosCreateWithoutPolizasInput = {
    id?: bigint | number
    nombre: string
    correo: string
    password: string
    tipo_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    usuario_team?: usuario_teamCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosUncheckedCreateWithoutPolizasInput = {
    id?: bigint | number
    nombre: string
    correo: string
    password: string
    tipo_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    usuario_team?: usuario_teamUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosCreateOrConnectWithoutPolizasInput = {
    where: usuariosWhereUniqueInput
    create: XOR<usuariosCreateWithoutPolizasInput, usuariosUncheckedCreateWithoutPolizasInput>
  }

  export type tipos_de_vencimientoCreateWithoutPolizasInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type tipos_de_vencimientoUncheckedCreateWithoutPolizasInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type tipos_de_vencimientoCreateOrConnectWithoutPolizasInput = {
    where: tipos_de_vencimientoWhereUniqueInput
    create: XOR<tipos_de_vencimientoCreateWithoutPolizasInput, tipos_de_vencimientoUncheckedCreateWithoutPolizasInput>
  }

  export type poliza_recibosUpsertWithWhereUniqueWithoutPolizasInput = {
    where: poliza_recibosWhereUniqueInput
    update: XOR<poliza_recibosUpdateWithoutPolizasInput, poliza_recibosUncheckedUpdateWithoutPolizasInput>
    create: XOR<poliza_recibosCreateWithoutPolizasInput, poliza_recibosUncheckedCreateWithoutPolizasInput>
  }

  export type poliza_recibosUpdateWithWhereUniqueWithoutPolizasInput = {
    where: poliza_recibosWhereUniqueInput
    data: XOR<poliza_recibosUpdateWithoutPolizasInput, poliza_recibosUncheckedUpdateWithoutPolizasInput>
  }

  export type poliza_recibosUpdateManyWithWhereWithoutPolizasInput = {
    where: poliza_recibosScalarWhereInput
    data: XOR<poliza_recibosUpdateManyMutationInput, poliza_recibosUncheckedUpdateManyWithoutPolizasInput>
  }

  export type poliza_recibosScalarWhereInput = {
    AND?: poliza_recibosScalarWhereInput | poliza_recibosScalarWhereInput[]
    OR?: poliza_recibosScalarWhereInput[]
    NOT?: poliza_recibosScalarWhereInput | poliza_recibosScalarWhereInput[]
    id?: BigIntFilter<"poliza_recibos"> | bigint | number
    poliza_id?: BigIntFilter<"poliza_recibos"> | bigint | number
    numeroRecibo?: StringFilter<"poliza_recibos"> | string
    vencimiento?: DateTimeFilter<"poliza_recibos"> | Date | string
    importe?: DecimalFilter<"poliza_recibos"> | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusFilter<"poliza_recibos"> | $Enums.poliza_recibos_estatus
    fechaPago?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    fechaCancelado?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    evidencia?: StringNullableFilter<"poliza_recibos"> | string | null
    created_at?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"poliza_recibos"> | Date | string | null
  }

  export type clientesUpsertWithoutPolizasInput = {
    update: XOR<clientesUpdateWithoutPolizasInput, clientesUncheckedUpdateWithoutPolizasInput>
    create: XOR<clientesCreateWithoutPolizasInput, clientesUncheckedCreateWithoutPolizasInput>
    where?: clientesWhereInput
  }

  export type clientesUpdateToOneWithWhereWithoutPolizasInput = {
    where?: clientesWhereInput
    data: XOR<clientesUpdateWithoutPolizasInput, clientesUncheckedUpdateWithoutPolizasInput>
  }

  export type clientesUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    colonia?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    estado_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ciudad?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    oficina?: NullableStringFieldUpdateOperationsInput | string | null
    casa?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clientesUncheckedUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    colonia?: StringFieldUpdateOperationsInput | string
    codigoPostal?: StringFieldUpdateOperationsInput | string
    estado_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ciudad?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    oficina?: NullableStringFieldUpdateOperationsInput | string | null
    casa?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companiaUpsertWithoutPolizasInput = {
    update: XOR<companiaUpdateWithoutPolizasInput, companiaUncheckedUpdateWithoutPolizasInput>
    create: XOR<companiaCreateWithoutPolizasInput, companiaUncheckedCreateWithoutPolizasInput>
    where?: companiaWhereInput
  }

  export type companiaUpdateToOneWithWhereWithoutPolizasInput = {
    where?: companiaWhereInput
    data: XOR<companiaUpdateWithoutPolizasInput, companiaUncheckedUpdateWithoutPolizasInput>
  }

  export type companiaUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania_representantes?: compania_representantesUpdateManyWithoutCompaniaNestedInput
    companias_productos?: companias_productosUpdateManyWithoutCompaniaNestedInput
    companias_ramos?: companias_ramosUpdateManyWithoutCompaniaNestedInput
    usuario_claves?: usuario_clavesUpdateManyWithoutCompaniaNestedInput
  }

  export type companiaUncheckedUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania_representantes?: compania_representantesUncheckedUpdateManyWithoutCompaniaNestedInput
    companias_productos?: companias_productosUncheckedUpdateManyWithoutCompaniaNestedInput
    companias_ramos?: companias_ramosUncheckedUpdateManyWithoutCompaniaNestedInput
    usuario_claves?: usuario_clavesUncheckedUpdateManyWithoutCompaniaNestedInput
  }

  export type formas_de_pagoUpsertWithoutPolizasInput = {
    update: XOR<formas_de_pagoUpdateWithoutPolizasInput, formas_de_pagoUncheckedUpdateWithoutPolizasInput>
    create: XOR<formas_de_pagoCreateWithoutPolizasInput, formas_de_pagoUncheckedCreateWithoutPolizasInput>
    where?: formas_de_pagoWhereInput
  }

  export type formas_de_pagoUpdateToOneWithWhereWithoutPolizasInput = {
    where?: formas_de_pagoWhereInput
    data: XOR<formas_de_pagoUpdateWithoutPolizasInput, formas_de_pagoUncheckedUpdateWithoutPolizasInput>
  }

  export type formas_de_pagoUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type formas_de_pagoUncheckedUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type metodos_de_pagoUpsertWithoutPolizasInput = {
    update: XOR<metodos_de_pagoUpdateWithoutPolizasInput, metodos_de_pagoUncheckedUpdateWithoutPolizasInput>
    create: XOR<metodos_de_pagoCreateWithoutPolizasInput, metodos_de_pagoUncheckedCreateWithoutPolizasInput>
    where?: metodos_de_pagoWhereInput
  }

  export type metodos_de_pagoUpdateToOneWithWhereWithoutPolizasInput = {
    where?: metodos_de_pagoWhereInput
    data: XOR<metodos_de_pagoUpdateWithoutPolizasInput, metodos_de_pagoUncheckedUpdateWithoutPolizasInput>
  }

  export type metodos_de_pagoUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type metodos_de_pagoUncheckedUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type monedasUpsertWithoutPolizasInput = {
    update: XOR<monedasUpdateWithoutPolizasInput, monedasUncheckedUpdateWithoutPolizasInput>
    create: XOR<monedasCreateWithoutPolizasInput, monedasUncheckedCreateWithoutPolizasInput>
    where?: monedasWhereInput
  }

  export type monedasUpdateToOneWithWhereWithoutPolizasInput = {
    where?: monedasWhereInput
    data: XOR<monedasUpdateWithoutPolizasInput, monedasUncheckedUpdateWithoutPolizasInput>
  }

  export type monedasUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type monedasUncheckedUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companias_productosUpsertWithoutPolizasInput = {
    update: XOR<companias_productosUpdateWithoutPolizasInput, companias_productosUncheckedUpdateWithoutPolizasInput>
    create: XOR<companias_productosCreateWithoutPolizasInput, companias_productosUncheckedCreateWithoutPolizasInput>
    where?: companias_productosWhereInput
  }

  export type companias_productosUpdateToOneWithWhereWithoutPolizasInput = {
    where?: companias_productosWhereInput
    data: XOR<companias_productosUpdateWithoutPolizasInput, companias_productosUncheckedUpdateWithoutPolizasInput>
  }

  export type companias_productosUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    compania?: companiaUpdateOneRequiredWithoutCompanias_productosNestedInput
    ramos?: ramosUpdateOneRequiredWithoutCompanias_productosNestedInput
  }

  export type companias_productosUncheckedUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ramosUpsertWithoutPolizasInput = {
    update: XOR<ramosUpdateWithoutPolizasInput, ramosUncheckedUpdateWithoutPolizasInput>
    create: XOR<ramosCreateWithoutPolizasInput, ramosUncheckedCreateWithoutPolizasInput>
    where?: ramosWhereInput
  }

  export type ramosUpdateToOneWithWhereWithoutPolizasInput = {
    where?: ramosWhereInput
    data: XOR<ramosUpdateWithoutPolizasInput, ramosUncheckedUpdateWithoutPolizasInput>
  }

  export type ramosUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companias_productos?: companias_productosUpdateManyWithoutRamosNestedInput
    companias_ramos?: companias_ramosUpdateManyWithoutRamosNestedInput
  }

  export type ramosUncheckedUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companias_productos?: companias_productosUncheckedUpdateManyWithoutRamosNestedInput
    companias_ramos?: companias_ramosUncheckedUpdateManyWithoutRamosNestedInput
  }

  export type usuariosUpsertWithoutPolizasInput = {
    update: XOR<usuariosUpdateWithoutPolizasInput, usuariosUncheckedUpdateWithoutPolizasInput>
    create: XOR<usuariosCreateWithoutPolizasInput, usuariosUncheckedCreateWithoutPolizasInput>
    where?: usuariosWhereInput
  }

  export type usuariosUpdateToOneWithWhereWithoutPolizasInput = {
    where?: usuariosWhereInput
    data: XOR<usuariosUpdateWithoutPolizasInput, usuariosUncheckedUpdateWithoutPolizasInput>
  }

  export type usuariosUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_team?: usuario_teamUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_team?: usuario_teamUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type tipos_de_vencimientoUpsertWithoutPolizasInput = {
    update: XOR<tipos_de_vencimientoUpdateWithoutPolizasInput, tipos_de_vencimientoUncheckedUpdateWithoutPolizasInput>
    create: XOR<tipos_de_vencimientoCreateWithoutPolizasInput, tipos_de_vencimientoUncheckedCreateWithoutPolizasInput>
    where?: tipos_de_vencimientoWhereInput
  }

  export type tipos_de_vencimientoUpdateToOneWithWhereWithoutPolizasInput = {
    where?: tipos_de_vencimientoWhereInput
    data: XOR<tipos_de_vencimientoUpdateWithoutPolizasInput, tipos_de_vencimientoUncheckedUpdateWithoutPolizasInput>
  }

  export type tipos_de_vencimientoUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tipos_de_vencimientoUncheckedUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companias_productosCreateWithoutRamosInput = {
    id?: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
    compania: companiaCreateNestedOneWithoutCompanias_productosInput
    polizas?: polizasCreateNestedManyWithoutCompanias_productosInput
  }

  export type companias_productosUncheckedCreateWithoutRamosInput = {
    id?: bigint | number
    compania_id: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
    polizas?: polizasUncheckedCreateNestedManyWithoutCompanias_productosInput
  }

  export type companias_productosCreateOrConnectWithoutRamosInput = {
    where: companias_productosWhereUniqueInput
    create: XOR<companias_productosCreateWithoutRamosInput, companias_productosUncheckedCreateWithoutRamosInput>
  }

  export type companias_productosCreateManyRamosInputEnvelope = {
    data: companias_productosCreateManyRamosInput | companias_productosCreateManyRamosInput[]
    skipDuplicates?: boolean
  }

  export type companias_ramosCreateWithoutRamosInput = {
    id?: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
    compania: companiaCreateNestedOneWithoutCompanias_ramosInput
  }

  export type companias_ramosUncheckedCreateWithoutRamosInput = {
    id?: bigint | number
    compania_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
  }

  export type companias_ramosCreateOrConnectWithoutRamosInput = {
    where: companias_ramosWhereUniqueInput
    create: XOR<companias_ramosCreateWithoutRamosInput, companias_ramosUncheckedCreateWithoutRamosInput>
  }

  export type companias_ramosCreateManyRamosInputEnvelope = {
    data: companias_ramosCreateManyRamosInput | companias_ramosCreateManyRamosInput[]
    skipDuplicates?: boolean
  }

  export type polizasCreateWithoutRamosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosCreateNestedManyWithoutPolizasInput
    clientes: clientesCreateNestedOneWithoutPolizasInput
    compania: companiaCreateNestedOneWithoutPolizasInput
    formas_de_pago: formas_de_pagoCreateNestedOneWithoutPolizasInput
    metodos_de_pago: metodos_de_pagoCreateNestedOneWithoutPolizasInput
    monedas: monedasCreateNestedOneWithoutPolizasInput
    companias_productos: companias_productosCreateNestedOneWithoutPolizasInput
    usuarios?: usuariosCreateNestedOneWithoutPolizasInput
    tipos_de_vencimiento: tipos_de_vencimientoCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateWithoutRamosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput
  }

  export type polizasCreateOrConnectWithoutRamosInput = {
    where: polizasWhereUniqueInput
    create: XOR<polizasCreateWithoutRamosInput, polizasUncheckedCreateWithoutRamosInput>
  }

  export type polizasCreateManyRamosInputEnvelope = {
    data: polizasCreateManyRamosInput | polizasCreateManyRamosInput[]
    skipDuplicates?: boolean
  }

  export type companias_productosUpsertWithWhereUniqueWithoutRamosInput = {
    where: companias_productosWhereUniqueInput
    update: XOR<companias_productosUpdateWithoutRamosInput, companias_productosUncheckedUpdateWithoutRamosInput>
    create: XOR<companias_productosCreateWithoutRamosInput, companias_productosUncheckedCreateWithoutRamosInput>
  }

  export type companias_productosUpdateWithWhereUniqueWithoutRamosInput = {
    where: companias_productosWhereUniqueInput
    data: XOR<companias_productosUpdateWithoutRamosInput, companias_productosUncheckedUpdateWithoutRamosInput>
  }

  export type companias_productosUpdateManyWithWhereWithoutRamosInput = {
    where: companias_productosScalarWhereInput
    data: XOR<companias_productosUpdateManyMutationInput, companias_productosUncheckedUpdateManyWithoutRamosInput>
  }

  export type companias_ramosUpsertWithWhereUniqueWithoutRamosInput = {
    where: companias_ramosWhereUniqueInput
    update: XOR<companias_ramosUpdateWithoutRamosInput, companias_ramosUncheckedUpdateWithoutRamosInput>
    create: XOR<companias_ramosCreateWithoutRamosInput, companias_ramosUncheckedCreateWithoutRamosInput>
  }

  export type companias_ramosUpdateWithWhereUniqueWithoutRamosInput = {
    where: companias_ramosWhereUniqueInput
    data: XOR<companias_ramosUpdateWithoutRamosInput, companias_ramosUncheckedUpdateWithoutRamosInput>
  }

  export type companias_ramosUpdateManyWithWhereWithoutRamosInput = {
    where: companias_ramosScalarWhereInput
    data: XOR<companias_ramosUpdateManyMutationInput, companias_ramosUncheckedUpdateManyWithoutRamosInput>
  }

  export type polizasUpsertWithWhereUniqueWithoutRamosInput = {
    where: polizasWhereUniqueInput
    update: XOR<polizasUpdateWithoutRamosInput, polizasUncheckedUpdateWithoutRamosInput>
    create: XOR<polizasCreateWithoutRamosInput, polizasUncheckedCreateWithoutRamosInput>
  }

  export type polizasUpdateWithWhereUniqueWithoutRamosInput = {
    where: polizasWhereUniqueInput
    data: XOR<polizasUpdateWithoutRamosInput, polizasUncheckedUpdateWithoutRamosInput>
  }

  export type polizasUpdateManyWithWhereWithoutRamosInput = {
    where: polizasScalarWhereInput
    data: XOR<polizasUpdateManyMutationInput, polizasUncheckedUpdateManyWithoutRamosInput>
  }

  export type usuario_teamCreateWithoutTipos_de_usuariosInput = {
    id?: bigint | number
    principal_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    usuarios: usuariosCreateNestedOneWithoutUsuario_teamInput
  }

  export type usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput = {
    id?: bigint | number
    principal_id: bigint | number
    usuario_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usuario_teamCreateOrConnectWithoutTipos_de_usuariosInput = {
    where: usuario_teamWhereUniqueInput
    create: XOR<usuario_teamCreateWithoutTipos_de_usuariosInput, usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput>
  }

  export type usuario_teamCreateManyTipos_de_usuariosInputEnvelope = {
    data: usuario_teamCreateManyTipos_de_usuariosInput | usuario_teamCreateManyTipos_de_usuariosInput[]
    skipDuplicates?: boolean
  }

  export type usuario_teamUpsertWithWhereUniqueWithoutTipos_de_usuariosInput = {
    where: usuario_teamWhereUniqueInput
    update: XOR<usuario_teamUpdateWithoutTipos_de_usuariosInput, usuario_teamUncheckedUpdateWithoutTipos_de_usuariosInput>
    create: XOR<usuario_teamCreateWithoutTipos_de_usuariosInput, usuario_teamUncheckedCreateWithoutTipos_de_usuariosInput>
  }

  export type usuario_teamUpdateWithWhereUniqueWithoutTipos_de_usuariosInput = {
    where: usuario_teamWhereUniqueInput
    data: XOR<usuario_teamUpdateWithoutTipos_de_usuariosInput, usuario_teamUncheckedUpdateWithoutTipos_de_usuariosInput>
  }

  export type usuario_teamUpdateManyWithWhereWithoutTipos_de_usuariosInput = {
    where: usuario_teamScalarWhereInput
    data: XOR<usuario_teamUpdateManyMutationInput, usuario_teamUncheckedUpdateManyWithoutTipos_de_usuariosInput>
  }

  export type usuario_teamScalarWhereInput = {
    AND?: usuario_teamScalarWhereInput | usuario_teamScalarWhereInput[]
    OR?: usuario_teamScalarWhereInput[]
    NOT?: usuario_teamScalarWhereInput | usuario_teamScalarWhereInput[]
    id?: BigIntFilter<"usuario_team"> | bigint | number
    principal_id?: BigIntFilter<"usuario_team"> | bigint | number
    tipo_id?: BigIntFilter<"usuario_team"> | bigint | number
    usuario_id?: BigIntFilter<"usuario_team"> | bigint | number
    estatus?: BoolFilter<"usuario_team"> | boolean
    created_at?: DateTimeNullableFilter<"usuario_team"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"usuario_team"> | Date | string | null
  }

  export type polizasCreateWithoutTipos_de_vencimientoInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosCreateNestedManyWithoutPolizasInput
    clientes: clientesCreateNestedOneWithoutPolizasInput
    compania: companiaCreateNestedOneWithoutPolizasInput
    formas_de_pago: formas_de_pagoCreateNestedOneWithoutPolizasInput
    metodos_de_pago: metodos_de_pagoCreateNestedOneWithoutPolizasInput
    monedas: monedasCreateNestedOneWithoutPolizasInput
    companias_productos: companias_productosCreateNestedOneWithoutPolizasInput
    ramos: ramosCreateNestedOneWithoutPolizasInput
    usuarios?: usuariosCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateWithoutTipos_de_vencimientoInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput
  }

  export type polizasCreateOrConnectWithoutTipos_de_vencimientoInput = {
    where: polizasWhereUniqueInput
    create: XOR<polizasCreateWithoutTipos_de_vencimientoInput, polizasUncheckedCreateWithoutTipos_de_vencimientoInput>
  }

  export type polizasCreateManyTipos_de_vencimientoInputEnvelope = {
    data: polizasCreateManyTipos_de_vencimientoInput | polizasCreateManyTipos_de_vencimientoInput[]
    skipDuplicates?: boolean
  }

  export type polizasUpsertWithWhereUniqueWithoutTipos_de_vencimientoInput = {
    where: polizasWhereUniqueInput
    update: XOR<polizasUpdateWithoutTipos_de_vencimientoInput, polizasUncheckedUpdateWithoutTipos_de_vencimientoInput>
    create: XOR<polizasCreateWithoutTipos_de_vencimientoInput, polizasUncheckedCreateWithoutTipos_de_vencimientoInput>
  }

  export type polizasUpdateWithWhereUniqueWithoutTipos_de_vencimientoInput = {
    where: polizasWhereUniqueInput
    data: XOR<polizasUpdateWithoutTipos_de_vencimientoInput, polizasUncheckedUpdateWithoutTipos_de_vencimientoInput>
  }

  export type polizasUpdateManyWithWhereWithoutTipos_de_vencimientoInput = {
    where: polizasScalarWhereInput
    data: XOR<polizasUpdateManyMutationInput, polizasUncheckedUpdateManyWithoutTipos_de_vencimientoInput>
  }

  export type companiaCreateWithoutUsuario_clavesInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania_representantes?: compania_representantesCreateNestedManyWithoutCompaniaInput
    companias_productos?: companias_productosCreateNestedManyWithoutCompaniaInput
    companias_ramos?: companias_ramosCreateNestedManyWithoutCompaniaInput
    polizas?: polizasCreateNestedManyWithoutCompaniaInput
  }

  export type companiaUncheckedCreateWithoutUsuario_clavesInput = {
    id?: bigint | number
    rfc: string
    nombre: string
    nombreCorto: string
    direccion?: string | null
    estado?: string | null
    codigoPostal?: string | null
    ciudad?: string | null
    limitePrimerPago?: Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: Decimal | DecimalJsLike | number | string | null
    estatus?: boolean | null
    colonia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    compania_representantes?: compania_representantesUncheckedCreateNestedManyWithoutCompaniaInput
    companias_productos?: companias_productosUncheckedCreateNestedManyWithoutCompaniaInput
    companias_ramos?: companias_ramosUncheckedCreateNestedManyWithoutCompaniaInput
    polizas?: polizasUncheckedCreateNestedManyWithoutCompaniaInput
  }

  export type companiaCreateOrConnectWithoutUsuario_clavesInput = {
    where: companiaWhereUniqueInput
    create: XOR<companiaCreateWithoutUsuario_clavesInput, companiaUncheckedCreateWithoutUsuario_clavesInput>
  }

  export type companiaUpsertWithoutUsuario_clavesInput = {
    update: XOR<companiaUpdateWithoutUsuario_clavesInput, companiaUncheckedUpdateWithoutUsuario_clavesInput>
    create: XOR<companiaCreateWithoutUsuario_clavesInput, companiaUncheckedCreateWithoutUsuario_clavesInput>
    where?: companiaWhereInput
  }

  export type companiaUpdateToOneWithWhereWithoutUsuario_clavesInput = {
    where?: companiaWhereInput
    data: XOR<companiaUpdateWithoutUsuario_clavesInput, companiaUncheckedUpdateWithoutUsuario_clavesInput>
  }

  export type companiaUpdateWithoutUsuario_clavesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania_representantes?: compania_representantesUpdateManyWithoutCompaniaNestedInput
    companias_productos?: companias_productosUpdateManyWithoutCompaniaNestedInput
    companias_ramos?: companias_ramosUpdateManyWithoutCompaniaNestedInput
    polizas?: polizasUpdateManyWithoutCompaniaNestedInput
  }

  export type companiaUncheckedUpdateWithoutUsuario_clavesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rfc?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    nombreCorto?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    codigoPostal?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    limitePrimerPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitePrimerSubsecuente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colonia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    compania_representantes?: compania_representantesUncheckedUpdateManyWithoutCompaniaNestedInput
    companias_productos?: companias_productosUncheckedUpdateManyWithoutCompaniaNestedInput
    companias_ramos?: companias_ramosUncheckedUpdateManyWithoutCompaniaNestedInput
    polizas?: polizasUncheckedUpdateManyWithoutCompaniaNestedInput
  }

  export type tipos_de_usuariosCreateWithoutUsuario_teamInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type tipos_de_usuariosUncheckedCreateWithoutUsuario_teamInput = {
    id?: bigint | number
    label: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type tipos_de_usuariosCreateOrConnectWithoutUsuario_teamInput = {
    where: tipos_de_usuariosWhereUniqueInput
    create: XOR<tipos_de_usuariosCreateWithoutUsuario_teamInput, tipos_de_usuariosUncheckedCreateWithoutUsuario_teamInput>
  }

  export type usuariosCreateWithoutUsuario_teamInput = {
    id?: bigint | number
    nombre: string
    correo: string
    password: string
    tipo_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    polizas?: polizasCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosUncheckedCreateWithoutUsuario_teamInput = {
    id?: bigint | number
    nombre: string
    correo: string
    password: string
    tipo_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    polizas?: polizasUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosCreateOrConnectWithoutUsuario_teamInput = {
    where: usuariosWhereUniqueInput
    create: XOR<usuariosCreateWithoutUsuario_teamInput, usuariosUncheckedCreateWithoutUsuario_teamInput>
  }

  export type tipos_de_usuariosUpsertWithoutUsuario_teamInput = {
    update: XOR<tipos_de_usuariosUpdateWithoutUsuario_teamInput, tipos_de_usuariosUncheckedUpdateWithoutUsuario_teamInput>
    create: XOR<tipos_de_usuariosCreateWithoutUsuario_teamInput, tipos_de_usuariosUncheckedCreateWithoutUsuario_teamInput>
    where?: tipos_de_usuariosWhereInput
  }

  export type tipos_de_usuariosUpdateToOneWithWhereWithoutUsuario_teamInput = {
    where?: tipos_de_usuariosWhereInput
    data: XOR<tipos_de_usuariosUpdateWithoutUsuario_teamInput, tipos_de_usuariosUncheckedUpdateWithoutUsuario_teamInput>
  }

  export type tipos_de_usuariosUpdateWithoutUsuario_teamInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tipos_de_usuariosUncheckedUpdateWithoutUsuario_teamInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuariosUpsertWithoutUsuario_teamInput = {
    update: XOR<usuariosUpdateWithoutUsuario_teamInput, usuariosUncheckedUpdateWithoutUsuario_teamInput>
    create: XOR<usuariosCreateWithoutUsuario_teamInput, usuariosUncheckedCreateWithoutUsuario_teamInput>
    where?: usuariosWhereInput
  }

  export type usuariosUpdateToOneWithWhereWithoutUsuario_teamInput = {
    where?: usuariosWhereInput
    data: XOR<usuariosUpdateWithoutUsuario_teamInput, usuariosUncheckedUpdateWithoutUsuario_teamInput>
  }

  export type usuariosUpdateWithoutUsuario_teamInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateWithoutUsuario_teamInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    polizas?: polizasUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type polizasCreateWithoutUsuariosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosCreateNestedManyWithoutPolizasInput
    clientes: clientesCreateNestedOneWithoutPolizasInput
    compania: companiaCreateNestedOneWithoutPolizasInput
    formas_de_pago: formas_de_pagoCreateNestedOneWithoutPolizasInput
    metodos_de_pago: metodos_de_pagoCreateNestedOneWithoutPolizasInput
    monedas: monedasCreateNestedOneWithoutPolizasInput
    companias_productos: companias_productosCreateNestedOneWithoutPolizasInput
    ramos: ramosCreateNestedOneWithoutPolizasInput
    tipos_de_vencimiento: tipos_de_vencimientoCreateNestedOneWithoutPolizasInput
  }

  export type polizasUncheckedCreateWithoutUsuariosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    poliza_recibos?: poliza_recibosUncheckedCreateNestedManyWithoutPolizasInput
  }

  export type polizasCreateOrConnectWithoutUsuariosInput = {
    where: polizasWhereUniqueInput
    create: XOR<polizasCreateWithoutUsuariosInput, polizasUncheckedCreateWithoutUsuariosInput>
  }

  export type polizasCreateManyUsuariosInputEnvelope = {
    data: polizasCreateManyUsuariosInput | polizasCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type usuario_teamCreateWithoutUsuariosInput = {
    id?: bigint | number
    principal_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    tipos_de_usuarios: tipos_de_usuariosCreateNestedOneWithoutUsuario_teamInput
  }

  export type usuario_teamUncheckedCreateWithoutUsuariosInput = {
    id?: bigint | number
    principal_id: bigint | number
    tipo_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usuario_teamCreateOrConnectWithoutUsuariosInput = {
    where: usuario_teamWhereUniqueInput
    create: XOR<usuario_teamCreateWithoutUsuariosInput, usuario_teamUncheckedCreateWithoutUsuariosInput>
  }

  export type usuario_teamCreateManyUsuariosInputEnvelope = {
    data: usuario_teamCreateManyUsuariosInput | usuario_teamCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type polizasUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: polizasWhereUniqueInput
    update: XOR<polizasUpdateWithoutUsuariosInput, polizasUncheckedUpdateWithoutUsuariosInput>
    create: XOR<polizasCreateWithoutUsuariosInput, polizasUncheckedCreateWithoutUsuariosInput>
  }

  export type polizasUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: polizasWhereUniqueInput
    data: XOR<polizasUpdateWithoutUsuariosInput, polizasUncheckedUpdateWithoutUsuariosInput>
  }

  export type polizasUpdateManyWithWhereWithoutUsuariosInput = {
    where: polizasScalarWhereInput
    data: XOR<polizasUpdateManyMutationInput, polizasUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type usuario_teamUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: usuario_teamWhereUniqueInput
    update: XOR<usuario_teamUpdateWithoutUsuariosInput, usuario_teamUncheckedUpdateWithoutUsuariosInput>
    create: XOR<usuario_teamCreateWithoutUsuariosInput, usuario_teamUncheckedCreateWithoutUsuariosInput>
  }

  export type usuario_teamUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: usuario_teamWhereUniqueInput
    data: XOR<usuario_teamUpdateWithoutUsuariosInput, usuario_teamUncheckedUpdateWithoutUsuariosInput>
  }

  export type usuario_teamUpdateManyWithWhereWithoutUsuariosInput = {
    where: usuario_teamScalarWhereInput
    data: XOR<usuario_teamUpdateManyMutationInput, usuario_teamUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type polizasCreateManyClientesInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type polizasUpdateWithoutClientesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUpdateManyWithoutPolizasNestedInput
    compania?: companiaUpdateOneRequiredWithoutPolizasNestedInput
    formas_de_pago?: formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    metodos_de_pago?: metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutPolizasNestedInput
    companias_productos?: companias_productosUpdateOneRequiredWithoutPolizasNestedInput
    ramos?: ramosUpdateOneRequiredWithoutPolizasNestedInput
    usuarios?: usuariosUpdateOneWithoutPolizasNestedInput
    tipos_de_vencimiento?: tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateWithoutClientesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateManyWithoutClientesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type compania_representantesCreateManyCompaniaInput = {
    id?: bigint | number
    nombre: string
    telefono: string
    correo: string
    cargo: string
    estatus?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type companias_productosCreateManyCompaniaInput = {
    id?: bigint | number
    ramo_id: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
  }

  export type companias_ramosCreateManyCompaniaInput = {
    id?: bigint | number
    ramo_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
  }

  export type polizasCreateManyCompaniaInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usuario_clavesCreateManyCompaniaInput = {
    id?: bigint | number
    clave: string
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    usuario_id: bigint | number
  }

  export type compania_representantesUpdateWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type compania_representantesUncheckedUpdateWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type compania_representantesUncheckedUpdateManyWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companias_productosUpdateWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ramos?: ramosUpdateOneRequiredWithoutCompanias_productosNestedInput
    polizas?: polizasUpdateManyWithoutCompanias_productosNestedInput
  }

  export type companias_productosUncheckedUpdateWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    polizas?: polizasUncheckedUpdateManyWithoutCompanias_productosNestedInput
  }

  export type companias_productosUncheckedUpdateManyWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companias_ramosUpdateWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ramos?: ramosUpdateOneRequiredWithoutCompanias_ramosNestedInput
  }

  export type companias_ramosUncheckedUpdateWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companias_ramosUncheckedUpdateManyWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type polizasUpdateWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUpdateManyWithoutPolizasNestedInput
    clientes?: clientesUpdateOneRequiredWithoutPolizasNestedInput
    formas_de_pago?: formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    metodos_de_pago?: metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutPolizasNestedInput
    companias_productos?: companias_productosUpdateOneRequiredWithoutPolizasNestedInput
    ramos?: ramosUpdateOneRequiredWithoutPolizasNestedInput
    usuarios?: usuariosUpdateOneWithoutPolizasNestedInput
    tipos_de_vencimiento?: tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateManyWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuario_clavesUpdateWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    clave?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type usuario_clavesUncheckedUpdateWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    clave?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type usuario_clavesUncheckedUpdateManyWithoutCompaniaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    clave?: StringFieldUpdateOperationsInput | string
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type polizasCreateManyCompanias_productosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type polizasUpdateWithoutCompanias_productosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUpdateManyWithoutPolizasNestedInput
    clientes?: clientesUpdateOneRequiredWithoutPolizasNestedInput
    compania?: companiaUpdateOneRequiredWithoutPolizasNestedInput
    formas_de_pago?: formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    metodos_de_pago?: metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutPolizasNestedInput
    ramos?: ramosUpdateOneRequiredWithoutPolizasNestedInput
    usuarios?: usuariosUpdateOneWithoutPolizasNestedInput
    tipos_de_vencimiento?: tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateWithoutCompanias_productosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateManyWithoutCompanias_productosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type polizasCreateManyFormas_de_pagoInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type polizasUpdateWithoutFormas_de_pagoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUpdateManyWithoutPolizasNestedInput
    clientes?: clientesUpdateOneRequiredWithoutPolizasNestedInput
    compania?: companiaUpdateOneRequiredWithoutPolizasNestedInput
    metodos_de_pago?: metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutPolizasNestedInput
    companias_productos?: companias_productosUpdateOneRequiredWithoutPolizasNestedInput
    ramos?: ramosUpdateOneRequiredWithoutPolizasNestedInput
    usuarios?: usuariosUpdateOneWithoutPolizasNestedInput
    tipos_de_vencimiento?: tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateWithoutFormas_de_pagoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateManyWithoutFormas_de_pagoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type polizasCreateManyMetodos_de_pagoInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type polizasUpdateWithoutMetodos_de_pagoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUpdateManyWithoutPolizasNestedInput
    clientes?: clientesUpdateOneRequiredWithoutPolizasNestedInput
    compania?: companiaUpdateOneRequiredWithoutPolizasNestedInput
    formas_de_pago?: formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutPolizasNestedInput
    companias_productos?: companias_productosUpdateOneRequiredWithoutPolizasNestedInput
    ramos?: ramosUpdateOneRequiredWithoutPolizasNestedInput
    usuarios?: usuariosUpdateOneWithoutPolizasNestedInput
    tipos_de_vencimiento?: tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateWithoutMetodos_de_pagoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateManyWithoutMetodos_de_pagoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type polizasCreateManyMonedasInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type polizasUpdateWithoutMonedasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUpdateManyWithoutPolizasNestedInput
    clientes?: clientesUpdateOneRequiredWithoutPolizasNestedInput
    compania?: companiaUpdateOneRequiredWithoutPolizasNestedInput
    formas_de_pago?: formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    metodos_de_pago?: metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    companias_productos?: companias_productosUpdateOneRequiredWithoutPolizasNestedInput
    ramos?: ramosUpdateOneRequiredWithoutPolizasNestedInput
    usuarios?: usuariosUpdateOneWithoutPolizasNestedInput
    tipos_de_vencimiento?: tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateWithoutMonedasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateManyWithoutMonedasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_recibosCreateManyPolizasInput = {
    id?: bigint | number
    numeroRecibo: string
    vencimiento: Date | string
    importe: Decimal | DecimalJsLike | number | string
    estatus?: $Enums.poliza_recibos_estatus
    fechaPago?: Date | string | null
    fechaCancelado?: Date | string | null
    evidencia?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type poliza_recibosUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroRecibo?: StringFieldUpdateOperationsInput | string
    vencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    importe?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusFieldUpdateOperationsInput | $Enums.poliza_recibos_estatus
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCancelado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_recibosUncheckedUpdateWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroRecibo?: StringFieldUpdateOperationsInput | string
    vencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    importe?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusFieldUpdateOperationsInput | $Enums.poliza_recibos_estatus
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCancelado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type poliza_recibosUncheckedUpdateManyWithoutPolizasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroRecibo?: StringFieldUpdateOperationsInput | string
    vencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    importe?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus?: Enumpoliza_recibos_estatusFieldUpdateOperationsInput | $Enums.poliza_recibos_estatus
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCancelado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companias_productosCreateManyRamosInput = {
    id?: bigint | number
    compania_id: bigint | number
    nombre: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
  }

  export type companias_ramosCreateManyRamosInput = {
    id?: bigint | number
    compania_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    estatus?: boolean | null
  }

  export type polizasCreateManyRamosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type companias_productosUpdateWithoutRamosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    compania?: companiaUpdateOneRequiredWithoutCompanias_productosNestedInput
    polizas?: polizasUpdateManyWithoutCompanias_productosNestedInput
  }

  export type companias_productosUncheckedUpdateWithoutRamosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    polizas?: polizasUncheckedUpdateManyWithoutCompanias_productosNestedInput
  }

  export type companias_productosUncheckedUpdateManyWithoutRamosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companias_ramosUpdateWithoutRamosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    compania?: companiaUpdateOneRequiredWithoutCompanias_ramosNestedInput
  }

  export type companias_ramosUncheckedUpdateWithoutRamosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companias_ramosUncheckedUpdateManyWithoutRamosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type polizasUpdateWithoutRamosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUpdateManyWithoutPolizasNestedInput
    clientes?: clientesUpdateOneRequiredWithoutPolizasNestedInput
    compania?: companiaUpdateOneRequiredWithoutPolizasNestedInput
    formas_de_pago?: formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    metodos_de_pago?: metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutPolizasNestedInput
    companias_productos?: companias_productosUpdateOneRequiredWithoutPolizasNestedInput
    usuarios?: usuariosUpdateOneWithoutPolizasNestedInput
    tipos_de_vencimiento?: tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateWithoutRamosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateManyWithoutRamosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuario_teamCreateManyTipos_de_usuariosInput = {
    id?: bigint | number
    principal_id: bigint | number
    usuario_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usuario_teamUpdateWithoutTipos_de_usuariosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    principal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarios?: usuariosUpdateOneRequiredWithoutUsuario_teamNestedInput
  }

  export type usuario_teamUncheckedUpdateWithoutTipos_de_usuariosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    principal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuario_teamUncheckedUpdateManyWithoutTipos_de_usuariosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    principal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuario_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type polizasCreateManyTipos_de_vencimientoInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    compania_id: bigint | number
    subAgente_id?: bigint | number | null
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type polizasUpdateWithoutTipos_de_vencimientoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUpdateManyWithoutPolizasNestedInput
    clientes?: clientesUpdateOneRequiredWithoutPolizasNestedInput
    compania?: companiaUpdateOneRequiredWithoutPolizasNestedInput
    formas_de_pago?: formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    metodos_de_pago?: metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutPolizasNestedInput
    companias_productos?: companias_productosUpdateOneRequiredWithoutPolizasNestedInput
    ramos?: ramosUpdateOneRequiredWithoutPolizasNestedInput
    usuarios?: usuariosUpdateOneWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateWithoutTipos_de_vencimientoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateManyWithoutTipos_de_vencimientoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subAgente_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type polizasCreateManyUsuariosInput = {
    id?: bigint | number
    numeroPoliza?: string | null
    numeroCliente?: string | null
    inicioVigencia: Date | string
    finVigencia: Date | string
    antiguedad: number
    primaNeta: Decimal | DecimalJsLike | number | string
    financiamiento?: Decimal | DecimalJsLike | number | string | null
    primaTotal: Decimal | DecimalJsLike | number | string
    estatus_id: bigint | number
    comisionAgente?: Decimal | DecimalJsLike | number | string | null
    pagoInicial: Decimal | DecimalJsLike | number | string
    pagoSubsecuente: Decimal | DecimalJsLike | number | string
    cliente_id: bigint | number
    formaPago_id: bigint | number
    tipoVencimiento_id: bigint | number
    compania_id: bigint | number
    ramo_id: bigint | number
    metodoPago_id: bigint | number
    moneda_id: bigint | number
    producto_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usuario_teamCreateManyUsuariosInput = {
    id?: bigint | number
    principal_id: bigint | number
    tipo_id: bigint | number
    estatus?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type polizasUpdateWithoutUsuariosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUpdateManyWithoutPolizasNestedInput
    clientes?: clientesUpdateOneRequiredWithoutPolizasNestedInput
    compania?: companiaUpdateOneRequiredWithoutPolizasNestedInput
    formas_de_pago?: formas_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    metodos_de_pago?: metodos_de_pagoUpdateOneRequiredWithoutPolizasNestedInput
    monedas?: monedasUpdateOneRequiredWithoutPolizasNestedInput
    companias_productos?: companias_productosUpdateOneRequiredWithoutPolizasNestedInput
    ramos?: ramosUpdateOneRequiredWithoutPolizasNestedInput
    tipos_de_vencimiento?: tipos_de_vencimientoUpdateOneRequiredWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateWithoutUsuariosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poliza_recibos?: poliza_recibosUncheckedUpdateManyWithoutPolizasNestedInput
  }

  export type polizasUncheckedUpdateManyWithoutUsuariosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    numeroPoliza?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCliente?: NullableStringFieldUpdateOperationsInput | string | null
    inicioVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    finVigencia?: DateTimeFieldUpdateOperationsInput | Date | string
    antiguedad?: IntFieldUpdateOperationsInput | number
    primaNeta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    financiamiento?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    primaTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estatus_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comisionAgente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pagoInicial?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pagoSubsecuente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_id?: BigIntFieldUpdateOperationsInput | bigint | number
    formaPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipoVencimiento_id?: BigIntFieldUpdateOperationsInput | bigint | number
    compania_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ramo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    metodoPago_id?: BigIntFieldUpdateOperationsInput | bigint | number
    moneda_id?: BigIntFieldUpdateOperationsInput | bigint | number
    producto_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuario_teamUpdateWithoutUsuariosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    principal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipos_de_usuarios?: tipos_de_usuariosUpdateOneRequiredWithoutUsuario_teamNestedInput
  }

  export type usuario_teamUncheckedUpdateWithoutUsuariosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    principal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuario_teamUncheckedUpdateManyWithoutUsuariosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    principal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tipo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    estatus?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}